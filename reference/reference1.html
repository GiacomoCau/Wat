<!DOCTYPE html>
<html>
  <head>
    <title>
      1. Core Built-Ins for Macro and Definition Forms
    </title>
    <meta charset="UTF-8"/>
    <style>
      body { margin-left: 2%; }
      ul { list-style-type: none; }
      a { text-decoration: none; }
    </style>
  </head>
  <body>
    <br/>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference0.html">
      <input type="button" value="&lt;" disabled/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference.html">
      <input type="button" value="^"/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference2.html">
      <input type="button" value="&gt;"/>
    </a>
    <h2>
      1. Core Built-Ins for Macro and Definition Forms
    </h2>
    <div>
      <h3>
        def
      </h3>
      <ul>
        <li>
          (<b>def</b> definiendTree value)
          <br/>
            (<b>def</b> definiendTree bindResult value)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax definiendTree (or symbol decomposeTree))
          <br/>
            (syntax bindResult (or #ignore #inert :rhs :prv :cnt))
          <br/>
            &nbsp;
          <br/>
            (syntax decomposeTree (parametersTree . decomposeTree))
          <br/>
            (syntax parametersTree (or #null ignore symbol decomposeTree))
          <br/>
            (syntax symbol (or Symbol (#: check Symbol)))
          <br/>
            (syntax ignore (or #ignore (#: check #ignore)))
          <br/>
            (syntax check Any)
          <br/>
            (syntax check class)
          <br/>
            (syntax check checks)
          <br/>
            (syntax checks (check . checks))
          <br/>
            (syntax check (min . checks))
          <br/>
            (syntax check (min max . checks))
          <br/>
            (syntax check (min oo . checks))
          <br/>
            (syntax check (or . checks))
          <br/>
            (syntax check (and . checks))
          <br/>
            (syntax check (Apv . arguments))
          <br/>
            (syntax check value)
          <br/>
            (syntax arguments (value . arguments))
          <br/>
            &nbsp;
          <br/>
            Defines into the current environment the resulting bindings from the match of the <b>definiendTree</b> against <b>value</b>, signals an error otherwise.
          <br/>
            &nbsp;
          <br/>
            without <b>bindResult</b> or with <b>bindResult</b> #ignore use as bindResult `(bndRes)'
          <br/>
            with <b>bindResult</b> #inert return #inert
          <br/>
            with <b>bindResult</b> :rhs return the right side of the last binding
          <br/>
            with <b>bindResult</b> :prv return the previous value of the last binding
          <br/>
            with <b>bindResult</b> :cnt return the env
        </li>
      </ul>
    </div>
    <div>
      <h3>
        set!
      </h3>
      <ul>
        <li>
          (<b>set!</b> definiendTree value)
          <br/>
            (<b>set!</b> definiendTree bindResult value)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax definiendTree (or symbol decomposeTree))
          <br/>
            (syntax bindResult (or #ignore #inert :rhs :prv :cnt))
          <br/>
            &nbsp;
          <br/>
            (syntax decomposeTree (parametersTree . decomposeTree))
          <br/>
            (syntax parametersTree (or #null ignore symbol decomposeTree))
          <br/>
            (syntax symbol (or Symbol (#: check Symbol)))
          <br/>
            (syntax ignore (or #ignore (#: check #ignore)))
          <br/>
            (syntax check Any)
          <br/>
            (syntax check class)
          <br/>
            (syntax check checks)
          <br/>
            (syntax checks (check . checks))
          <br/>
            (syntax check (min . checks))
          <br/>
            (syntax check (min max . checks))
          <br/>
            (syntax check (min oo . checks))
          <br/>
            (syntax check (or . checks))
          <br/>
            (syntax check (and . checks))
          <br/>
            (syntax check (Apv . arguments))
          <br/>
            (syntax check value)
          <br/>
            (syntax arguments (value . arguments))
          <br/>
            &nbsp;
          <br/>
            Update into the environment the resulting bindings from the match of the <b>definiendTree</b> against <b>value</b>, signals an error if a binding is not defined.
          <br/>
            &nbsp;
          <br/>
            without <b>bindResult</b> or with <b>bindResult</b> #ignore use as bindResult `(bndRes)'
          <br/>
            with <b>bindResult</b> #inert return #inert
          <br/>
            with <b>bindResult</b> :rhs return the right side of the last binding
          <br/>
            with <b>bindResult</b> :prv return the previous value of the last binding
          <br/>
            with <b>bindResult</b> :cnt return the env
        </li>
      </ul>
    </div>
    <div>
      <h3>
        vau
      </h3>
      <ul>
        <li>
          (<b>vau</b> parametersTree environmentParameter . body)
          <br/>
            (<b>vau</b> parametersTree environmentParameter #: check . body)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax parametersTree (or #null ignore symbol decomposeTree))
          <br/>
            (syntax environmentParameter (or #ignore Symbol))
          <br/>
            (syntax body (or forms (#: check . forms)))
          <br/>
            &nbsp;
          <br/>
            (syntax decomposeTree (parametersTree . decomposeTree))
          <br/>
            (syntax symbol (or Symbol (#: check Symbol)))
          <br/>
            (syntax ignore (or #ignore (#: check #ignore)))
          <br/>
            (syntax check Any)
          <br/>
            (syntax check class)
          <br/>
            (syntax check checks)
          <br/>
            (syntax checks (check . checks))
          <br/>
            (syntax check (min . checks))
          <br/>
            (syntax check (min max . checks))
          <br/>
            (syntax check (min oo . checks))
          <br/>
            (syntax check (or . checks))
          <br/>
            (syntax check (and . checks))
          <br/>
            (syntax check (Apv . arguments))
          <br/>
            (syntax check value)
          <br/>
            (syntax arguments (value . arguments))
          <br/>
            &nbsp;
          <br/>
            Return a anonymous fexpr with the given <b>parameterTree</b>, <b>environmentParameter</b> and <b>body</b>.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        begin
      </h3>
      <ul>
        <li>
          (<b>begin</b> . forms)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            Sequentially evaluate <b>forms</b> returning the value of the last one, #inert if <b>forms</b> is #null.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        if
      </h3>
      <ul>
        <li>
          (<b>if</b> test thenForm . forms)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax forms (or () (elseForm) (test thenForm . forms)))
          <br/>
            &nbsp;
          <br/>
            (derivation (vau (test thenForm . forms) env (if (eval test env) (eval thenForm env) (null? forms) #inert (null? (cdr forms)) (eval (car forms) env) (apply if forms env))))
          <br/>
            &nbsp;
          <br/>
            Evaluate the <b>test</b> which must yield a boolean.
          <br/>
            Then evaluate either the <b>thenForm</b> or <b>elseForm</b> expression depending on whether the <b>test</b> yielded #true or #false.
          <br/>
            Idea stolen from Anarki https://github.com/arclanguage/anarki
        </li>
      </ul>
    </div>
    <div>
      <h3>
        wrap
      </h3>
      <ul>
        <li>
          (<b>wrap</b> operator)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            Return a new function that wraps around the underlying <b>operator</b>, and induces argument evaluations around it.
          <br/>
            Does not wrap the `Apv` and the `java functions`, but wraps the remaining `Combinator`.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        theEnv
      </h3>
      <ul>
        <li>
          (<b>theEnv</b>)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (derivation (vau () environment environment))
          <br/>
            &nbsp;
          <br/>
            Return the current environment.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        eval
      </h3>
      <ul>
        <li>
          (<b>eval</b> form . environment)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (eval form (if (null? environment) (theEnv) (car! environment))))
          <br/>
            &nbsp;
          <br/>
            Return the result of evaluation of <b>form</b> in the optional <b>environment</b>.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        \
      </h3>
      <ul>
        <li>
          (<b>\</b> parameterTree . forms)
          <br/>
            (<b>\</b> parameterTree #: check . forms)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (vau (parameterTree . forms) env (wrap (eval (list* 'vau parameterTree #ignore forms) env))))
          <br/>
            &nbsp;
          <br/>
            Return an anonymous function with the given <b>parameterTree</b> and <b>forms</b> as body,
          <br/>
            which use the definition environment for evaluate <b>forms</b> as an implicit `begin' and get the values of the free variables.
          <br/>
            The classic Scheme static lambda.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        lambda
      </h3>
      <ul>
        <li>
          (aliasof \. :-)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        unwrap
      </h3>
      <ul>
        <li>
          (<b>unwrap</b> function)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            Return the underlying operator of a <b>function</b>.
          <br/>
            Unwraps the `Apv`, wraps the `java functions` in a `JFun` and does not unwrap the remaining `Combinator`.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        apply
      </h3>
      <ul>
        <li>
          (<b>apply</b> fun args . environment)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (eval (cons (unwrap fun) args) (if (null? environment) (newEnv) (car! environment)) ))
          <br/>
            &nbsp;
          <br/>
            Call the <b>function</b> with a dynamically-supplied list of <b>arguments</b> in the optional <b>environment</b>.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        car
      </h3>
      <ul>
        <li>
          (<b>car</b> cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((car . #_)) car)) cons)
          <br/>
            (derivation (@car cons))
          <br/>
            &nbsp;
          <br/>
            Return the contents of the address part of the register.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        car!
      </h3>
      <ul>
        <li>
          (<b>car!</b> cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((car)) car)) cons)
          <br/>
            &nbsp;
          <br/>
            Return the contents of the address part of the register
          <br/>
            if decrement part of the register is #null, signals an error otherwise.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cadr
      </h3>
      <ul>
        <li>
          (<b>cadr</b> cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((#_ cadr . #_)) cadr)) cons)
          <br/>
            (derivation (car (cdr cons)))
          <br/>
            (derivation (@car cons 1))
          <br/>
            &nbsp;
          <br/>
            Return the `car' of the `cdr' of the <b>cons</b>.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cdr
      </h3>
      <ul>
        <li>
          (<b>cdr</b> cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((#_ . cdr)) cdr)) cons)
          <br/>
            (derivation (@cdr cons))
          <br/>
            &nbsp;
          <br/>
            Return the contents of the decrement part of the register.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cons
      </h3>
      <ul>
        <li>
          (<b>cons</b> car cdr)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (@new vm Cons car cdr))
          <br/>
            (derivation (@new Cons car cdr))
          <br/>
            &nbsp;
          <br/>
            Return a cons with the given <b>car</b> and <b>cdr</b>.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cons?
      </h3>
      <ul>
        <li>
          (<b>cons?</b> object)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (type? object Cons))
          <br/>
            &nbsp;
          <br/>
            Return #true if the <b>object</b> is a cons, #false otherwise.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        atom?
      </h3>
      <ul>
        <li>
          (<b>atom?</b> object)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (if (cons? object) #f #t))
          <br/>
            &nbsp;
          <br/>
            Return #true if the <b>object</b> is not a cons, #false otherwise.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        list
      </h3>
      <ul>
        <li>
          (<b>list</b> . arguments)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (wrap (vau arguments #ignore arguments)))
          <br/>
            &nbsp;
          <br/>
            Return the list of evaluated <b>arguments</b>.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        list*
      </h3>
      <ul>
        <li>
          (<b>list*</b> . arguments)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (if (null? arguments) () (((\ (loop) (def loop :rhs (\ ((car . cdr)) (if (null? cdr) car (cons car (loop cdr)))))) #inert) arguments))) 
          <br/>
            (derivation (if (null? arguments) () ((rec\ (loop (car . cdr)) (if (null? cdr) car (cons car (loop cdr)))) arguments)))
          <br/>
            &nbsp;
          <br/>
            Return a list of evaluated <b>arguments</b> so that
          <br/>
            the last argument becomes the `cdr' of the list.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        null?
      </h3>
      <ul>
        <li>
          (<b>null?</b> object)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (type? object Null))
          <br/>
            &nbsp;
          <br/>
            Return #true if the <b>object</b> is #null, #false otherwise.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        quote
      </h3>
      <ul>
        <li>
          (<b>quote</b> operand)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (derivation (vau (operand) #ignore operand))
          <br/>
            &nbsp;
          <br/>
            Return the unevaluated <b>operand</b>.
        </li>
      </ul>
    </div>
    <div>
      <h3>
        assert
      </h3>
      <ul>
        <li>
          (<b>assert</b> expression value)
          <br/>
            (<b>assert</b> expression)
          <br/>
            (<b>assert</b> expression class attribute value . attributes)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax attributes (attribute value . attributes))
          <br/>
            (syntax attribute (or Symbol Keyword String .Field @Method))
          <br/>
            &nbsp;
          <br/>
            Signals an error if:
          <br/>
            - <b>expression</b> does not equal <b>value</b>
          <br/>
            - <b>value</b> is not present and the <b>expression</b> does not throws
          <br/>
            - <b>expression</b> throws or returns an object and the object is not of the same <b>class</b> with the <b>attributes</b> of the given <b>value</b>.
        </li>
      </ul>
    </div>
    <br/>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference0.html">
      <input type="button" value="&lt;" disabled/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference.html">
      <input type="button" value="^"/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference2.html">
      <input type="button" value="&gt;"/>
    </a>
  </body>
</html>
