<!DOCTYPE html>
<html>
  <head>
    <title>
      1. Core Built-Ins for Macro and Definition Forms
    </title>
    <meta charset="UTF-8"/>
    <style>
      body { font-family: consolas; }
      ul { list-style-type: none; }
      a { text-decoration: none; }
    </style>
  </head>
  <body>
    <br/>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference0.html">
      <input type="button" value="&lt;" disabled/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference.html">
      <input type="button" value="^"/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference2.html">
      <input type="button" value="&gt;"/>
    </a>
    <h2>
      1. Core Built-Ins for Macro and Definition Forms
    </h2>
    <div>
      <h3>
        def
      </h3>
      <ul>
        <li>
          Match the DEFINIEND-TREE against the VALUE and place resulting bindings into the current environment.
          <br/>
            without bindResult or with bindResult #ignore use as bindResult (bndRes)
          <br/>
            with bindResult #inert return #inert
          <br/>
            with bindResult :rhs return the right side of the last binding
          <br/>
            with bindResult :prv return the previous value of the last binding
          <br/>
            with bindResult :obj return the env
        </li>
        <li>
          $(fn definiendTree value)
        </li>
        <li>
          $(fn definiendTree bindResult value)
        </li>
        <li>
          $(syntax bindResult (or #ignore #inert :rhs :prv))  
        </li>
        <li>
          $(type fexpr)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        vau
      </h3>
      <ul>
        <li>
          Construct a fexpr with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER, and FORMS.
        </li>
        <li>
          $(fn parameterTree environmentParameter . forms)
        </li>
        <li>
          $(type fexpr)
        </li>
        <li>
          $(derivation (vau (pt ep . forms) env (eval (list 'vau pt ep (cons 'begin forms)) env)))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        \
      </h3>
      <ul>
        <li>
          Create an anonymous function with the given PARAMETER-TREE and FORMS.
        </li>
        <li>
          $(fn parameterTree . forms)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (vau (parameterTree . forms) env (wrap (eval (list* 'vau parameterTree #ignore forms) env))))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        lambda
      </h3>
      <ul>
        <li>
          alias for \ :-)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        wrap
      </h3>
      <ul>
        <li>
          Create a new function that wraps around an underlying OPERATOR, and induces argument evaluation around it.
        </li>
        <li>
          $(fn operator)
        </li>
        <li>
          $(type function)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        assert
      </h3>
      <ul>
        <li>
          Reports an error if:
          <br/>
            - EXPRESSION does not equal VALUE
          <br/>
            - VALUE is not present and the EXPRESSION does not throws
          <br/>
            - EXPRESSION throws or returns an object and the object is not of the same CLASS with the ATTRIBUTES of the specified VALUE.
        </li>
        <li>
          $(fn expression value)
        </li>
        <li>
          $(fn expression)
        </li>
        <li>
          $(fn expression class attribute value . attributes)
        </li>
        <li>
          $(syntax attributes (or () (attribute value . attributes)))
        </li>
        <li>
          $(syntax attribute (or Symbol Keyword String .Field @Method))
        </li>
        <li>
          $(type fexpr)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        apply
      </h3>
      <ul>
        <li>
          Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
        </li>
        <li>
          $(fn fun args . env)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (eval (cons (unwrap fun) args) (if (null? env) (newEnv) (car! env)) ))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        begin
      </h3>
      <ul>
        <li>
          Sequentially evaluate FORMS, returning the value of the last one, or void if there are no forms.
        </li>
        <li>
          $(fn . forms)
        </li>
        <li>
          $(type fexpr)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        car
      </h3>
      <ul>
        <li>
          Return the contents of the address part of the register.
        </li>
        <li>
          $(fn cons)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (\ ((car . #_)) car))
        </li>
        <li>
          $(derivation (@car cons))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        car!
      </h3>
      <ul>
        <li>
          Return the contents of the address part of the register
          <br/>
            if decrement part of the register is null, else error.
        </li>
        <li>
          $(fn cons)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (\ ((car)) car))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cadr
      </h3>
      <ul>
        <li>
          Return the `car' of the `cdr' of the CONS.
        </li>
        <li>
          $(fn cons)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (\ ((#_ cadr . #_)) cadr))
        </li>
        <li>
          $(derivation (car (cdr cons)))
        </li>
        <li>
          $(derivation (@car cons 1))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cdr
      </h3>
      <ul>
        <li>
          Return the contents of the decrement part of the register.
        </li>
        <li>
          $(fn cons)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (\ ((#_ . cdr)) cdr))
        </li>
        <li>
          $(derivation (@cdr cons))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cons
      </h3>
      <ul>
        <li>
          Create a cons with the given CAR and CDR.
        </li>
        <li>
          $(fn car cdr)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (@new vm Cons car cdr))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cons?
      </h3>
      <ul>
        <li>
          Return true if the OBJECT is a cons, false otherwise.
        </li>
        <li>
          $(fn object)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (\ (object) (type? object Cons)))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        eval
      </h3>
      <ul>
        <li>
          Evaluate the FORM in the ENVIRONMENT, returning its result.
        </li>
        <li>
          $(fn form . environment)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (eval (if (null? environment) ((vau () env env)) (car! environment))))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        if
      </h3>
      <ul>
        <li>
          Evaluate the TEST which must yield a boolean.
          <br/>
            Then evaluate either the THEN or ELSE expression
          <br/>
            depending on whether the TEST yielded true or false.
        </li>
        <li>
          $(fn test then . forms)
        </li>
        <li>
          $(syntax forms (or () (else) (test then . forms)))
        </li>
        <li>
          $(type fexpr)
        </li>
        <li>
          $(derivation (vau (test then . forms) env (if (eval test env) (eval then env) (null? forms) #inert (null? (cdr forms)) (eval (car forms) env) (apply if forms env))))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        list
      </h3>
      <ul>
        <li>
          Return the list of evaluated ARGUMENTS.
        </li>
        <li>
          $(fn . arguments)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (wrap (vau arguments #ignore arguments)))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        list*
      </h3>
      <ul>
        <li>
          Create a list of evaluated ARGUMENTS so that
          <br/>
            the last argument becomes the `cdr' of the list.
        </li>
        <li>
          $(fn . arguments)
        </li>
        <li>
          $(type function)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        newBox
      </h3>
      <ul>
        <li>
          Create a new box with the optional VALUE.
          <br/>
            The Box are functions that encapsulates a mutable value.
          <br/>
            Calling the box without arguments returns the value in the box.
          <br/>
            Calling the box with an attribute update the value in the box.
        </li>
        <li>
          $(fn)
        </li>
        <li>
          $(fn value)
        </li>
        <li>
          $(type function)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        null?
      </h3>
      <ul>
        <li>
          Return true if the OBJECT is nil, false otherwise.
        </li>
        <li>
          $(fn object)
        </li>
        <li>
          $(type function)
        </li>
        <li>
          $(derivation (\ (object) (type? object Null)))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        quote
      </h3>
      <ul>
        <li>
          Return the unevaluated OPERAND.
        </li>
        <li>
          $(fn operand)
        </li>
        <li>
          $(type fexpr)
        </li>
        <li>
          $(derivation (vau (operand) #ignore operand))
        </li>
      </ul>
    </div>
    <br/>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference0.html">
      <input type="button" value="&lt;" disabled/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference.html">
      <input type="button" value="^"/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference2.html">
      <input type="button" value="&gt;"/>
    </a>
  </body>
</html>
