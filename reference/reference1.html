<!DOCTYPE html>
<html>
  <head>
    <title>
      1. Core Built-Ins for Macro and Definition Forms
    </title>
    <meta charset="UTF-8"/>
    <style>
      body { margin-left: 2%; }
      ul { list-style-type: none; }
      a { text-decoration: none; }
    </style>
  </head>
  <body>
    <br/>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference0.html">
      <input type="button" value="&lt;" disabled/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference.html">
      <input type="button" value="^"/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference2.html">
      <input type="button" value="&gt;"/>
    </a>
    <h2>
      1. Core Built-Ins for Macro and Definition Forms
    </h2>
    <div>
      <h3>
        def
      </h3>
      <ul>
        <li>
          Defines into the current environment the resulting bindings from the match of the <b>definiendTree</b> against <b>value</b>, signals an error otherwise.
          <br/>
            &nbsp;
          <br/>
            without <b>bindResult</b> or with <b>bindResult</b> #ignore use as bindResult `(bndRes)'
          <br/>
            with <b>bindResult</b> #inert return #inert
          <br/>
            with <b>bindResult</b> :rhs return the right side of the last binding
          <br/>
            with <b>bindResult</b> :prv return the previous value of the last binding
          <br/>
            with <b>bindResult</b> :cnt return the env
          <br/>
            &nbsp;
          <br/>
            (def definiendTree value)
          <br/>
            (def definiendTree bindResult value)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax definiendTree (or symbol decomposeTree))
          <br/>
            (syntax bindResult (or #ignore #inert :rhs :prv :cnt))
          <br/>
            &nbsp;
          <br/>
            (syntax decomposeTree (parametersTree . decomposeTree))
          <br/>
            (syntax parametersTree (or #null ignore symbol decomposeTree))
          <br/>
            (syntax symbol (or Symbol (#: check Symbol)))
          <br/>
            (syntax ignore (or #ignore (#: check #ignore)))
          <br/>
            (syntax check Any)
          <br/>
            (syntax check Class)
          <br/>
            (syntax check checks)
          <br/>
            (syntax checks (check . checks))
          <br/>
            (syntax check (min . checks))
          <br/>
            (syntax check (min max . checks))
          <br/>
            (syntax check (min oo . checks))
          <br/>
            (syntax check (or . checks))
          <br/>
            (syntax check (and . checks))
          <br/>
            (syntax check (Apv . arguments))
          <br/>
            (syntax check value)
          <br/>
            (syntax arguments (value . arguments))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        set!
      </h3>
      <ul>
        <li>
          Update into the environment the resulting bindings from the match of the <b>definiendTree</b> against <b>value</b>, signals an error if a binding is not defined.
          <br/>
            &nbsp;
          <br/>
            without <b>bindResult</b> or with <b>bindResult</b> #ignore use as bindResult `(bndRes)'
          <br/>
            with <b>bindResult</b> #inert return #inert
          <br/>
            with <b>bindResult</b> :rhs return the right side of the last binding
          <br/>
            with <b>bindResult</b> :prv return the previous value of the last binding
          <br/>
            with <b>bindResult</b> :cnt return the env
          <br/>
            &nbsp;
          <br/>
            (set! definiendTree value)
          <br/>
            (set! definiendTree bindResult value)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax definiendTree (or symbol decomposeTree))
          <br/>
            (syntax bindResult (or #ignore #inert :rhs :prv :cnt))
          <br/>
            &nbsp;
          <br/>
            (syntax decomposeTree (parametersTree . decomposeTree))
          <br/>
            (syntax parametersTree (or #null ignore symbol decomposeTree))
          <br/>
            (syntax symbol (or Symbol (#: check Symbol)))
          <br/>
            (syntax ignore (or #ignore (#: check #ignore)))
          <br/>
            (syntax check Any)
          <br/>
            (syntax check Class)
          <br/>
            (syntax check checks)
          <br/>
            (syntax checks (check . checks))
          <br/>
            (syntax check (min . checks))
          <br/>
            (syntax check (min max . checks))
          <br/>
            (syntax check (min oo . checks))
          <br/>
            (syntax check (or . checks))
          <br/>
            (syntax check (and . checks))
          <br/>
            (syntax check (Apv . arguments))
          <br/>
            (syntax check value)
          <br/>
            (syntax arguments (value . arguments))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        vau
      </h3>
      <ul>
        <li>
          Return a anonymous fexpr with the given <b>parameterTree</b>, <b>environmentParameter</b> and <b>body</b>.
          <br/>
            &nbsp;
          <br/>
            (vau parametersTree environmentParameter . body)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax parametersTree (or #null ignore symbol decomposeTree))
          <br/>
            (syntax environmentParameter (or #ignore Symbol))
          <br/>
            (syntax body (or forms (#: check . forms)))
          <br/>
            &nbsp;
          <br/>
            (syntax decomposeTree (parametersTree . decomposeTree))
          <br/>
            (syntax symbol (or Symbol (#: check Symbol)))
          <br/>
            (syntax ignore (or #ignore (#: check #ignore)))
          <br/>
            (syntax check Any)
          <br/>
            (syntax check Class)
          <br/>
            (syntax check checks)
          <br/>
            (syntax checks (check . checks))
          <br/>
            (syntax check (min . checks))
          <br/>
            (syntax check (min max . checks))
          <br/>
            (syntax check (min oo . checks))
          <br/>
            (syntax check (or . checks))
          <br/>
            (syntax check (and . checks))
          <br/>
            (syntax check (Apv . arguments))
          <br/>
            (syntax check value)
          <br/>
            (syntax arguments (value . arguments))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        if
      </h3>
      <ul>
        <li>
          Evaluate the <b>test</b> which must yield a boolean.
          <br/>
            Then evaluate either the <b>then</b> or <b>else</b> expression depending on whether the <b>test</b> yielded #true or #false.
          <br/>
            Idea stolen from Anarki https://github.com/arclanguage/anarki
          <br/>
            &nbsp;
          <br/>
            (if test then . forms)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax forms (or () (else) (test then . forms)))
          <br/>
            &nbsp;
          <br/>
            (derivation (vau (test then . forms) env (if (eval test env) (eval then env) (null? forms) #inert (null? (cdr forms)) (eval (car forms) env) (apply if forms env))))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        wrap
      </h3>
      <ul>
        <li>
          Return a new function that wraps around the underlying <b>operator</b>, and induces argument evaluations around it.
          <br/>
            Does not wrap the `Apv` and the `java functions`, but wraps the remaining `Combinator`.
          <br/>
            &nbsp;
          <br/>
            (wrap operator)
          <br/>
            (type function)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        theEnv
      </h3>
      <ul>
        <li>
          Return the current environment.
          <br/>
            &nbsp;
          <br/>
            (theEnv)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (derivation (vau () environment environment))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        eval
      </h3>
      <ul>
        <li>
          Return the result of evaluation of <b>form</b> in the optional <b>environment</b>.
          <br/>
            &nbsp;
          <br/>
            (eval form . environment)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (eval form (if (null? environment) (theEnv) (car! environment))))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        \
      </h3>
      <ul>
        <li>
          Return an anonymous function with the given <b>parameterTree</b> and <b>forms</b> as body,
          <br/>
            which use the definition environment for evaluate <b>forms</b> as an implicit `begin' and get the values of the free variables.
          <br/>
            The classic Scheme static lambda.
          <br/>
            &nbsp;
          <br/>
            (\ parameterTree . forms)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (vau (parameterTree . forms) env (wrap (eval (list* 'vau parameterTree #ignore forms) env))))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        lambda
      </h3>
      <ul>
        <li>
          alias for \. :-)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        unwrap
      </h3>
      <ul>
        <li>
          Return the underlying operator of a <b>function</b>.
          <br/>
            Unwraps the `Apv`, wraps the `java functions` in a `JFun` and does not unwrap the remaining `Combinator`.
          <br/>
            &nbsp;
          <br/>
            (unwrap function)
          <br/>
            (type function)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        apply
      </h3>
      <ul>
        <li>
          Call the <b>function</b> with a dynamically-supplied list of <b>arguments</b> in the optional <b>environment</b>.
          <br/>
            &nbsp;
          <br/>
            (apply fun args . environment)
          <br/>
            (type function)
          <br/>
            (derivation (eval (cons (unwrap fun) args) (if (null? environment) (newEnv) (car! environment)) ))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        begin
      </h3>
      <ul>
        <li>
          Sequentially evaluate <b>forms</b> returning the value of the last one, #inert if <b>forms</b> is #null.
          <br/>
            &nbsp;
          <br/>
            (begin . forms)
          <br/>
            (type fexpr)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        car
      </h3>
      <ul>
        <li>
          Return the contents of the address part of the register.
          <br/>
            &nbsp;
          <br/>
            (car cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((car . #_)) car)) cons)
          <br/>
            (derivation (@car cons))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        car!
      </h3>
      <ul>
        <li>
          Return the contents of the address part of the register
          <br/>
            if decrement part of the register is #null, signals an error otherwise.
          <br/>
            &nbsp;
          <br/>
            (car! cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((car)) car)) cons)
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cadr
      </h3>
      <ul>
        <li>
          Return the `car' of the `cdr' of the <b>cons</b>.
          <br/>
            &nbsp;
          <br/>
            (cadr cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((#_ cadr . #_)) cadr)) cons)
          <br/>
            (derivation (car (cdr cons)))
          <br/>
            (derivation (@car cons 1))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cdr
      </h3>
      <ul>
        <li>
          Return the contents of the decrement part of the register.
          <br/>
            &nbsp;
          <br/>
            (cdr cons)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation ((\ ((#_ . cdr)) cdr)) cons)
          <br/>
            (derivation (@cdr cons))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cons
      </h3>
      <ul>
        <li>
          Return a cons with the given <b>car</b> and <b>cdr</b>.
          <br/>
            &nbsp;
          <br/>
            (cons car cdr)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (@new vm Cons car cdr))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        cons?
      </h3>
      <ul>
        <li>
          Return #true if the <b>object</b> is a cons, #false otherwise.
          <br/>
            &nbsp;
          <br/>
            (cons? object)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (type? object Cons))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        atom?
      </h3>
      <ul>
        <li>
          Return #true if the <b>object</b> is not a cons, #false otherwise.
          <br/>
            &nbsp;
          <br/>
            (atom? object)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (if (cons? object) #f #t))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        list
      </h3>
      <ul>
        <li>
          Return the list of evaluated <b>arguments</b>.
          <br/>
            &nbsp;
          <br/>
            (list . arguments)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (wrap (vau arguments #ignore arguments)))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        list*
      </h3>
      <ul>
        <li>
          Return a list of evaluated <b>arguments</b> so that
          <br/>
            the last argument becomes the `cdr' of the list.
          <br/>
            &nbsp;
          <br/>
            (list* . arguments)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (if (atom? arguments) arguments ((rec\ (loop arguments) (if (null? (cdr arguments)) (car argument) (cons (car argument) (loop (cdr arguments))))) arguments)))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        null?
      </h3>
      <ul>
        <li>
          Return #true if the <b>object</b> is #null, #false otherwise.
          <br/>
            &nbsp;
          <br/>
            (null? object)
          <br/>
            (type function)
          <br/>
            &nbsp;
          <br/>
            (derivation (type? object Null))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        quote
      </h3>
      <ul>
        <li>
          Return the unevaluated <b>operand</b>.
          <br/>
            &nbsp;
          <br/>
            (quote operand)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (derivation (vau (operand) #ignore operand))
        </li>
      </ul>
    </div>
    <div>
      <h3>
        assert
      </h3>
      <ul>
        <li>
          Signals an error if:
          <br/>
            - <b>expression</b> does not equal <b>value</b>
          <br/>
            - <b>value</b> is not present and the <b>expression</b> does not throws
          <br/>
            - <b>expression</b> throws or returns an object and the object is not of the same <b>class</b> with the <b>attributes</b> of the given <b>value</b>.
          <br/>
            &nbsp;
          <br/>
            (assert expression value)
          <br/>
            (assert expression)
          <br/>
            (assert expression class attribute value . attributes)
          <br/>
            (type fexpr)
          <br/>
            &nbsp;
          <br/>
            (syntax attributes (attribute value . attributes))
          <br/>
            (syntax attribute (or Symbol Keyword String .Field @Method))
        </li>
      </ul>
    </div>
    <br/>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference0.html">
      <input type="button" value="&lt;" disabled/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference.html">
      <input type="button" value="^"/>
    </a>
    <a href="https://htmlpreview.github.io?https://github.com/GiacomoCau/Wat/blob/main/reference/reference2.html">
      <input type="button" value="&gt;"/>
    </a>
  </body>
</html>
