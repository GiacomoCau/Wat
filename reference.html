<!DOCTYPE html>
<html><head><title>Reference</title><style>ul { list-style-type: none; }</style></head>

<h2>Core Built-Ins for Macro and Definitions Forms</h2>
<div>
<h3>vau</h3>
<ul>
<li>
Construct a fexpr with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER, and FORMS.
<li>$(fn (parameterTree environmentParameter . forms))
<li>$(type fexpr)
<li>$(derivation (vau (pt ep . forms) env (eval (list 'vau pt ep (cons 'begin forms)) env)))
</ul>
</div>
<div>
<h3>\</h3>
<ul>
<li>
Create an anonymous function with the given PARAMETER-TREE and FORMS.
<li>$(fn (parameterTree . forms))
<li>$(type function)
<li>$(derivation (vau (parameterTree . forms) env (wrap (eval (list* 'vau parameterTree #ignore forms) env))))
</ul>
</div>
<div>
<h3>lambda</h3>
<ul><li>(def lambda \)</ul></div>
<div>
</div>
<div>
<h3>wrap</h3>
<ul>
<li>
Create a new function that wraps around an underlying OPERATOR, and
induces argument evaluation around it.
<li>$(fn (operator))
<li>$(type function)
</ul>
</div>
<div>
<h3>assert</h3>
<ul><li>(def assert %assert)</ul></div>
<div>
</div>
<div>
<h3>apply</h3>
<ul>
<li>
Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
<li>$(fn (fun args . env))
<li>$(type function)
<li>$(derivation (eval (cons (unwrap fun) args) (if (null? env) (newEnv) (car! env)) ))
</ul>
</div>
<div>
<h3>begin</h3>
<ul>
<li>
Sequentially evaluate FORMS, returning the value of the last one, or void if there are no forms.
<li>$(fn forms)
<li>$(type fexpr)
</ul>
</div>
<div>
<h3>car</h3>
<ul>
<li>
Return the contents of the address part of the register.
<li>$(fn (cons))
<li>$(type function)
</ul>
</div>
<div>
<h3>cadr</h3>
<ul>
<li>
Return the `car' of the `cdr' of the CONS.
<li>$(derivation (car (cdr cons)))
<li>$(derivation (\ ((#_ . (cadr . #_))) cadr))
<li>$(derivation (\ ((#_ cadr . #_)) cadr))
</ul>
</div>
<div>
<h3>cdr</h3>
<ul>
<li>
Return the contents of the decrement part of the register.
<li>$(fn (cons))
<li>$(type function)
</ul>
</div>
<div>
<h3>cons</h3>
<ul>
<li>
Create a cons with the given CAR and CDR.
<li>$(fn (car cdr))
<li>$(type function)
</ul>
</div>
<div>
<h3>cons?</h3>
<ul>
<li>
Return true if the OBJECT is a cons, false otherwise.
<li>$(fn (object))
<li>$(type function)
</ul>
</div>
<div>
<h3>eval</h3>
<ul>
<li>
Evaluate the FORM in the ENVIRONMENT, returning its result.
<li>$(fn (form environment))
<li>$(type function)
</ul>
</div>
<div>
<h3>if</h3>
<ul>
<li>
Evaluate the TEST which must yield a boolean.  Then evaluate either
the CONSEQUENT or ALTERNATIVE depending on whether the TEST yielded
true or false.
<li>$(fn (test consequent . alternative))
<li>$(fn (test1 consequent1 test2 consequent2 ... . alternative))
<li>$(type fexpr)
<li>$(derivation (vau (test then . else) env (if (eval then env) (eval then env) (null? else) #inert (null? (cdr else)) (eval (car else)) (apply if else env))))
</ul>
</div>
<div>
<h3>list</h3>
<ul>
<li>
Return the list of evaluated ARGUMENTS.
<li>$(fn arguments)
<li>$(type function)
<li>$(derivation (wrap (vau arguments #ignore arguments))
</ul>
</div>
<div>
<h3>list*</h3>
<ul>
<li>
Create a list from the ARGUMENTS so that the last argument becomes
the `cdr' of the list.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>newBox</h3>
<ul><li>(def newBox</ul></div>
<div>
</div>
<div>
<h3>quote</h3>
<ul>
<li>
Return the unevaluated OPERAND.
<li>$(fn (operand))
<li>$(type fexpr)
<li>$(derivation (vau (operand) #ignore operand))
</ul>
</div>

<h2>Macro</h2>
<div>
<h3>evalMacro</h3>
<ul><li>(def evalMacro (newBox #t))</ul></div>
<div>
</div>
<div>
<h3>makeMacro</h3>
<ul>
<li>
Create a macro from an EXPANDER operator.
A macro is an operator that receives an operand and produces a form
(by calling the expander with the operand as argument)
that is then evaluated in place of the operand.
<li>$(fn (expander))
<li>$(type function)
</ul>
</div>
<div>
<h3>macro</h3>
<ul>
<li>
Create an anonymous macro with the given PARAMETER-TREE and FORMS.
<li>$(fn (parameterTree . forms))
<li>$(type macro)
</ul>
</div>
<div>
<h3>expand</h3>
<ul><li>(def expand</ul></div>
<div>
</div>

<h2>Definitions Forms</h2>
<div>
<h3>defMacro</h3>
<ul>
<li>
Define a macro with the given NAME, PARAMETER-TREE, and FORMS.
<li>$(fn (name parameterTree . forms))
<li>$(fn ((name parameterTree) . forms))
<li>$(type macro)
</ul>
</div>
<div>
<h3>defVau</h3>
<ul>
<li>
Define a fexpr with the given NAME, PARAMETER-TREE,
ENVIRONMENT-PARAMETER, and FORMS.
<li>$(fn (name parameterTree . forms))
<li>$(fn ((name parameterTree) . forms))
<li>$(type macro)
</ul>
</div>
<div>
<h3>defConstant</h3>
<ul>
<li>
Define a constant with the given NAME and VALUE.  This is mostly
for documentation purposes, as constants are still mutable.
</ul>
</div>
<div>
<h3>def*</h3>
<ul><li>(defMacro (def* lhs . rhs)</ul></div>
<div>
</div>
<div>
<h3>def\</h3>
<ul>
<li>
Define a function with the given NAME, PARAMETER-TREE, and FORMS.
<li>$(fn (name parameterTree . forms))
<li>$(fn ((name parameterTree) . forms))
<li>$(type macro)
</ul>
</div>

<h2>Other Core Built-Ins</h2>
<div>
<h3>apply*</h3>
<ul>
<li>
Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
<li>$(fn (fun . args)) 
<li>$(type function)
<li>$(derivation (apply fun args (newEnv)))
</ul>
</div>
<div>
<h3>apply**</h3>
<ul>
<li>
Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
<li>$(fn (fun . args)) 
<li>$(type function)
<li>$(derivation (apply fun (apply list* args) (newEnv)))
</ul>
</div>
<div>
<h3>set</h3>
<ul>
<li>
Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT,
creating or updating existing bindings.  Unlike Common Lisp (or
Scheme), we have no `setq' (or `set!') that allows updating arbitrary
bindings -- you always need to know the environment a binding is in to
change it.  Therefore, we usually use boxes (see below) instead of
mutating bindings directly.
</ul>
</div>
<div>
<h3>set!</h3>
<ul><li>(def set! %set!)</ul></div>
<div>
</div>
<div>
<h3>unwrap</h3>
<ul>
<li>
Return the underlying operator of a FUNCTION.
<li>$(fn (function))
<li>$(type function)
</ul>
</div>
<div>
<h3>wrau</h3>
<ul><li>(defMacro (wrau pt ep . body)</ul></div>
<div>
</div>

<h2>Env</h2>
<div>
<h3>newEnv</h3>
<ul>
<li>
Create a new environment with an optional PARENT-ENVIRONMENT? in
which bindings are looked up if they are not found.
<li>$(fn parentEnvironment?)
<li>$(type function)
</ul>
</div>
<div>
<h3>theEnv</h3>
<ul>
<li>
Return the current environment.
<li>$(fn parent?)
<li>$(type fexpr)
<li>$(derivation (vau () environment environment)))
</ul>
</div>

<h2>Obj</h2>
<div>
<h3>new</h3>
<ul>
<li>
Create a new instance of CLASS (that must be a `standard-class').
The SLOT-INITS must be of even length, and alternately contain slot
names (symbols, typically keywords) and values.
<li>$(fn (class . slotInits))
</ul>
</div>
<div>
<h3>defObj</h3>
<ul><li>(defMacro (defObj name class . attr)</ul></div>
<div>
</div>

<h2>Env &amp; Obj</h2>
<div>
<h3>bound?</h3>
<ul>
<li>
Return true if the SYMBOL or KEYWORD is bound in the ENVIRONMENT or OBJ, false otherwise.
<li>$(fn (symbol environment))
<li>$(type function)
</ul>
</div>
<div>
<h3>value</h3>
<ul><li>(def value %value)</ul></div>
<div>
</div>
<div>
<h3>getSlot</h3>
<ul>
<li>
Return the value of the slot named SLOT-NAME of the OBJECT.
</ul>
</div>
<div>
<h3>setSlot</h3>
<ul>
<li>
Set the value of the slot named SLOT-NAME of the OBJECT to VALUE.
</ul>
</div>
<div>
<h3>slotBound?</h3>
<ul>
<li>
Return true if the slot named SLOT-NAME of the OBJECT is set, false otherwise.
</ul>
</div>

<h2>Cons</h2>
<div>
<h3>car!</h3>
<ul>
<li>
Return the contents of the address part of the register if decrement part of the register is null, else error.
</ul>
</div>
<div>
<h3>caar</h3>
<ul>
<li>
Return the `car' of the `car' of the CONS.
</ul>
</div>
<div>
<h3>cadr!</h3>
<ul>
<li>
Return the `car' of the `cdr' of the CONS if 'cddr' is null, else error.
</ul>
</div>
<div>
<h3>cdar</h3>
<ul>
<li>
Return the `cdr' of the `car' of the CONS.
</ul>
</div>
<div>
<h3>cddr</h3>
<ul>
<li>
Return the `cdr' of the `cdr' of the CONS.
<li>$(derivation (cdr (cdr cons)))
<li>$(derivation (\ ((#_ . (#_ . cddr))) cddr))
<li>$(derivation (\ ((#_ #_ . cddr)) cddr))
</ul>
</div>
<div>
<h3>cons!</h3>
<ul><li>(def\ (cons! car) (cons car))</ul></div>
<div>
</div>
<div>
<h3>null?</h3>
<ul>
<li>
Return true if the OBJECT is nil, false otherwise.
<li>$(fn (object))
<li>$(type function)
</ul>
</div>
<div>
<h3>!null?</h3>
<ul><li>(def !null? %!null?)</ul></div>
<div>
</div>
<div>
<h3>nth</h3>
<ul>
<li>
Return element number N of LIST, where the `car' is element zero.
<li>$(fn (n list))
<li>$(type function)
</ul>
</div>
<div>
<h3>nthCdr</h3>
<ul>
<li>
Returns the tail of LIST that would be obtained by calling `cdr' N times in succession.
<li>$(fn (n list))
<li>$(type function)
</ul>
</div>

<h2>List</h2>
<div>
<h3>append</h3>
<ul>
<li>
Append two lists.  The first one must be proper and is copied.  The
second one is not copied (and doesn't even have to be a list). It
becomes the `cdr' of the final cons of the first list, or is returned
directly if the first list is empty.
<li>$(fn (list1 list2))
<li>$(type function)
</ul>
</div>
<div>
<h3>len</h3>
<ul><li>(def len %len)</ul></div>
<div>
<h3>list?</h3>
<ul>
<li>
Return true if the OBJECT is a list, false otherwise.
<li>$(fn (object))
<li>$(type function)
</ul>
</div>
<div>
<h3>reverse</h3>
<ul>
<li>
Reverse the LIST.
<li>$(fn (list))
<li>$(type function)
</ul>
</div>

<h2>Symbol &amp; Keyword</h2>
<div>
<h3>intern</h3>
<ul>
<li>
Get or create the unique symbol with STRING as name.
<li>$(fn (string))
<li>$(type function)
</ul>
</div>
<div>
<h3>keyword</h3>
<ul><li>(def keyword %keyword)</ul></div>
<div>
<h3>keyword?</h3>
<ul><li>(def keyword? %keyword?)</ul></div>
<div>
<h3>keywordName</h3>
<ul><li>(def keywordName %name)</ul></div>
<div>
</div>
<div>
<h3>symbol</h3>
<ul><li>(def symbol %symbol)</ul></div>
<div>
<h3>symbol?</h3>
<ul><li>(def symbol? %symbol?)</ul></div>
<div>
<h3>symbolName</h3>
<ul>
<li>
Return the name of the SYMBOL as a string.
<li>$(fn (symbol))
<li>$(type function)
</ul>
</div>

<h2>Equals</h2>
<div>
<h3>==</h3>
<ul>
<li>
Return true if the values A and B are pointer-identical, false otherwise.
<li>$(fn (a b))
<li>$(type function)
</ul>
</div>
<div>
<h3>!=</h3>
<ul><li>(def != %!=)</ul></div>
<div>
<h3>eq?</h3>
<ul><li>(def eq? %eq?)</ul></div>
<div>
</div>
<div>
<h3>ignore?</h3>
<ul><li>(def\ (ignore? o) (== o #_))</ul></div>
<div>
<h3>sheBang?</h3>
<ul><li>(def\ (sheBang? o) (== o #!))</ul></div>
<div>
<h3>inert?</h3>
<ul><li>(def\ (inert? o) (== o #inert))</ul></div>
<div>
</div>

<h2>Boolean</h2>
<div>
<h3>!</h3>
<ul>
<li>
Invert the BOOLEAN.
<li>$(fn (boolean))
<li>$(type function)
<li>$(derivation (if boolean #f #t))
</ul>
</div>
<div>
<h3>not</h3>
<ul><li>(def not !)</ul></div>
<div>
</div>
<div>
<h3>!!</h3>
<ul><li>(def !! %!!)</ul></div>
<div>
</div>

<h2>Number</h2>
<div>
<h3>number?</h3>
<ul><li>(def number? %number?)</ul></div>
<div>
<h3>+</h3>
<ul><li>(def + %+)</ul></div>
<div>
<h3>*</h3>
<ul><li>(def * %*)</ul></div>
<div>
<h3>-</h3>
<ul><li>(def - %-)</ul></div>
<div>
<h3>/</h3>
<ul><li>(def / %/)</ul></div>
<div>
<h3>%</h3>
<ul><li>(def % %%)</ul></div>
<div>
<h3>1+</h3>
<ul><li>(def\ (1+ n) (+ n 1))</ul></div>
<div>
<h3>1-</h3>
<ul><li>(def\ (1- n) (- n 1))</ul></div>
<div>
<h3>0?</h3>
<ul><li>(def\ (0? n) (== n 0))</ul></div>
<div>
<h3>1?</h3>
<ul><li>(def\ (1? n) (== n 1))</ul></div>
<div>
<h3>-1?</h3>
<ul><li>(def\ (-1? n) (== n -1))</ul></div>
<div>
<h3>even?</h3>
<ul><li>(def\ (even? n) (== (% n 2) 0))</ul></div>
<div>
<h3>odd?</h3>
<ul><li>(def\ (odd? n)  (== (% n 2) 1))</ul></div>
<div>
</div>

<h2>String</h2>
<div>
<h3>string?</h3>
<ul><li>(def string? %string?)</ul></div>
<div>
<h3>$</h3>
<ul><li>(def $ %$)</ul></div>
<div>
</div>

<h2>Comparator</h2>
<div>
<h3>&lt;</h3>
<ul><li>(def &lt; %&lt;)</ul></div>
<div>
<h3>&gt;</h3>
<ul><li>(def &gt; %&gt;)</ul></div>
<div>
<h3>&lt;=</h3>
<ul><li>(def &lt;= %&lt;=)</ul></div>
<div>
<h3>&gt;=</h3>
<ul><li>(def &gt;= %&gt;=)</ul></div>
<div>
</div>

<h2>Bit</h2>
<div>
<h3>~</h3>
<ul><li>(def ~ %~)</ul></div>
<div>
<h3>&amp;</h3>
<ul><li>(def &amp; %&amp;)</ul></div>
<div>
<h3>\|</h3>
<ul><li>(def \| %|)</ul></div>
<div>
<h3>^</h3>
<ul><li>(def ^ %^)</ul></div>
<div>
<h3>&lt;&lt;</h3>
<ul><li>(def &lt;&lt; %&lt;&lt;)</ul></div>
<div>
<h3>&gt;&gt;</h3>
<ul><li>(def &gt;&gt; %&gt;&gt;)</ul></div>
<div>
<h3>&gt;&gt;&gt;</h3>
<ul><li>(def &gt;&gt;&gt; %&gt;&gt;&gt;)</ul></div>
<div>
</div>

<h2>First-Order Control</h2>
<div>
<h3>then</h3>
<ul><li>(def* (then else) begin begin)</ul></div>
<div>
</div>
<div>
<h3>loop</h3>
<ul>
<li>
Evaluate the FORMS in an infinite loop.
<li>$(fn forms)
<li>$(type fexpr)
</ul>
</div>
<div>
<h3>atEnd</h3>
<ul>
<li>
valuate the PROTECTED-FORM and return its result.  Regardless of
whether the protected form returns normally, or via a nonlocal exit or
panic, the CLEANUP-FORM are evaluated after the protected forms.
<li>$(fn (cleanupForm . protectedForms))
<li>$(type fexpr)
</ul>
</div>
<div>
<h3>finally</h3>
<ul><li>(defMacro (finally x . cnl)</ul></div>
<div>
</div>
<div>
<h3>throwTag</h3>
<ul>
<li>
Abort to a nesting catch tag established by `catch' and pass the
optional RESULT? (defaults to void) to it.
<li>$(fn (tag . val))
<li>$(type macro)
</ul>
</div>
<div>
<h3>throw</h3>
<ul><li>(defMacro (throw . forms) (list* 'throwTag #_ forms) )</ul></div>
<div>
</div>

<h2>Delimited-Control Operators</h2>
<div>
<h3>takeSubcont</h3>
<ul>
<li>
Abort outwards to the PROMPT.  When the prompt is reached, evaluate
the FORMS with NAME bound to the captured continuation (which does not
include the prompt).
<li>$(fn (prompt symbol . forms))
<li>$(type operatore)
</ul>
</div>
<div>
<h3>pushPrompt</h3>
<ul>
<li>
Push the PROMPT and evaluate the FORMS inside the prompt.  This
delimits the continuation.
<li>$(fn (prompt . forms))
<li>$(type operatore)
</ul>
</div>
<div>
<h3>pushDelimSubcont</h3>
<ul>
<li>
Push the PROMPT and compose the previously captured CONTINUATION
inside it.  The FORMS are then evaluated inside the new continuation.
<li>$(fn (prompt continuation . forms))
<li>$(type operatore)
</ul>
</div>
<div>
<h3>pushSubcont</h3>
<ul>
<li>
We don't have `pushSubcont' but for these tests we can emulate it
with a `pushDelimSubcont' that pushes an unused prompt.
<li>$(fn (continuation . forms))
<li>$(type macro)
</ul>
</div>
<div>
<h3>pushSubcontBarrier</h3>
<ul>
<li>
Push a continuation barrier that prevents the FORMS from capturing
any continuations to the outside.
<li>$(fn forms)
<li>$(type operatore)
</ul>
</div>

<h2>Error</h2>
<div>
<h3>rootPrompt</h3>
<ul><li>(def rootPrompt %rootPrompt)</ul></div>
<div>
</div>
<div>
<h3>makeTypeError</h3>
<ul><li>(def\ makeTypeError (datum expected)</ul></div>
<div>
</div>
<div>
<h3>typeError</h3>
<ul><li>(def\ typeError (datum expected)</ul></div>
<div>
</div>

<h2>Classes</h2>
<div>
<h3>className</h3>
<ul>
<li>
Return the name symbol of the CLASS.
<li>$(fn (class))
<li>$(type function)
</ul>
</div>
<div>
<h3>classOf</h3>
<ul>
<li>
Return the class of the OBJECT.
<li>$(fn (object))
<li>$(type function)
</ul>
</div>
<div>
<h3>instanceOf?</h3>
<ul><li>(def instanceOf? %instanceOf?)</ul></div>
<div>
</div>
<div>
<h3>subClass?</h3>
<ul>
<li>
Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.
A class is considered a subclass of itself.
<li>$(fn (class superclass))
<li>$(type function)
</ul>
</div>
<div>
<h3>type?</h3>
<ul>
<li>
Return true if the OBJECT is an instance of the CLASS, false otherwise.
<li>$(fn (object class))
<li>$(type function)
</ul>
</div>

<h2>Basic Functions and Macro</h2>
<div>
<h3>idf</h3>
<ul>
<li>
Identity function.
</ul>
</div>
<div>
<h3>_</h3>
<ul>
<li>
&quot;Implicit&quot; Argument Lambda.
</ul>
</div>
<div>
<h3>curry</h3>
<ul><li>(def\ (curry f v)</ul></div>
<div>
</div>
<div>
<h3>curry*</h3>
<ul><li>(def\ (curry* f . v*)</ul></div>
<div>
</div>
<div>
<h3>compose</h3>
<ul>
<li>
Compose two functions, creating a new function equivalent to (G (F ...)).
</ul>
</div>
<div>
<h3>compose*</h3>
<ul><li>(def\ (compose* . f*)</ul></div>
<div>
</div>
<div>
<h3>iota</h3>
<ul><li>(def\ (iota n) (reverse ((rec\ (ι n) (if (0? n) () (cons n (ι (1- n))))) n)))</ul></div>
<div>
<h3>fork</h3>
<ul><li>(def\ (fork f l r) [_ (f (l _) (r _))])</ul></div>
<div>
<h3>hook</h3>
<ul><li>(def\ (hook l r) [_ (l _ (r _))])</ul></div>
<div>
</div>
<div>
<h3>rec</h3>
<ul><li>(defMacro (rec lhs . rhs)</ul></div>
<div>
</div>
<div>
<h3>label</h3>
<ul><li>(def label rec)</ul></div>
<div>
</div>
<div>
<h3>rec\</h3>
<ul><li>(defMacro (rec\ lhs . rhs)</ul></div>
<div>
</div>
<div>
<h3>label\</h3>
<ul><li>(def label\ rec\)</ul></div>
<div>
</div>
<div>
<h3>map</h3>
<ul>
<li>
Create a new list by applying the FUNCTION to every element of the LIST.
</ul>
</div>
<div>
<h3>def*\</h3>
<ul><li>(defMacro (def*\ lhs* . rhs*)</ul></div>
<div>
</div>

<h2>Lexical Bindings</h2>
<div>
<h3>-&gt;begin</h3>
<ul><li>(def\ (-&gt;begin binding) (cons 'begin (cdr binding)))</ul></div>
<div>
<h3>-&gt;name+#inert</h3>
<ul><li>(def\ (-&gt;name+#inert (lhs . #_)) (list (if (cons? lhs) (car lhs) lhs) #inert))</ul></div>
<div>
<h3>-&gt;name+lambda</h3>
<ul><li>(def\ (-&gt;name+lambda (lhs . rhs)) (if (cons? lhs) (list (car lhs) (list* '\ (cdr lhs) rhs)) (list lhs (cons '\ rhs)) ))</ul></div>
<div>
</div>
<div>
<h3>wth1</h3>
<ul><li>(defMacro (wth1 dt value . forms)</ul></div>
<div>
</div>
<div>
<h3>wth*</h3>
<ul><li>(defMacro (wth* bindings . forms)</ul></div>
<div>
</div>
<div>
<h3>wth</h3>
<ul><li>(defMacro (wth b* . forms)</ul></div>
<div>
</div>
<div>
<h3>let1Loop</h3>
<ul><li>(defMacro (let1Loop lhs . rhs)</ul></div>
<div>
</div>
<div>
<h3>let1</h3>
<ul><li>(defMacro (let1 lhs . rhs)</ul></div>
<div>
</div>
<div>
<h3>let1\</h3>
<ul><li>(defMacro (let1\ binding . body)</ul></div>
<div>
</div>
<div>
<h3>let1rec</h3>
<ul><li>(defMacro (let1rec binding . body)</ul></div>
<div>
</div>
<div>
<h3>let1rec\</h3>
<ul><li>(defMacro (let1rec\ binding . body)</ul></div>
<div>
</div>
<div>
<h3>let*</h3>
<ul>
<li>
Establish BINDINGS serially during the evaluation of FORMS, so that
every binding can refer to previous ones.
<li>$(syntax bindings ((definiendTree value) . bindings))
</ul>
</div>
<div>
<h3>letLoop</h3>
<ul>
<li>
Labelled recursive loop, analogous to Scheme's named `let'.
Lexically bind a function named NAME with one PARAMETER for every
INITIALIZER and the FORMS as body.  Then immediately apply the
function to a list containing one VALUE for every INITIALIZER and
return the result.  The function is bound per `labels' so it can
recursively refer to itself.
<li>$(fn (initializers . body))
<li>$(fn (name initializers . body))
<li>$(syntax initializers ((parameter value) . initializers)
</ul>
</div>
<div>
<h3>let</h3>
<ul>
<li>
Establish BINDINGS parallelly during the evaluation of FORMS, so
that no binding can refer to the other ones.
<li>$(fn (bindings . body))
<li>$(fn (name bindings . body))
<li>$(syntax bindings ((parameter value) . bindings)
</ul>
</div>
<div>
<h3>let\</h3>
<ul>
<li>
Establish FUNCTION-BINDINGS parallelly during evaluation of FORMS,
so that no function can refer to the other ones.
<li>$(syntax functionBinding (name parameterTree . forms))
</ul>
</div>
<div>
<h3>letrec</h3>
<ul>
<li>
Utility to establish BINDINGS recursively during the evaluation of
FORMS.  Used by `labels'.
</ul>
</div>
<div>
<h3>letrec\</h3>
<ul><li>(defMacro (letrec\ bindings . body)</ul></div>
<div>
</div>
<div>
<h3>labels</h3>
<ul>
<li>
Establish FUNCTION-BINDINGS recursively during evaluation of FORMS,
so that every function can refer to the other ones.
<li>$(syntax functionBinding (name parameterTree . forms))
</ul>
</div>

<h2>Simple Control</h2>
<div>
<h3>prog1</h3>
<ul>
<li>
Evaluate FORM and any additional FORMS, and return the result of FORM.
</ul>
</div>
<div>
<h3>when</h3>
<ul>
<li>
If TEST yields true, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
</ul>
</div>
<div>
<h3>unless</h3>
<ul>
<li>
If TEST yields false, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
</ul>
</div>
<div>
<h3>&amp;&amp;</h3>
<ul>
<li>
Return true if all OPERANDS evaluate to true, false otherwise.
If an operand evaluates to false, later operands are not evaluated.
If there are no operands, return false.
</ul>
</div>
<div>
<h3>and</h3>
<ul><li>(def and &amp;&amp;)</ul></div>
<div>
</div>
<div>
<h3>||</h3>
<ul>
<li>
Return true if one of the OPERANDS evaluates to true, false otherwise.
If an operand evaluates to true, later operands are not evaluated.
If there are no operands, return true.
</ul>
</div>
<div>
<h3>or</h3>
<ul><li>(def or ||)</ul></div>
<div>
</div>
<div>
<h3>&amp;&amp;f</h3>
<ul><li>(def\ &amp;&amp;f fs</ul></div>
<div>
</div>
<div>
<h3>||f</h3>
<ul><li>(def\ ||f fs</ul></div>
<div>
</div>

<h2>Bind Bind? IfBind? CaseVau DefCaseVau Case\ DefCase\ Match Cond</h2>
<div>
<h3>bind?</h3>
<ul><li>(def bind? %bind?)</ul></div>
<div>
</div>
<div>
<h3>ifBind?</h3>
<ul><li>(defVau (ifBind? (pt exp) then . else) env</ul></div>
<div>
</div>
<div>
<h3>caseVau</h3>
<ul><li>(defVau (caseVau . clauses) env</ul></div>
<div>
</div>
<div>
<h3>defCaseVau</h3>
<ul><li>(defMacro (defCaseVau sym . clauses)</ul></div>
<div>
</div>
<div>
<h3>case\</h3>
<ul><li>(defMacro (case\ . clauses)</ul></div>
<div>
</div>
<div>
<h3>defCase\</h3>
<ul><li>(defMacro (defCase\ sym . clauses)</ul></div>
<div>
</div>
<div>
<h3>match</h3>
<ul><li>(defMacro (match exp . clauses)</ul></div>
<div>
</div>
<div>
<h3>cond</h3>
<ul>
<li>
Multi-armed conditional.
Go through the CLAUSES in order.  Evaluate the TEST.
If it yields true, evaluate the FORMS as an implicit `begin'.
If it yields false, go to the next clause,
or return void if there are no more clauses.
<li>$(syntax clauses (clause . clauses))
<li>$(syntax clause (else . forms))
<li>$(syntax clause (test-&gt;bool . forms))
<li>$(syntax clause (test))
<li>$(syntax clause (test =&gt; apv1))
<li>$(syntax clause (test guard =&gt; apv1))
</ul>
</div>

<h2>Quasiquote</h2>
<div>
<h3>%`</h3>
<ul><li>(defVau %` (x) env</ul></div>
<div>
</div>

<h2>Options</h2>
<div>
<h3>some</h3>
<ul>
<li>
Create a one-element list from the VALUE.
</ul>
</div>
<div>
<h3>ifOpt</h3>
<ul>
<li>
Destructure the OPTION?.  If it's non-nil, evaluate the THEN form
with the NAME bound to the contents of the option.  If it's nil,
evaluate the ELSE form.
</ul>
</div>
<div>
<h3>ifOpt*</h3>
<ul><li>(defVau (ifOpt* (pt opt) then . else) env</ul></div>
<div>
</div>
<div>
<h3>whenOpt</h3>
<ul>
<li>
Destructure the OPTION?.  If it's non-nil, evaluate the FORMS with
the NAME bound to the contents of the option.  If it's nil, return nil.
</ul>
</div>
<div>
<h3>unlessOpt</h3>
<ul>
<li>
Destructure the OPTION?.  If it's nil, evaluate the FORMS.  If it's
non-nil, return nil.
</ul>
</div>
<div>
<h3>caseOpt</h3>
<ul><li>(defVau (caseOpt opt . clauses) env</ul></div>
<div>
</div>
<div>
<h3>optDft</h3>
<ul>
<li>
Return the contents of the OPTION?, or the DEFAULT? if the option
is nil.  The default itself defaults to void.  The DEFAULT? is
evaluated lazily, only when the OPTION? is nil.
</ul>
</div>
<div>
<h3>optDft*</h3>
<ul>
<li>
Similar to `opt', but provides DEFAULTS for any number of
elements of LIST.  This is useful for implementing functions that take
multiple optDft arguments.  Each default is evaluated lazily, only when needed.
</ul>
</div>
<div>
<h3>optDft!</h3>
<ul>
<li>
Returns the contents of the OPTION? or signals an error if it is nil.
</ul>
</div>

<h2>OptValue Member Member? !Member? OptKey Assoc Member*?</h2>
<div>
<h3>optValue</h3>
<ul>
<li>
Search for the KEYWORD in the property list LST
(a list of alternating keywords and values)
and return the found value as an option.
</ul>
</div>
<div>
<h3>member</h3>
<ul>
<li>
Search for ITEM in the LIST according to the TEST predicate
(defaults to `==').  Return the tail of the list starting with
ITEM if found, nil otherwise.  The KEY function is applied to
each list element before comparison (defaults to `idf').
<li>$(fn (item list &amp;key test key))
</ul>
</div>
<div>
<h3>member?</h3>
<ul><li>(def\ (member? key lst . keywords)</ul></div>
<div>
</div>
<div>
<h3>!member?</h3>
<ul><li>(def\ (!member? key lst . keywords)</ul></div>
<div>
</div>
<div>
<h3>optKey</h3>
<ul><li>(def\ (optKey key lst)</ul></div>
<div>
</div>
<div>
<h3>assoc</h3>
<ul><li>(def\ (assoc k lst) </ul></div>
<div>
</div>
<div>
<h3>member*?</h3>
<ul><li>(def\ (member*? key . lst)</ul></div>
<div>
</div>

<h2>Case MatchObj? CaseType CaseType\</h2>
<div>
<h3>case</h3>
<ul><li>(defVau (case exp . clauses) env</ul></div>
<div>
</div>
<div>
<h3>matchObj?</h3>
<ul><li>(def matchObj? %matchObj?)</ul></div>
<div>
</div>
<div>
<h3>matchObj*?</h3>
<ul><li>(def\ (matchObj*? obj class . slots) </ul></div>
<div>
</div>
<div>
<h3>caseType</h3>
<ul>
<li>
Multi-armed type test.
Evaluate the KEYFORM.  Go through the CLAUSES.  If the result of
evaluating KEYFORM is an instance of the class named by CLASS-NAME,
evaluate the FORMS as an implicit `begin'.  Otherwise go to the next
clause, or return void if there are no more clauses.
<li>$(fn (key . clauses))
<li>$(type fexpr)
<li>$(syntax clauses (clause . clauses))
<li>$(syntax clause (className . forms))
<li>$(syntax clause ((className . slotSpecs) . forms))
</ul>
</div>
<div>
<h3>caseType\</h3>
<ul><li>(defMacro (caseType\ (#! Symbol key) . clauses)</ul></div>
<div>
</div>
<div>
<h3>caseType\</h3>
<ul><li>(defMacro (caseType\ (#! (1 Symbol) key) . clauses)</ul></div>
<div>
</div>

<h2>Sort</h2>
<div>
<h3>sort</h3>
<ul><li>(def\ (sort lst . opt)</ul></div>
<div>
</div>

<h2>Checks</h2>
<div>
<h3>assert#t</h3>
<ul>
<li>
Signal an error if the BOOLEAN is false. Otherwise return void.
</ul>
</div>
<div>
<h3>makeTypeError</h3>
<ul>
<li>
Create a `type-error' with the given DATUM and EXPECTED-TYPE.
</ul>
</div>
<div>
<h3>typeError</h3>
<ul>
<li>
Signal a `type-error'
</ul>
</div>
<div>
<h3>the</h3>
<ul>
<li>
Signal a `type-error' if the OBJECT is not an instance of the CLASS, else return object.
<li>$(fn (class object)
<li>$(type function)
</ul>
</div>
<div>
<h3>check</h3>
<ul><li>(defVau (check o ck) env</ul></div>
<div>
</div>
<div>
<h3>check</h3>
<ul><li>(defVau (check o ck) env</ul></div>
<div>
</div>
<div>
<h3>check*</h3>
<ul><li>(defMacro (check* o . cks)</ul></div>
<div>
</div>
<div>
<h3>check?</h3>
<ul><li>(defVau check? args env</ul></div>
<div>
</div>
<div>
<h3>the+</h3>
<ul><li>(defMacro (the+ ck obj) (list 'let1 (list 'obj obj) (list 'check 'obj ck) 'obj))</ul></div>
<div>
</div>

<h2>Block Loop For While Until DoTimes Repeat</h2>
<div>
<h3>block</h3>
<ul>
<li>
Establish a block named BLOCK-NAME and evaluate the FORMS as an
implicit `begin' inside it.  The forms may use `returnFrom' to
nonlocally exit from the block.
Note that unlike in Common Lisp, there is no separate namespace for
block names; a block is named in the normal variable namespace.
</ul>
</div>
<div>
<h3>returnFrom</h3>
<ul>
<li>
Abort evaluation and return the optional VALUE? (which lsts to
void) from the block named BLOCK-NAME.  It is an error to return from
a block whose dynamic extent has ended.
<li>$(fn (blockName . value?))
</ul>
</div>
<div>
<h3>while</h3>
<ul>
<li>
Evaluate FORMS while TEST-FORM evaluates to true.
</ul>
</div>
<div>
<h3>%loop</h3>
<ul><li>(def %loop</ul></div>
<div>
</div>
<div>
<h3>loop</h3>
<ul><li>(def loop %loop)</ul></div>
<div>
</div>
<div>
<h3>for1</h3>
<ul><li>(defMacro (for1 ((#! Symbol var) init cond . incr) . body)</ul></div>
<div>
</div>
<div>
<h3>for1</h3>
<ul><li>(defMacro (for1 ((#! Symbol var) init . incr) cond . body)</ul></div>
<div>
</div>
<div>
<h3>while</h3>
<ul>
<li>
Evaluate FORMS while TEST-FORM evaluates to true.
</ul>
</div>
<div>
<h3>until</h3>
<ul>
<li>
Evaluate FORMS until TEST-FORM evaluates to true.
</ul>
</div>
<div>
<h3>doTimes</h3>
<ul>
<li>
Cf. Common Lisp's DOTIMES.
</ul>
</div>
<div>
<h3>repeat</h3>
<ul><li>(defVau (repeat times . forms) env</ul></div>
<div>
</div>
<div>
<h3>doTimes</h3>
<ul><li>(defMacro doTimes ((var times . result) . body)</ul></div>
<div>
</div>
<div>
<h3>repeat</h3>
<ul><li>(defVau (repeat times . forms) env</ul></div>
<div>
</div>
<div>
<h3>doTimes</h3>
<ul><li>(defMacro doTimes ((var times . result) . body)</ul></div>
<div>
</div>

<h2>Lists</h2>
<div>
<h3>any?</h3>
<ul><li>(def\ (any? f lst . lst*)</ul></div>
<div>
</div>
<div>
<h3>any?*</h3>
<ul><li>(defMacro (any?* f . lst) (list 'any? f lst))</ul></div>
<div>
</div>
<div>
<h3>all?</h3>
<ul><li>(def\ (all? f lst . lst*)</ul></div>
<div>
</div>
<div>
<h3>all?*</h3>
<ul><li>(defMacro (all?* f . lst) (list 'all? f lst))</ul></div>
<div>
</div>
<div>
<h3>forEach#</h3>
<ul>
<li>
Apply the FUNCTION to every element of the LIST for effect. Return the #inert.
</ul>
</div>
<div>
<h3>forEach</h3>
<ul>
<li>
Apply the FUNCTION to every element of the LIST for effect. Return the list.
</ul>
</div>
<div>
<h3>maplist</h3>
<ul>
<li>
Apply the FUNCTION, which must return a list, to every element of the
LIST, and append the results.  (Note: this currently uses `append',
but might be changed to use `nconc' in the future, like Common Lisp.)
</ul>
</div>
<div>
<h3>filter</h3>
<ul><li>(def\ (filter f lst . lst*)</ul></div>
<div>
</div>
<div>
<h3>remove</h3>
<ul>
<li>
Return a new list from which the elements that satisfy the TEST have been removed.
</ul>
</div>
<div>
<h3>reduceL</h3>
<ul><li>(def\ (reduceL f init lst . lst*)</ul></div>
<div>
</div>
<div>
<h3>reduce</h3>
<ul>
<li>
Use the binary FUNCTION to combine the elements of the LIST.  The
INITIAL-VALUE is logically placed before the list.
</ul>
</div>
<div>
<h3>reduceR</h3>
<ul><li>(def\ (reduceR f init lst . lst*)</ul></div>
<div>
</div>
<div>
<h3>foldL</h3>
<ul><li>(def\ (foldL f init lst . lst*)</ul></div>
<div>
</div>
<div>
<h3>foldR</h3>
<ul><li>(def\ (foldR f init lst . lst*)</ul></div>
<div>
</div>
<div>
<h3>dolist</h3>
<ul>
<li>
Cf. Common Lisp's DOLIST.
</ul>
</div>
<div>
<h3>make\*</h3>
<ul><li>(def\ (make\* n f)</ul></div>
<div>
</div>

<h2> Arrays</h2>
<div>
<h3>array-&gt;list</h3>
<ul><li>(def\ (array-&gt;list arr)</ul></div>
<div>
</div>
<div>
<h3>array-&gt;cons</h3>
<ul><li>(def\ (array-&gt;cons arr)</ul></div>
<div>
</div>
<div>
<h3>list-&gt;array</h3>
<ul><li>(def list-&gt;array %list-&gt;array)</ul></div>
<div>
</div>
<div>
<h3>array</h3>
<ul><li>(def\ (array . args) (list-&gt;array args))</ul></div>
<div>
</div>
<div>
<h3>Object[]</h3>
<ul><li>(def Object[] &amp;java.lang.Object[])</ul></div>
<div>
</div>
<div>
<h3>arrayMap</h3>
<ul><li>(def\ (arrayMap fun (#! Object[] arr))</ul></div>
<div>
</div>
<div>
<h3>arrayFilter</h3>
<ul><li>(def\ (arrayFilter pred (#! Object[] arr))</ul></div>
<div>
</div>
<div>
<h3>newInstance</h3>
<ul><li>(def\ (newInstance class dim . dims)</ul></div>
<div>
</div>
<div>
<h3>arrayGet</h3>
<ul><li>(def\ (arrayGet array index)</ul></div>
<div>
</div>
<div>
<h3>arrayGet*</h3>
<ul><li>(def\ (arrayGet* array . indexes)</ul></div>
<div>
</div>
<div>
<h3>arraySet</h3>
<ul><li>(def\ (arraySet array index value)</ul></div>
<div>
</div>
<div>
<h3>arraySet*</h3>
<ul><li>(def\ (arraySet* array0 value . indexes)</ul></div>
<div>
</div>

<h2>Simple Set</h2>
<div>
<h3>set?</h3>
<ul><li>(def\ (set? lst) (if (null? lst) #t (apply /= lst)))</ul></div>
<div>
</div>
<div>
<h3>set+</h3>
<ul><li>(def\ (set+ v lst)</ul></div>
<div>
</div>
<div>
<h3>defSet+</h3>
<ul><li>(defVau (defSet+ (#! Symbol plc) v) env</ul></div>
<div>
</div>
<div>
<h3>-&gt;set</h3>
<ul><li>(def\ -&gt;set (lst)</ul></div>
<div>
</div>
<div>
<h3>-&gt;set</h3>
<ul><li>(def\ -&gt;set (lst)</ul></div>
<div>
</div>

<h2>Syntetic Expression</h2>
<div>
<h3>%´</h3>
<ul><li>(defMacro %´ ((#! (or Symbol List) x))</ul></div>
<div>
</div>

<h2>Box</h2>
<div>
<h3>newBox</h3>
<ul>
<li>
Create a new box with the optional INITIAL-VALUE?.  A box is a
function that encapsulates a mutable value.  Calling the box without
arguments returns the value.  Calling the box with an argument sets
the value.
<li>$(fn initialValue?)
<li>$(type function)
</ul>
</div>
<div>
<h3>defBox</h3>
<ul><li>(defMacro (defBox name . value?)</ul></div>
<div>
</div>

<h2>Dynamic Binding</h2>
<div>
<h3>newDVar</h3>
<ul><li>(def newDVar %newDVar)</ul></div>
<div>
<h3>dval</h3>
<ul><li>(def dval %dVal)</ul></div>
<div>
</div>
<div>
<h3>ddef</h3>
<ul>
<li>
Define a new or update an existing dynamic variable with the given
NAME and optDft default VALUE.
<li>$(fn (name))
<li>$(fn (name value))
</ul>
</div>
<div>
<h3>ddef*</h3>
<ul><li>(defMacro (ddef* var* . val*)</ul></div>
<div>
</div>
<div>
<h3>dget</h3>
<ul>
<li>
Return the current value of the DYNAMIC-VARIABLE.
</ul>
</div>
<div>
<h3>dset</h3>
<ul>
<li>
Set the current value of the DYNAMIC-VARIABLE.
</ul>
</div>
<div>
<h3>dlet</h3>
<ul>
<li>
Evaluate the FORMS with the dynamic variables specified by BINDINGS
temporarily bound to new values.  Bindings are established parallely
as per `let'.
<li>$(syntax binding (dynamicVariable value))
</ul>
</div>
<div>
<h3>progv</h3>
<ul>
<li>
Evaluate the FORMS with the list of DYNAMIC-VARIABLES temporarily
bound to new VALUES.  The DYNAMIC-VARIABLES and VALUES lists must have
the same length.
</ul>
</div>
<div>
<h3>dlet*</h3>
<ul>
<li>
Evaluate the FORMS with the dynamic variables specified by BINDINGS
temporarily bound to new values.  Bindings are established serially as
per `let*'.
</ul>
</div>

<h2>Classes</h2>
<div>
<h3>findClass</h3>
<ul>
<li>
Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT.
</ul>
</div>
<div>
<h3>defClass</h3>
<ul>
<li>
Define a new `StandardClass' with the given NAME, optional SUPERCLASS?, and SLOT-SPECS.
The superclass defaults to `standard-object'.
The SLOT-SPECS and PROPERTIES are currently ignored.
<li>$(syntax slotSpec symbol)
<li>$(syntax property (:documentation docstring))
</ul>
</div>

<h2>Generic Functions</h2>
<div>
<h3>defGeneric</h3>
<ul>
<li>
Define a new generic function with the given NAME.
The RECEIVER, PARAMETERS, and PROPERTIES are currently ignored.
<li>$(syntax property (:documentation docstring))
</ul>
</div>
<div>
<h3>defMethod</h3>
<ul>
<li>
Add a new method to the generic function named by NAME
specialized for the class named by CLASS-NAME.
</ul>
</div>

<h2>Modules</h2>
<div>
<h3>provide</h3>
<ul><li>(defVau (provide symbols . body) env</ul></div>
<div>
</div>
<div>
<h3>module</h3>
<ul><li>(defVau (module exports . body) env</ul></div>
<div>
</div>
<div>
<h3>defModule</h3>
<ul><li>(defMacro (defModule name exports . body)</ul></div>
<div>
</div>
<div>
<h3>import</h3>
<ul><li>(defVau (import module imports) env</ul></div>
<div>
</div>

<h2>Relational Operators</h2>
<div>
<h3>relationalOp</h3>
<ul>
<li>
Utility to create an n-ary relational operator from a BINARY-OPERATOR.
</ul>
</div>
<div>
<h3>&lt;</h3>
<ul>
<li>
Return true if the ARGUMENTS are in monotonically increasing order,
false otherwise.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>&gt;</h3>
<ul>
<li>
Return true if the ARGUMENTS are in monotonically decreasing order,
false otherwise.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>&lt;=</h3>
<ul>
<li>
Return true if the ARGUMENTS are in monotonically nondecreasing
order, false otherwise.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>&gt;=</h3>
<ul>
<li>
Return true if the ARGUMENTS are in monotonically nonincreasing
order, false otherwise.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>eq?</h3>
<ul>
<li>
Return true if all ARGUMENTS are equal, false otherwise.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>==</h3>
<ul>
<li>
Return true if all ARGUMENTS are ==, false otherwise.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>!=</h3>
<ul>
<li>
Return true if all ARGUMENTS are ==, false otherwise.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>/=</h3>
<ul>
<li>
Return true if all ARGUMENTS are distinct, false otherwise.
<li>$(fn arguments)
</ul>
</div>
<div>
<h3>/=</h3>
<ul><li>(def\ /= args</ul></div>
<div>
</div>

<h2>Thetic &amp; Lytic</h2>
<div>
<h3>theticOp</h3>
<ul>
<li>
Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE.
</ul>
</div>
<div>
<h3>+</h3>
<ul>
<li>
Return the sum of the ARGUMENTS, or 0 if no arguments are supplied.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>*</h3>
<ul>
<li>
Return the product of the ARGUMENTS, or 1 if no arguments are supplied.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>$</h3>
<ul>
<li>
Return the join of the ARGUMENTS, or &quot;&quot; if no arguments are supplied.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>lyticOp</h3>
<ul>
<li>
Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE.
</ul>
</div>
<div>
<h3>-</h3>
<ul>
<li>
If only one number is supplied in the ARGUMENTS, return the
negation of that number. If more than one number is supplied, subtract
all of the later ones from the first one and return the result.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>
<div>
<h3>/</h3>
<ul>
<li>
If only one number is supplied in the ARGUMENTS, return the
reciprocal of that number.  If more than one number is supplied,
divide the first one by all of the later ones and return the result.
<li>$(fn arguments)
<li>$(type function)
</ul>
</div>

<h2> Greatest Common Divisor e Lowest Common Multiple</h2>
<div>
<h3>gcd</h3>
<ul><li>(def\ (gcd a b . more)</ul></div>
<div>
</div>
<div>
<h3>abs</h3>
<ul><li>(def abs (let1 (abs (@getMethod Math &quot;abs&quot; &amp;int)) (\ (n) (abs #null n))))</ul></div>
<div>
</div>
<div>
<h3>lcm</h3>
<ul><li>(def\ (lcm a b . more)</ul></div>
<div>
</div>

<h2>Sequences</h2>
<div>
<h3>length</h3>
<ul>
<li>
Return the number of elements in a sequence.
</ul>
</div>
<div>
<h3>length</h3>
<ul><li>(defMethod length ((seq List))</ul></div>
<div>
</div>
<div>
<h3>length</h3>
<ul><li>(defMethod length ((seq Null))</ul></div>
<div>
</div>
<div>
<h3>elt</h3>
<ul>
<li>
Return the sequence element at the specified index.
</ul>
</div>
<div>
<h3>elt</h3>
<ul><li>(defMethod elt ((seq List) index)</ul></div>
<div>
</div>
<div>
<h3>elt</h3>
<ul><li>(defMethod elt ((seq String) index)</ul></div>
<div>
</div>
<div>
<h3>subSeq</h3>
<ul>
<li>
Create a sequence that is a copy of the subsequence
of the SEQUENCE bounded by START and optional END?.  If END?  is not
supplied or void, the subsequence stretches until the end of the list
</ul>
</div>
<div>
<h3>subSeq</h3>
<ul><li>(defMethod subSeq ((seq List) start . end)</ul></div>
<div>
</div>
<div>
<h3>subSeq</h3>
<ul><li>(defMethod subSeq ((seq Null) start . end)</ul></div>
<div>
</div>
<div>
<h3>subSeq</h3>
<ul><li>(defMethod subSeq ((seq String) start . end)</ul></div>
<div>
</div>

<h2>Coroutines</h2>
<div>
<h3>coroutinePrompt</h3>
<ul>
<li>
This prompt is used for general coroutine-like use of continuations.
</ul>
</div>
<div>
<h3>coroutine</h3>
<ul>
<li>
Evaluate the FORMS in a context in which `yield' can be used to pause execution.
</ul>
</div>
<div>
<h3>yield</h3>
<ul>
<li>
Pause the current coroutine.  In the place where the enclosing
`coroutine' (or `resume') was called, evaluate the FORMS with NAME
bound to the paused coroutine.  `resume' can later be used to restart
execution inside the coroutine.
</ul>
</div>
<div>
<h3>resume</h3>
<ul>
<li>
Resume the paused coroutine K and evaluate FORMS in the place where
`yield' was called in the coroutine.
</ul>
</div>

<h2>Fibers</h2>
<div>
<h3>fiberPrompt</h3>
<ul>
<li>
The prompt used for delimiting fibers.
</ul>
</div>
<div>
<h3>YieldRecord</h3>
<ul>
<li>
Instances of this class are yielded.
</ul>
</div>
<div>
<h3>makeYieldRecord</h3>
<ul>
<li>
Create a new yield record with the given yielded value and resume continuation.
</ul>
</div>
<div>
<h3>fiberYield</h3>
<ul>
<li>
Yield a value (which defaults to void).
</ul>
</div>
<div>
<h3>fiberResume</h3>
<ul>
<li>
Resume a suspended fiber with a value (which defaults to void).
</ul>
</div>
<div>
<h3>fiber</h3>
<ul>
<li>
Evaluate the body expressions as a fiber.
</ul>
</div>
<div>
<h3>runFiber*</h3>
<ul>
<li>
Get all values yielded by a fiber, and its final result, and collect them in a list.
Uses the optional list of values to sent to the fiber with `fiberResume'.
</ul>
</div>
<div>
<h3>runFiberWithValues</h3>
<ul><li>(defMacro (runFiberWithValues f args) (list 'eval (list 'list* 'runFiber* f args))) </ul></div>
<div>
<h3>runFiberWithValues</h3>
<ul><li>(defMacro (runFiberWithValues f args) (list 'apply 'runFiber* (list 'cons f args))) </ul></div>
<div>
<h3>runFiberWithValues</h3>
<ul><li>(defMacro (runFiberWithValues f args) (list 'apply** 'runFiber* f args)) </ul></div>
<div>
</div>
<div>
<h3>runFiber</h3>
<ul><li>(def runFiber runFiber*)</ul></div>
<div>
</div>

<h2>Auto Increment/Decrement and Assignement Operator</h2>
<div>
<h3>++</h3>
<ul><li>(defVau (++ plc . args) env</ul></div>
<div>
</div>
<div>
<h3>--</h3>
<ul><li>(defVau (-- plc . args) env</ul></div>
<div>
</div>
<div>
<h3>assignOp</h3>
<ul><li>(def\ (assignOp op)</ul></div>
<div>
</div>
<div>
<h3>$=</h3>
<ul><li>(def $= (assignOp %$))</ul></div>
<div>
<h3>+=</h3>
<ul><li>(def += (assignOp %+))</ul></div>
<div>
<h3>-=</h3>
<ul><li>(def -= (assignOp %-))</ul></div>
<div>
</div>

<h2>Java Try/Resource</h2>
<div>
<h3>close1</h3>
<ul><li>(defMacro (close1 binding . body)</ul></div>
<div>
</div>
<div>
<h3>close</h3>
<ul><li>(defMacro (close bindings . body)</ul></div>
<div>
</div>

<h2>Utility</h2>
<div>
<h3>time</h3>
<ul><li>(defVau (time times . forms) env</ul></div>
<div>
</div>
</html>
