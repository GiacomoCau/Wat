(defCaseVau derive
    ((('/ 1 x) x) `(/ -1 (pow ,x 2)))
    ((('sqr x) x) `(/ 1 (* 2 (sqr ,x))))
    ((('sin x) x) `(cos ,x))
    ((('cos x) x) `(- (sin ,x)))
    ((('tan x) x) `(/ 1 (pow (cos ,x) 2)))
    ((('exp x) x) `(exp ,x))
    ((('log x) x) `(/ 1 ,x))
    ((('log a x) x) `(/ 1 (* ,x (log ,a))))
    ((('pow a x) x) `(* (pow ,a ,x) (log ,a)))
    ((('+ (f x) (g x)) x)
     (let ( (d1 (apply* derive `(,f ,x) `,x))
            (d2 (apply* derive `(,g ,x) `,x)) )
       `(+ ,d1 ,d2) ))
    ((('* (#! Number k) (f x)) x)
     (let1 (d (apply* derive `(,f ,x) `,x)) 
       `(* ,k ,d) ))
    ((('* (f x) (g x)) x)
     (let ( (d1 (apply* derive `(,f ,x) `,x))
            (d2 (apply* derive `(,g ,x) `,x)) )
       `(+ (* ,d1 (,g ,x)) (* (,f ,x) ,d2)) ))
    ((('/ (f x) (g x)) x)
     (let ( (d1 (apply* derive `(,f ,x) `,x))
            (d2 (apply* derive `(,g ,x) `,x)) )
       `(/ (+ (* ,d1 (,g ,x))
              (* (,f ,x) ,d2 (pow (,g ,x) 2)) ))))
    (else => (\ (x) (simpleError ($ "underivable expr: " x)))) )

(%assert (derive (* "3" (sin a)) a) SimpleError :type 'simple :message "underivable expr: ((* \"3\" (sin a)) a)")
(%assert (derive (/ (tan a) (sqr a)) a) '(/ (+ (* (/ 1 (pow (cos a) 2)) (sqr a)) (* (tan a) (/ 1 (* 2 (sqr a))) (pow (sqr a) 2)))))

