
(def\ (<- env . keys)
  (if (null? keys) env
    (apply** <- (env (car keys)) (cdr keys)))) 

(def\ (instance cls . args) (apply (cls :init) args))

(defVau (class extend . bindings) env
  (def\ (->\||begin lhs rhs) (if (cons? lhs) (list* '\ (cdr lhs) rhs) (->begin (cons lhs rhs))) )
  (def\ (object bindings super)
    (def this (newEnv super))
    (forEach (\ (b) (this (if (cons? b) (->name (car b)) b) #inert)) bindings)
    (forEach (\ (b) (when (cons? b) (let1 ((lhs . rhs) b) (this (->name lhs) (eval (apply* ->\||begin lhs rhs) this))))) bindings)
    this )
  (def static (if (|| (atom? (car bindings)) (!= (caar bindings) 'static)) () (prog1 (cdar bindings) (def bindings (cdr bindings)))))
  (def hasnew? ((rec\ (loop b) (if (null? b) #f (atom? (car b)) (loop (cdr b)) (let1 (((n . #_) . b) b) (if (&& (cons? n) (== (car n) 'new)) #t (loop b))))) bindings))
  (def extend (if (null? extend) () (eval extend env)))
  (if (&& (!null? extend) (extend :hasnew?) (! hasnew?)) (error "new not defined!"))
  (def class (object static (if (null? extend) env extend)))
  (class :cnt :hasnew? hasnew? :init  
    (\ args
      (def proxi (newEnv env (newObj class)))
      (def obj ((object bindings proxi) :cnt :static class))
      (def new (@remove (.map obj) "new"))
      (if (null? new)
        (if (null? extend)
          (obj :this obj :super env)
          (let1 (super (apply instance (cons extend args) env))
            (.parent proxi super) (obj :this obj :super super) ))
        (if (null? extend)
          (apply new args (obj :cnt :this obj :super env))
          (let1\ (!this #_ (error "this not yet defined!"))
            ;; new invocation (new must invoke (super ...) if (&& (!null? extend) (extend :hasnew?)))
            (apply new args  
              (obj :cnt :this !this :super
                (\ args
                  (def super (apply instance (cons extend args) env))
                  (.parent proxi super) (obj :this obj :super super) )))
            (when (== (obj :this) !this) (error "super not invoked!")) )))
      obj )))

(def\ (is? instance class)
  (if (&& (type? instance Env) (!null? (def static :rhs (@get (.map instance) "static"))))
    (extend? static class)
    (error "is not an instance!") ))

(def\ (extend? class superClass)
  (if (null? class) #f (== class superClass) #t (extend? (.parent class) superClass)) )

(defMacro (invoke method obj . args)
  (list* (list obj method) args) )

(defMacro (invoke obj method . args)
  (list* (list obj method) args) )

;(load "varie/yaos/yaos.lsp")

(let ()
  (def A (class () (a 1)))
  (def B (class A (b 2)))
  (def b (instance B))
  (assert (b :static) B)
  (assert (.parent B) A)
  (assert (is? b A) #t)
  (assert (extend? B A) #t) )

(let ()
  (def A (class () (a 1) (B (class () ((new b) (this :b b)) (b 0) ((f c) (+ a b c))))))
  (def objA (instance A))
  (def objB (instance (objA :B) 2)) 
  (assert ((objB :f) 3) 6)
)
(let ()  
  (def A (class () (a 1)))
  (def B (class A (b 2)))
  (def C (class B (c 3) ((f d) (+ a b c d))))
  (def objA (instance A))
  (def objB (instance B))
  (def objC (instance C))
  (assert ((objC :f) 4) 10)
)
(let ()  
  (def A (class () ((new a) (this :a a))))
  (def B (class A ((new) (super 1)) (b 2)))
  (def C (class B ((new) (super)) (c 3) (a 5) ((f d) (+ (super :a) b c d))))
  (def objA (instance A 1))
  (def objB (instance B))
  (def objC (instance C))
  (assert ((objC :f) 4) 10)
)
(let ()  
  (def A (class () ((new a) (this :a a))))
  (def B (class A ((new) #;(super 1)) (b 2)))
  (assert (instance B) Error @getMessage "super not invoked!")
)
(let ()  
  (def A (class () ((new a) (this :a a))))
  (def B (class A ((new) (this) (super 1)) (b 2)))
  (assert (instance B) Error @getMessage "this not yet defined!")
)
(let ()  
  (def A (class () (a 1)))
  (def B (class A (static (a 0)) (b 2) ((f c) (+ (super :a) b c)) ((g c) (+ (static :a) b c)) ((h c) (+ a b c))))
  (def objB (instance B))
  (assert ((objB :f) 3) 6)
  (assert ((objB :g) 3) 5)
  (assert ((objB :h) 3) 5)
)
(let ()
  (def A (class () (static (a 0)) ((new) (++ a) (++ static a) (++ A a)) ((f) (++ static a) (++ A a))))
  (instance A)
  (def objA (instance A))
  (assert (A :a) 6)
  (assert ((objA :f)) 8) 
)
(let ()
  (def A (class () (static (a 1))))
  (def B (class A  (b 2)))
  (def b1 (instance B))
  (def b2 (instance B))
  (b1 :set! :a 3)
  (assert (== (A :a) (b1 :a) (b2 :a)) #t)
)
(let ()
  (def A (class () (static ((a) 1)) ((a) 2)))
  (def B (class A  (static ((b) (a))) ))
  (def b (instance B))
  (assert ((B :b)) 1)
  (assert ((b :b)) 1)
)
(let ()
  (def A (class () (static ((a) 1)) ((a) 2)))
  (def B (class A  (static ((b) (a))) ((b) (a)) ))
  (def b (instance B))
  (assert ((B :b)) 1)
  (assert ((b :b)) 2)
  (assert ((<- b :static :b)) 1)
)
(let ()
  (def A (class () ((new))))
  (assert (class A (b 1)) Error @getMessage "new not defined!")
)
(let ()
  (def A (class () ((new))))
  (def B (class A ((new) ) (b 1)))
  (assert (instance B) Error @getMessage "super not invoked!")
)
(let ()
  (def A (class () a (b 1) ((f) (list a b))))
  (assert (((instance A) :f)) (#inert 1))
)
