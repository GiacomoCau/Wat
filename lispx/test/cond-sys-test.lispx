(defsuite handlerBind

  (defClass TestError (Error) ())

  (deftest handlerBind.0
    (signalsError?
     (handlerBind)
     Error :type 'match :operands +1))

  (deftest handlerBind.0b
    (handlerBind ())
    #inert)

  (deftest handlerBind.1
    (handlerBind ()
      1 2 (+ 1 2))
    3)

  (deftest handlerBind.2
    (handlerBind ((SimpleError (\ (e) 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest handlerBind.3
    (handlerBind ((SimpleError (\ (e) 'whatever))
                   (TestError (\ (e) 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest handlerBind.no-handler
    (handlerBind ((TestError (\ (e) 'whatever)))
      (signal (makeSimpleError "foo")))
    #inert)

  (deftest handlerBind.unhandled
    (handlerBind ((SimpleError (\ (e) 'whatever)))
      (signal (makeSimpleError "foo")))
    #inert)

  (deftest handlerBind.decline
    (block b
      (handlerBind ((SimpleError (\ (e) (returnFrom b 1))))
        (handlerBind ((SimpleError (\ (e) 'decline)))
          (signal (makeSimpleError "foo")))))
    1)

  (deftest handlerBind.handled
    (block b
      (handlerBind ((SimpleError (\ (e)
                                     (assert (eq? "foo" (@getMessage e)))
                                     (returnFrom b 1))))
        (signal (makeSimpleError "foo"))))
    1)

  (deftest handlerBind.nested
    (block b
      (handlerBind ((SimpleError (\ (e) (returnFrom b 'outer))))
        (handlerBind ((SimpleError (\ (e) (returnFrom b 'inner))))
          (signal (makeSimpleError "foo")))))
    'inner)

  (deftest handlerBind.resignal
    (block b
      (handlerBind ((SimpleError (\ (e) (returnFrom b 'outer))))
        (handlerBind ((SimpleError (\ (e) (signal e))))
          (signal (makeSimpleError "foo")))))
    'outer)

  (deftest handlerBind.firewall
    (block b
      (handlerBind ((TestError (\ (e) (returnFrom b 'outer))))
        (handlerBind ((SimpleError (\ (e)
                                       (signal (new TestError)))))
          (handlerBind ((TestError (\ (e) (returnFrom b 'inner))))
            (signal (makeSimpleError "foo"))))))
    'outer)

  (deftest handlerBind.multiple.1
    (block b
      (handlerBind ((TestError (\ (e) (returnFrom b 'test)))
                     (SimpleError (\ (e) (returnFrom b 'simple))))
        (signal (makeSimpleError "foo"))))
    'simple)

  (deftest handlerBind.multiple.2
    (block b
      (handlerBind ((TestError (\ (e) (returnFrom b 'test)))
                     (SimpleError (\ (e) (returnFrom b 'simple))))
        (signal (new TestError))))
    'test)

  (deftest handlerBind.anything
    (block b
      (handlerBind ((Object (\ (e) (returnFrom b e))))
        (signal "foo")))
    "foo"))

(defsuite handlerCase

  (defClass TestError (Error) ())

  (deftest handlerCase.0
    (signalsError?
     (handlerCase)
     Error :type 'match :operands +1))

  (deftest handlerCase.0b
    (handlerCase ())
    #inert)

  (deftest handlerCase.1
    (handlerCase ()
      1 2 (+ 1 2))
    3)

  (deftest handlerCase.2
    (handlerCase ((SimpleError (\ (e) 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest handlerCase.3
    (handlerCase ((SimpleError (\ (e) 'whatever))
                   (TestError (\ (e) 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest handlerCase.no-handler
    (handlerCase ((TestError (\ (e) 'whatever)))
      (signal (makeSimpleError "foo")))
    #inert)

  (deftest handlerCase.handled
    (handlerCase ((SimpleError (\ (e)
                                   (assert (eq? "foo" (@getMessage e)))
                                   'whatever)))
      (signal (makeSimpleError "foo")))
    'whatever)

  (deftest handlerCase.nested
    (handlerCase ((SimpleError (\ (e) 'outer)))
      (handlerCase ((SimpleError (\ (e) 'inner)))
        (signal (makeSimpleError "foo"))))
    'inner)

  (deftest handlerCase.resignal
    (handlerCase ((SimpleError (\ (e) 'outer)))
      (handlerCase ((SimpleError (\ (e) (signal e))))
        (signal (makeSimpleError "foo"))))
    'outer)

  (deftest handlerCase.multiple.1
    (handlerCase ((TestError (\ (e) 'test))
                   (SimpleError (\ (e) 'simple)))
      (signal (makeSimpleError "foo")))
    'simple)

  (deftest handlerCase.multiple.2
    (handlerCase ((TestError (\ (e) 'test))
                   (SimpleError (\ (e) 'simple)))
      (signal (new TestError)))
    'test)

  (deftest handlerCase.anything
    (handlerCase ((Object (\ (e) e)))
      (signal "foo"))
    "foo"))

(defsuite restartBind

  (deftest restartBind.0
    (signalsError?
     (restartBind)
     Error :type 'match :operands +1))

  (deftest restartBind.0b
    (restartBind ())
    #inert)

  (deftest restartBind.1
    (restartBind ()
      1 2 (+ 1 2))
    3)

  (deftest restartBind.2
    (restartBind ((continue (\ () 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest restartBind.3
    (restartBind ((continue (\ () 'whatever))
                   (abort (\ () 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest restartBind.no-handler.1
    (signalsError?
     (invokeRestart 'continue)
     RestartError :restartName 'continue))

  (deftest restartBind.no-handler.2
    (signalsError?
     (restartBind ((continue (\ () 'whatever)))
       (invokeRestart 'abort))
     RestartError :restartName 'abort))

  (deftest restartBind.no-handler.1a
    (signalsError?
     (invokeRestartInteractively 'continue)
     RestartError :restartName 'continue))

  (deftest restartBind.no-handler.2a
    (signalsError?
     (restartBind ((continue (\ () 'whatever)))
       (invokeRestartInteractively 'abort))
     RestartError :restartName 'abort))

  (deftest restartBind.no-exit.1
    (restartBind ((continue (\ () 'whatever)))
      (invokeRestart 'continue))
    'whatever)

  (deftest restartBind.no-exit.2
    (restartBind ((continue (\ () 'whatever)))
      (ifOpt? (restartHandler (findRestart? 'continue))
        (invokeRestart restartHandler)
        (assert #f)))
    'whatever)

  (deftest restartBind.handled
    (block b
      (restartBind ((abort (\ (arg1 arg2)
                              (assert (eq? 1 arg1))
                              (assert (eq? 2 arg2))
                              (returnFrom b 3))))
        (invokeRestart 'abort (+ 0 1) (+ 1 1))))
    3)

  (deftest restartBind.nested
    (block b
      (restartBind ((continue (\ () (returnFrom b 'outer))))
        (restartBind ((continue (\ () (returnFrom b 'inner))))
          (invokeRestart 'continue))))
    'inner)

  (deftest restartBind.reinvoke
    (block b
      (restartBind ((y (\ (val) (returnFrom b (+ val 1)))))
        (restartBind ((x (\ (val) (invokeRestart 'y (+ val 1)))))
          (invokeRestart 'x 1))))
    3)

  (deftest restartBind.no-firewall
    (block b
      (restartBind ((r1 (\ () (returnFrom b 'outer))))
        (restartBind ((r2 (\ () (invokeRestart 'r1))))
          (restartBind ((r1 (\ () (returnFrom b 'inner))))
            (invokeRestart 'r2)))))
    'inner)

  (deftest restartBind.multiple.1
    (block b
      (restartBind ((r1 (\ (arg) (returnFrom b (- 100 arg))))
                     (r2 (\ (arg) (returnFrom b (+ 100 arg)))))
        (invokeRestart 'r2 1)))
    101)

  (deftest restartBind.multiple.2
    (block b
      (restartBind ((r1 (\ (arg) (returnFrom b (- 100 arg))))
                     (r2 (\ (arg) (returnFrom b (+ 100 arg)))))
        (invokeRestart 'r1 1)))
    99))

(defsuite restartCase

  (deftest restartCase.0
    (signalsError?
     (restartCase)
     Error :type 'match :operands +1))

  (deftest restartCase.0b
    (restartCase ())
    #inert)

  (deftest restartCase.1
    (restartCase ()
      1 2 (+ 1 2))
    3)

  (deftest restartCase.2
    (restartCase ((continue (\ () 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest restartCase.3
    (restartCase ((continue (\ () 'whatever))
                   (abort (\ () 'whatever)))
      1 2 (+ 1 2))
    3)

  (deftest restartCase.no-handler.1
    (signalsError?
     (invokeRestart 'continue)
     RestartError :restartName 'continue))

  (deftest restartCase.no-handler.2
    (signalsError?
     (restartCase ((continue (\ () 'whatever)))
       (invokeRestart 'abort))
     RestartError :restartName 'abort))

  (deftest restartCase.no-exit.1
    (restartCase ((continue (\ () 'whatever)))
      (invokeRestart 'continue))
    'whatever)

  (deftest restartCase.no-exit.2
    (restartCase ((continue (\ () 'whatever)))
      (ifOpt? (restartHandler (findRestart? 'continue))
        (invokeRestart restartHandler)
        (assert #f)))
    'whatever)

  (deftest restartCase.handled
    (restartCase ((abort (\ (arg1 arg2)
                            (assert (eq? 1 arg1))
                            (assert (eq? 2 arg2))
                            3)))
      (invokeRestart 'abort (+ 0 1) (+ 1 1)))
    3)

  (deftest restartCase.nested
    (restartCase ((continue (\ () 'outer)))
      (restartCase ((continue (\ () 'inner)))
        (invokeRestart 'continue)))
    'inner)

  (deftest restartCase.nested2
    (restartCase ((r1 (\ () 'outer)))
      (restartCase ((r1 (\ ()  (invokeRestart 'r1)))
                     (r2 (\ ())))
        (invokeRestart 'r1)))
    'outer)

  (deftest restartCase.reinvoke
    (restartCase ((y (\ (val) (+ val 1))))
      (restartCase ((x (\ (val) (invokeRestart 'y (+ val 1)))))
        (invokeRestart 'x 1)))
    3)

  (deftest restartCase.no-firewall
    (restartCase ((r1 (\ () 'outer)))
      (restartCase ((r2 (\ () (invokeRestart 'r1))))
        (restartCase ((r1 (\ () 'inner)))
          (invokeRestart 'r2))))
    'outer)

  (deftest restartCase.parallel
    (restartCase ((r1 (\ () 'outer)))
      (restartCase ((r1 (\ () 'inner))
                     (r2 (\ () (invokeRestart 'r1))))
        (invokeRestart 'r2)))
    'outer)

  (deftest restartCase.multiple.1
    (restartCase ((r1 (\ (arg) (- 100 arg)))
                   (r2 (\ (arg) (+ 100 arg))))
      (invokeRestart 'r2 1))
    101)

  (deftest restartCase.multiple.2
    (restartCase ((r1 (\ (arg) (- 100 arg)))
                   (r2 (\ (arg) (+ 100 arg))))
      (invokeRestart 'r1 1))
    99))

(defsuite findRestart?

  (deftest findRestart?.0
    (signalsError?
     (findRestart?)
     Error :type 'match :operands +1))

  (deftest findRestart?.1
    (findRestart? 'foo)
    #null)

  (deftest findRestart?.1b
    (restartBind ((bar (\ ())))
      (findRestart? 'foo))
    #null)

  (deftest findRestart?.2
    (findRestart? 'foo (makeSimpleError "foo"))
    #null)

  (deftest findRestart?.3
    (block exit
      (restartBind ((x (\ (arg) (returnFrom exit (+ 1000 arg)))))
        (ifOpt? (r (findRestart? 'x))
          (begin
            (assert (eq? (getSlot r 'restartName) 'x))
            (assert (eq? (getSlot r 'associatedConditions) '()))
            (invokeRestart r 1))
          (assert #f))))
    1001)

  (deftest findRestart?.3b
    (restartCase ((x (\ (arg) (+ 1000 arg))))
      (ifOpt? (r (findRestart? 'x))
        (begin
          (assert (eq? (getSlot r 'restartName) 'x))
          (assert (eq? (getSlot r 'associatedConditions) '()))
          (invokeRestart r 1))
        (assert #f)))
    1001)

  (deftest findRestart?.4
    (block exit
      (def c (makeSimpleError "foo"))
      (restartBind ((x (\ (arg) (returnFrom exit (+ 1000 arg)))
                        :associatedConditions (list c)))
        (ifOpt? (r (findRestart? 'x c))
          (begin
            (assert (eq? (getSlot r 'restartName) 'x))
            (assert (eq? (getSlot r 'associatedConditions) (list c)))
            (invokeRestart r 1))
          (assert #f))))
    1001)

  (deftest findRestart?.4b
    (begin
      (def c (makeSimpleError "foo"))
      (restartBind ((x (\ (arg) (+ 1000 arg))
                        :associatedConditions (list c)))
        (ifOpt? (r (findRestart? 'x c))
          (begin
            (assert (eq? (getSlot r 'restartName) 'x))
            (assert (eq? (getSlot r 'associatedConditions) (list c)))
            (invokeRestart r 1))
          (assert #f))))
    1001)

  (deftest findRestart?.5
    (block exit
      (def c (makeSimpleError "foo"))
      (restartBind ((x (\ (arg) (returnFrom exit (+ 1000 arg)))
                        :associatedConditions (list c)))
        (restartBind ((x (\ (arg) (returnFrom exit (- 1000 arg)))))
          (ifOpt? (r (findRestart? 'x c))
            (invokeRestart r 1)
            (assert #f)))))
    999)

  (deftest findRestart?.5b
    (begin
      (def c (makeSimpleError "foo"))
      (restartCase ((x (\ (arg) (+ 1000 arg))
                        :associatedConditions (list c)))
        (restartCase ((x (\ (arg) (- 1000 arg))))
          (ifOpt? (r (findRestart? 'x c))
            (invokeRestart r 1)
            (assert #f)))))
    999)

  (deftest findRestart?.6
    (block exit
      (def c (makeSimpleError "foo"))
      (def d (makeSimpleError "bar"))
      (restartBind ((x (\ (arg) (returnFrom exit (+ 1000 arg)))
                        :associatedConditions (list c)))
        (restartBind ((x (\ (arg) (returnFrom exit (- 1000 arg)))
                          :associatedConditions (list d)))
          (ifOpt? (r (findRestart? 'x c))
            (invokeRestart r 1)
            (assert #f)))))
    1001)

  (deftest findRestart?.6b
    (begin
      (def c (makeSimpleError "foo"))
      (def d (makeSimpleError "bar"))
      (restartCase ((x (\ (arg) (+ 1000 arg))
                        :associatedConditions (list c)))
        (restartCase ((x (\ (arg) (- 1000 arg))
                          :associatedConditions (list d)))
          (ifOpt? (r (findRestart? 'x c))
            (invokeRestart r 1)
            (assert #f)))))
    1001))

(defsuite computeRestarts

  (deftest computeRestarts.1
    (computeRestarts)
    '())

  (def\ restart-names condition?
    (let ((restarts (apply computeRestarts condition?)))
      (map (\ (restart)
                (getSlot restart 'restartName))
              restarts)))

  (deftest computeRestarts.1
    (restartCase ((outer1 (\ ()))
                   (outer2 (\ ())))
      (restartCase ((middle1 (\ ()))
                     (middle2 (\ ())))
        (restartCase ((inner1 (\ ()))
                       (inner2 (\ ())))
          (assert (eq? (restart-names)
                     '(inner1
                       inner2
                       middle1
                       middle2
                       outer1
                       outer2)))
          #t))))

  (deftest computeRestarts.2
    (begin
      (def c (makeSimpleError "foo"))
      (def d (makeSimpleError "bar"))
      (restartCase ((outer1 (\ ()))
                     (outer2 (\ ()) :associatedConditions (list c)))
        (restartCase ((middle1 (\ ()) :associatedConditions (list c))
                       (middle2 (\ ())))
          (restartCase ((inner1 (\ ()) :associatedConditions (list c d))
                         (inner2 (\ ())))
            (assert (eq? (restart-names)
                       '(inner1
                         inner2
                         middle1
                         middle2
                         outer1
                         outer2)))
            (assert (eq? (restart-names c)
                       '(inner1
                         inner2
                         middle1
                         middle2
                         outer1
                         outer2)))
            (assert (eq? (restart-names d)
                       '(inner1
                         inner2
                         middle2
                         outer1)))
            #t))))))

(defsuite signal

  (deftest signal.0
    (signalsError?
     (signal)
     Error :type 'match :operands +1))

  (deftest signal.1
    (signal (makeSimpleError "foo"))
    #inert)

  (deftest signal.2
    (signalsError?
     (signal (new Obj :x 1 :y 2))
     Obj :x 1 :y 2))

  (deftest signal.3
    (handlerBind ((SimpleError (\ (e)
                                   (invokeRestart 'continue 12))))
      (signal (makeSimpleError "Foo!")
        (abort (\ (value) (* value 10)))
        (continue (\ (value) (* value 2)))))
    24)

  (deftest signal.3b
    (handlerBind ((SimpleError (\ (e)
                                   (invokeRestart 'abort 12))))
      (signal (makeSimpleError "Foo!")
        (abort (\ (value) (* value 10)))
        (continue (\ (value) (* value 2)))))
    120)

  (deftest signal.4
    (restartCase ((abort (\ (value) (* 1000 value))))
      (handlerBind ((SimpleError (\ (e)
                                     (invokeRestart 'abort 12))))
        ;; Silly?  Yeah, probably.
        (signal (signal (makeSimpleError "Foo!"))
          (abort (\ (value) (* value 10)))
          (continue (\ (value) (* value 2))))))
    12000)

  (deftest signal.4b
    (block b
      (restartCase ((abort (\ (value) (* 1000 value))))
        (handlerBind ((SimpleError (\ (e)
                                       (invokeRestart 'abort 12))))
          (signal (signal (makeSimpleError "Foo!")
                    (abort (\ (value) (returnFrom b (* 10000 value)))))
            (abort (\ (value) (* value 10)))
            (continue (\ (value) (* value 2)))))))
    120000)

  ;;; Test that `signal' (and `error' likewise) associates the
  ;;; restarts it binds with the signalled error.
  (deftest signal.associations
    (dolist (signal-operator (list signal error) #t)
      (block ok ; so that the test doesn't fail when testing `error'.
        (handlerBind ((SimpleError
                        (\ (e)
                          (let* ((handler (opt? (findRestart? 'r e)))
                                 (a-cs (getSlot handler 'associatedConditions)))
                            (assert (cons? (member e a-cs)))
                            (returnFrom ok)))))
          (signal-operator (makeSimpleError "error!")
            (r (\ () 1))))))))

(defsuite invokeRestart

  (deftest invokeRestart.0
    (signalsError?
     (invokeRestart)
     Error :type 'match :operands +1))

  (deftest invokeRestart.1
    (signalsError?
     (invokeRestart "foo")
     Error :type 'type :datum "foo" :expected '(or Symbol RestartHandler)) ) )

(defsuite invokeRestartInteractively

  (deftest invokeRestartInteractively.1
    (restartBind ((r1 (\ (arg1 arg2) (+ arg1 arg2))
                       :interactiveFunction (\ () (list 1 2))))
      (invokeRestartInteractively 'r1))
    3)

  (deftest invokeRestartInteractively.1a
    (restartBind ((r1 (\ (arg1 arg2) (+ arg1 arg2))
                       :interactiveFunction (\ () (list 1 2))))
      (invokeRestartInteractively (opt? (findRestart? 'r1))))
    3)

  (deftest invokeRestartInteractively.1b
    (restartBind ((r1 (\ () (+ 1 2))))
      (invokeRestartInteractively 'r1))
    3)

  (deftest invokeRestartInteractively.1c
    (restartBind ((r1 (\ () (+ 1 2))))
      (invokeRestartInteractively (opt? (findRestart? 'r1))))
    3)

  (deftest invokeRestartInteractively.2
    (signalsError?
     (restartBind ((r1 (\ (arg1 arg2) (+ arg1 arg2))
                        :interactiveFunction (\ () '())))
       (invokeRestartInteractively 'r1))
     Error :type 'match :operands +2))

  (deftest invokeRestartInteractively.3
    (signalsError?
     (restartBind ((r1 (\ (arg1) arg1)
                        :interactiveFunction (\ () '(1 2))))
       (invokeRestartInteractively 'r1))
     Error :type 'match :operands -1)))

(defsuite |Condition Handling in the Lisp Language Family|
  ;; Adapted from https://www.nhplace.com/kent/Papers/Condition-Handling-2001.html

  (defClass UnboundVariable (Error) (name))

  (deftest* firewall.1
    (let ((result
           (handlerCase ((UnboundVariable (\ (c) (list 'outer c))))
             (handlerBind ((Error (\ (#ignore)
                                     (error (new UnboundVariable :name 'fred)))))
               (handlerCase ((UnboundVariable (\ (c) (list 'inner c))))
                 ;; Signal an arbitrary error:
                 (simpleError "Not an UNBOUND-VARIABLE error."))))))
      (assert (and (== (car result) 'outer)
                   (type? (cadr result) UnboundVariable)
                   (== (getSlot (cadr result) 'name) 'fred)))))

  (deftest* firewall.2
    (let ((result
           (handlerCase ((UnboundVariable (\ (c) (list 'outer c))))
             (handlerBind ((Error (\ (#ignore)
                                     (error (new UnboundVariable :name 'fred)))))
               (handlerCase ((UnboundVariable (\ (c) (list 'inner c))))
                 (error (new UnboundVariable :name 'marvin)))))))
      (assert (and (== (car result) 'inner)
                   (type? (cadr result) UnboundVariable)
                   (== (getSlot (cadr result) 'name) 'marvin))))))
