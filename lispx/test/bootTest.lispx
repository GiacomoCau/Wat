;;; LispX Main Test Suite

;; The order of the tests is haphazard.  It should be brought in line
;; with how the operators appear in boot.lispx.

(defSuite signalsError?

  (defTest \|SIGNALS-ERROR returns true if the expression signals|
    (signalsError?
     x
     Error :type 'unboundKey))

  (defTest \|SIGNALS-ERROR returns true if the expression signals a subclass|
    (signalsError?
     x
     Error))

  (defTest \|SIGNALS-ERROR returns true if the expression signals and keys match|
    (signalsError?
     x
     Error :type 'unboundKey :key 'x))

  (defTest \|SIGNALS-ERROR returns true if the expression signals a subclass and keys match|
    (signalsError?
     x
     Error :key 'x))

  (defTest \|SIGNALS-ERROR returns false if the expression signals but keys don't match|
    (signalsError?
     x
     Error :type 'unboundKey :key 'y)
    #f)

  (defTest \|SIGNALS-ERROR returns false if the expression doesn't signal|
    (signalsError?
     1
     Error)
    #f)

  (defTest \|SIGNALS-ERROR returns false if the expression signals another condition type|
    (signalsError?
     x
     Error :type 'match)
    #f))

(defSuite assert#t

  (defTest assert#t.1
    (assert#t (eq? 1 1))
    #inert)

  (defTest assert#t.2
    (signalsError?
     (assert#t (eq? 1 2))
     Error :type 'assert))

  (defTest assert#t.3
    (signalsError?
     (assert#t)
     Error :type 'match))

  (defTest assert#t.4
    (signalsError?
     (assert#t 1)
     Error :type 'type :datum 1 :expected 'Boolean))

  (defTest assert#t.5
    (signalsError?
     (assert#t #t #t)
     Error :type 'match)))

(defSuite error

  (defTest error.1
    (signalsError?
     (error (new Obj :x 1 :y 2))
     Obj :x 1 :y 2))

  (defTest error.2
    (signalsError?
     (error)
     Error :type 'match))

  (defTest error.3
    (handlerBind ((SimpleError (\ (e) (invokeRestart 'continue 12))))
      (error (makeSimpleError "Foo!")
        (abort (\ (value) (* value 10)))
        (continue (\ (value) (* value 2)))))
    24)

  (defTest error.3b
    (handlerBind ((SimpleError (\ (e) (invokeRestart 'abort 12))))
      (error (makeSimpleError "Foo!")
        (abort (\ (value) (* value 10)))
        (continue (\ (value) (* value 2)))))
    120)

  (defTest error.4
    (restartCase ((abort (\ (value) (* 1000 value))))
      (handlerBind ((SimpleError (\ (e) (invokeRestart 'abort 12))))
        (error (error (makeSimpleError "Foo!"))
          (abort (\ (value) (* value 10)))
          (continue (\ (value) (* value 2))))))
    12000)

  (defTest error.4b
    (block b
      (restartCase ((abort (\ (value) (* 1000 value))))
        (handlerBind ((SimpleError (\ (e) (invokeRestart 'abort 12))))
          (error
            (error (makeSimpleError "Foo!")
              (abort (\ (value) (returnFrom b (* 10000 value)))) )
            (abort (\ (value) (* value 10)))
            (continue (\ (value) (* value 2)))))))
    120000))

(defSuite the

  (defTest the.1
    (the Boolean (== 1 1))
    #t)

  (defTest the.2
    (signalsError?
     (the String #t)
     Error :type 'type :datum #t :expected 'String))

  (defTest the.3
    (signalsError?
     (the #t #f)
     Error :type 'type :datum #f :expected #t))

  (defTest the.4
    (signalsError?
     (the)
     Error :type 'match :operands# +2))

  (defTest the.5
    (signalsError?
     (the #t)
     Error :type 'match :operands# +1)))

(defSuite makeTypeError

  (defTest makeTypeError.1
    (let ((e (makeTypeError "foo" 'Number)))
      (assert#t (matchType?* e Error :type 'type :datum "foo" :expected 'Number))
      (assert#t (type? e Error))
      (assert#t (type? e Condition))
      (assert#t (eq? "foo" (getValue e 'datum)))
      (assert#t (eq? 'Number (getValue e 'expected))))
    #inert))

(defSuite simpleError

  (defTest makeSimpleError.1
    (let ((e (makeSimpleError "foo")))
      (assert#t (type? e SimpleError))
      (assert#t (type? e Error))
      (assert#t (type? e Condition))
      (assert#t (eq? "foo" (@getMessage e))))
    #inert)

  (defTest simpleError.1
    (signalsError?
     (simpleError)
     Error :type 'match))

  (defTest simpleError.2
    (signalsError?
     (simpleError "foo")
     SimpleError :type 'simple @getMessage "foo")))

(defSuite makeRestartError

  (defTest makeRestartError.1
    (let ((e (makeRestartError 'continue)))
      (assert#t (type? e RestartError))
      (assert#t (type? e Error))
      (assert#t (type? e Condition))
      (assert#t (eq? 'continue (getValue e 'restartName))))
    #inert))

(defSuite vau

  (defTest \|A fexpr without body expression results in #VOID|
    ((vau #ignore #ignore))
    #inert)

  (defTest \|A fexpr returns its operands unevaluated|
    ((vau ops #ignore ops) x y z)
    '(x y z))

  (defTest \|A fexpr can have multiple body expressions|
    (begin
      (def env (theEnv))
      (assert#t (eq? ((vau ops #ignore (set env var 1) ops) x y z)
                 '(x y z)))
      (assert#t (eq? (eval 'var env) 1)))
    #inert)

  (defTest \|The environment parameter receives the current environment|
    (begin
      (def env (theEnv))
      (== ((vau #ignore e e)) env)))

  (defTest \|Opv are instances of Opv, Combinable, Object|
    (let ((opv (vau #ignore #ignore 12)))
      (type? opv Opv)
      (type? opv Combinable)
      (type? opv Object)
      (opv))
    12)

  (defTest \|Arity check 1|
    (signalsError?
     (vau)
     Error :type 'match :operands# +2))

  (defTest \|Arity check 2|
    (signalsError?
     (vau x)
     Error :type 'match :operands# +1)))

(defSuite quote

  (defTest \|Quoted symbols are pointer identical|
     (== 'foo 'foo))

  (defTest \|Lists can be quoted|
    (eq? '(1 2 3) (list 1 2 3)))

  (defTest \|Numbers can be quoted|
    (eq? '1 1))

  (defTest \|Strings can be quoted|
    (eq? '"foo" "foo"))

  (defTest \|QUOTE requires at least one argument|
    (signalsError?
     (quote)
     Error :type 'match))

  (defTest \|QUOTE requires at most one argument|
    (signalsError?
     (quote 1 2 3)
     Error :type 'match)))

(defSuite list

  (defTest list.1
    (== #null (list)))

  (defTest list.2
    (eq? '(1) (list 1)))

  (defTest list.3
    (eq? '((1) (2)) (list (list 1) (list 2)))))

(defSuite list*

  (defTest list*.1
    (list*)
    #null)

  (defTest list*.2
    (list* 1 2 '(3))
    '(1 2 3))

  (defTest list*.3
    (list* 1 2 3)
    '(1 2 . 3))

  (defTest list*.4
    (list* 1 2)
    '(1 . 2))

  (defTest list*.5
    (list* 2)
    '2))

(defSuite theEnv

  (defTest theEnv.1
    (let ((x 1))
      (eval 'x (theEnv)))
    1)

  (defTest theEnv.2
    (let ((x 1)
          (env (theEnv)))
      (bound? 'x env))
    #f)

  (defTest theEnv.3
    (let* ((x 1)
           (env (theEnv)))
      (bound? 'x env))
    #t)

  (defTest theEnv.4
    (signalsError?
     (theEnv #t)
     Error :type 'match)))

(defSuite bound?

  (defTest bound?.1
    (bound? 'nope (theEnv))
    #f)

  (defTest bound?.2
    (bound? 'def\ (theEnv)))

  (defTest bound?.3
    (bound? 'Obj (theEnv)))

  (defTest bound?.4
    (signalsError?
     (bound?)
     Error :type 'match :operands# +2))

  (defTest bound?.5
    (signalsError?
     (bound? 'x)
     Error :type 'match :operands# +1))

  (defTest bound?.6
    (signalsError?
     (bound? 12 (theEnv))
     Error :type 'type :datum 12 :expected '(or Symbol Keyword String)))

  (defTest bound?.7
    (signalsError?
     (bound? 'x 33)
     Error :type 'type :datum 33 :expected 'ObjEnv))

  (defTest bound?.8
    (signalsError?
     (bound? 'x (theEnv) #t)
     Error :type 'match :operands# -1)))

(defSuite macro

  (defTest macro.0
    ((macro ()))
    #inert)

  (defTest macro.1
    (let ((z 1))
      ((macro () 'x 'y 'z)))
    1)

  (defTest macro.2
    ((macro () (list eq? 1 1)))
    #t)

  (defTest macro.3
    (signalsError?
     (macro)
     Error :type 'match)
    #t))

(defSuite defMacro

  (defTest defMacro.1
    (begin
      (defMacro mybegin body
        (list* begin body))
      (mybegin 1 2 3))
    3)

  (defTest defMacro.2
    (signalsError?
     (defMacro)
     Error :type 'match))

  (defTest defMacro.3
    (signalsError?
     (defMacro foo)
     Error :type 'match))

  (defTest defMacro.4
    (begin
      (defMacro foo ())
      (foo))
    #inert))

(defSuite defVau

  (defTest defVau.1
    (begin
      (defVau mybegin body env
        (eval (cons 'begin body) env))
      (mybegin 1 2 3))
    3)

  (defTest defVau.1'
    (begin
      (defVau mybegin body env
        (apply begin body env))
      (mybegin 1 2 3))
    3)

  (defTest defVau.2
    (signalsError?
     (defVau)
     Error :type 'match))

  (defTest defVau.3
    (signalsError?
     (defVau foo)
     Error :type 'match :operands# '+2))

  (defTest defVau.3b
    (signalsError?
     (defVau foo ())
     Error :type 'match :operands# '+1))

  (defTest defVau.4
    (begin
      (defVau foo () #ignore)
      (foo))
    #inert))

(defSuite def

  (defTest def.1
    (begin
      (def (x y z) (list 1 2 3))
      (assert#t (eq? x 1))
      (assert#t (eq? y 2))
      (assert#t (eq? z 3)))
    #inert)

  (defTest def.2
    (signalsError?
     (def :key :key)
     Error :type 'type :datum :key :expected '(or Symbol Cons)))

  (defTest def.2b
    (signalsError?
     (def :key :key2)
     Error :type 'type :datum :key :expected '(or Symbol Cons)))

  (defTest def.3
    (signalsError?
      (def #ignore 2)
    Error :type 'type :datum #ignore :expected '(or Symbol Cons)))

  (defTest def.4
    (def x 1)
    (if (== (bndRes) :rhs) 1 #inert))

  (defTest def.5
    (signalsError?
      (def () ())
    Error :type 'type :datum #null :expected '(or Symbol Cons)))

  (defTest def.6
    (signalsError?
     (def)
     Error :type 'match :operands# '+2))

  (defTest def.7
    (signalsError?
     (def x)
     Error :type 'match :operands# '+1))

  (defTest def.8
    (signalsError?
     (def #t 12)
     Error :type 'type :datum #t :expected '(or Symbol Cons)))

  (defTest def.9
    (signalsError?
     (def x 1 "docstring")
     Error :type 'type :datum 1 :expected '(or #inert #ignore :rhs :prv :cnt))))

(defSuite defConstant

  (defTest defConstant.1
    (begin
      (defConstant x 1)
      x)
    1)

  (defTest defConstant.2
    (signalsError?
     (defConstant)
     Error :type 'match :operands# '+2))

  (defTest defConstant.3
    (signalsError?
     (defConstant x)
     Error :type 'match :operands# '+1))

  (defTest defConstant.4
    (begin
      (defConstant x 1)
      x)
    1)

  (defTest defConstant.5
    (defConstant x 1)
    (if (== (bndRes) :rhs) 1 #inert)))

(defSuite \

  (defTest \.1
    ((\ ()))
    #inert)

  (defTest \.2
    ((\ args 'whatever args) 1 2 (intern "foo"))
    '(1 2 foo))

  (defTest \.3
    (signalsError?
     (\ )
     Error :type 'match))

  (defTest \.4
    (signalsError?
     (\ #t)
     Error :type 'type :datum #t :expected '(or () #ignore Symbol Cons))))

(defSuite def\

  (defTest def\.1
    (begin
      (def\ foo () 'foo)
      (def\ bar (x) (list (foo) x))
      (bar 'bar))
    '(foo bar))

  (defTest def\.2
    (begin
      (def\ nope ())
      (nope))
    #inert)

  (defTest def\.3
    (signalsError?
     (def\)
     Error :type 'match))

  (defTest def\.4
    (signalsError?
     (def\ foo)
     Error :type 'match))

  (defTest def\.5
    (signalsError?
     (def\ #t ())
     Error :type 'type :datum #t :expected '(or Symbol Cons)))

  (defTest def\.6
    (type? (def\ foo ()) (if (== (bndRes) :rhs) Apv Inert))))

(defSuite begin

  (defTest begin.1
    (begin)
    #inert)

  (defTest begin.2
    (begin (list))
    (list))

  (defTest begin.3
    (begin
      (def env (theEnv))
      (begin (set env x 1) (set env x 2) x))
    2))

(defSuite prog1

  (defTest prog1.1
    (prog1 1)
    1)

  (defTest prog1.2
    (prog1 1 2 3)
    1)

  (defTest prog1.3
    (signalsError?
     (prog1)
     Error :type 'match))

  (defTest prog1.4
    (begin
      (def env (theEnv))
      (assert#t (eq? 4 (prog1 4 (set env x 2))))
      x)
    2))

(defSuite eval

  (defTest eval.1
    (eval #null (theEnv))
    #null)

  (defTest eval.2
    (eval '(eq? 1 2) (theEnv))
    #f)

  (defTest eval.3
    (signalsError?
     (eval)
     Error :type 'match :operands# +1))

  (defTest eval.4
     (eval '1)
     1)

  (defTest eval.5
    (signalsError?
     (eval 'x (theEnv))
     Error :type 'unboundKey :key 'x))

  (defTest eval.6
    (signalsError?
     (eval '1 (theEnv) #t)
     Error :type 'match :operands# -1)))

(defSuite cons

  (defTest cons.1
    (cons (cons 1) (cons 2))
    '((1) . (2)))

  (defTest cons.2
    (cons (cons 1) #null)
    '((1)))

  (defTest cons.3
    (signalsError?
     (cons)
     Error :type 'match :operands# +1))

  (defTest cons.4
    (cons 1)
    '(1))

  (defTest cons.5
    (signalsError?
     (cons 1 2 3)
     Error :type 'match :operands# -1)))

(defSuite car

  (defTest car.1
    (car (list 1 2))
    1)

  (defTest car.2
    (signalsError?
     (car)
     Error :type 'match :operands# +1))

  (defTest car.3
    (signalsError?
     (car 1)
     Error :type 'type :datum 1 :expected 'Cons))

  (defTest car.4
    (signalsError?
     (car 1 2)
     Error :type 'type :expected 'Cons)))

(defSuite cdr

  (defTest cdr.1
    (cdr (list 1 2))
    '(2))

  (defTest cdr.2
    (signalsError?
     (cdr)
     Error :type 'match :operands# +1))

  (defTest cdr.3
    (signalsError?
     (cdr 1)
     Error :type 'type :datum 1 :expected 'Cons))

  (defTest cdr.4
    (signalsError?
     (cdr 1 2)
     Error :type 'type :expected 'Cons)))

(defSuite symbolName

  (defTest symbolName.1
    (eq? "foo" (symbolName 'foo)))

  (defTest symbolName.2
    (signalsError?
      (eq? "foo" (symbolName :foo))
      Error :type 'type :datum :foo :expected 'Symbol))

  (defTest symbolName.3
    (signalsError?
      (symbolName)
      Error :type 'match :operands# +1))

  (defTest symbolName.4
    (signalsError?
      (symbolName 12)
      Error :type 'type :datum 12 :expected 'Symbol)) )

(defSuite keywordName

  (defTest keywordName.1
    (eq? "foo" (keywordName :foo)))

  (defTest keywordName.2
    (signalsError?
      (eq? "foo" (keywordName 'foo))
      Error :type 'type :datum 'foo :expected 'Keyword))

  (defTest keywordName.3
    (signalsError?
      (keywordName)
      Error :type 'match :operands# +1))

  (defTest keywordName.4
    (signalsError?
      (keywordName 12)
      Error :type 'type :datum 12 :expected 'Keyword)) )

(defSuite wrap

  (defTest wrap.1
    ((wrap (vau (x) #ignore x)) (list 1 2 3))
    '(1 2 3))

  (defTest wrap.2
    (signalsError?
     (wrap)
     Error :type 'match :operands# +1))

  (defTest wrap.3
    (signalsError?
     (wrap 33)
     Error :type 'type :datum 33 :expected 'Combinable)))

(defSuite unwrap

  (defTest unwrap.1
    ((unwrap (\ (x) x)) (list 1 2 3))
    '(list 1 2 3))

  (defTest unwrap.2
    (signalsError?
     (unwrap)
     Error :type 'match :operands# +1))

  (defTest unwrap.3
    (signalsError?
     (unwrap 33)
     Error :type 'type :datum 33 :expected 'Apv)))

(defSuite if

  (defTest if.1
    (if #t (eq? 1 1) (eq? 1 2))
    #t)

  (defTest if.2
    (if #f (eq? 1 1) (eq? 1 2))
    #f)

  (defTest if.3
    (signalsError?
     (if)
     Error :type 'match :operands# +2))

  (defTest if.4
    (signalsError?
     (if #t)
     Error :type 'match :operands# +1))

  (defTest if.5
     (if #t #f)
     #f)

  (defTest if.6
    (signalsError?
     (if 1 #f #t)
     Error :type 'type :datum 1 :expected 'Boolean)))

(defSuite cond

  (defTest cond.1
    (cond)
    #inert)

  (defTest cond.2
    (cond (#f 1 2 3))
    #inert)

  (defTest cond.3
    (cond (#f 1 2 3)
          ((eq? 1 1) 4 5 (eq? 1 1)))
    #t)

  (defTest cond.4
     (cond (1 #t))
     #inert))

(defSuite caseType

  (defTest caseType.1
    (signalsError?
     (caseType)
     Error :type 'match :operands# +1))

  (defTest caseType.2
    (caseType (+ 2 2))
    #inert)

  (defTest caseType.3
    (caseType (+ 2 2)
      (Object 1)
      (Integer 2))
    1)

  (defTest caseType.4
    (caseType (+ 2 2)
      (Integer 2)
      (Object 1))
    2)
    
  (defTest caseType.5
    (signalsError?
     (caseType (+ 2 2) (else (simpleError "none clause")))
     SimpleError :type 'simple @getMessage "none clause"))

  (defTest caseType.6
    (signalsError?
     (caseType (+ 2 2)
       (String 2)
       (Boolean 1)
       (else => (\ (v) (typeError v '(or String Boolean)))) )
     Error :type 'type :datum 4 :expected '(or String Boolean))) )

(defSuite not

  (defTest not.1
    (not #t)
    #f)

  (defTest not.2
    (not #f)
    #t)

  (defTest not.3
    (signalsError?
     (not)
     Error :type 'match :operands# +1))

  (defTest not.4
    (signalsError?
     (not 1)
     Error :type 'type :datum 1 :expected 'Boolean)))

(defSuite ==

  (defTest ==.1
    (== 'foo 'foo)
    #t)

  (defTest ==.2
    (== 'foo 'bar)
    #f)

  (defTest ==.3
    (== #t #t)
    #t)

  (defTest ==.4
    (== #f #f)
    #t)

  (defTest ==.5
    (== #inert #inert)
    #t)

  (defTest ==.6
    (== #ignore #ignore)
    #t)

  (defTest ==.7
    (== #null #null)
    #t)

  (defTest ==.8
    (== #null ())
    #t)

  (defTest ==.9
    (== #null '())
    #t)

  (defTest ==.10
    (signalsError?
     (==)
     Error :type 'match :operands# +2))

  (defTest ==.11
    (signalsError?
     (== 11)
     Error :type 'match :operands# +1)))

(defSuite eq?

  (defTest eq?.1
    (eq? 1 1 1)
    #t)

  (defTest eq?.2
    (eq? 1 1 2)
    #f)

  (defTest eq?.3
    (eq? #t #t #t)
    #t)

  (defTest eq?.4
    (eq? #t #t #f)
    #f)

  (defTest eq?.5
    (eq? "foo" "foo" "foo")
    #t)

  (defTest eq?.6
    (eq? (list (list 1)) (list (list 1)))
    #t)

  (defTest eq?.7
    (signalsError?
     (eq?)
     Error :type 'match :operands# +2))

  (defTest eq?.8
    (signalsError?
     (eq? 1)
     Error :type 'match :operands# +1)))

(defSuite /=

  (defTest /=.1
    (/= 1 1 1)
    #f)

  (defTest /=.2
    (/= 1 1 2)
    #f)

  (defTest /=.3
    (/= 1 2 3)
    #t)

  (defTest /=.4
    (/= #t #t #f)
    #f)

  (defTest /=.4b
    (/= #t #f)
    #t)

  (defTest /=.5
    (/= "foo" "foo" "foo")
    #f)

  (defTest /=.5b
    (/= "foo" "bar" "quux")
    #t)

  (defTest /=.6
    (/= (list (list 1)) (list (list 2)))
    #t)

  (defTest /=.7
    (signalsError?
     (/=)
     Error :type 'match :operands# +1))

  (defTest /=.8
    (/= 1)
    #t)

  (defTest /=.9
    (/= 1 2 3 3)
    #f)

  (defTest /=.9b
    (/= 3 1 2 3)
    #f)

  (defTest /=.9c
    (/= 3 1 2 3 4)
    #f)

  (defTest /=.9d
    (/= 1 2 3 3 4)
    #f)

  (defTest /=.9e
    (/= 3 3 4)
    #f)

  (defTest /=.10
    (/= #t "a")
    #t))

(defSuite <

  (defTest <.1
    (< 1 1 1)
    #f)

  (defTest <.2
    (< 1 1 2)
    #f)

  (defTest <.3
    (< -3 -2 -1 0 1 2 3)
    #t)

  (defTest <.4
    (< #t #t #f)
    #f)

  (defTest <.5
    (< "foo" "foo" "foo")
    #f)

  (defTest <.6
    (signalsError?
     (< (list (list 1)) (list (list 2)))
     Error))

  (defTest <.7
    (signalsError?
     (<)
     Error :type 'match :operands# +2))

  (defTest <.8
    (signalsError?
     (< 1)
     Error :type 'match :operands# +1))

  (defTest <.9
    (< 1 2 3 3)
    #f)

  (defTest <.different-types
    (signalsError?
     (< 1 2 3 "foo")
     Error :type 'java :member '%< :args '(3 "foo"))) )

(defSuite >

  (defTest >.1
    (> 1 1 1)
    #f)

  (defTest >.2
    (> 2 1 1)
    #f)

  (defTest >.3
    (> 3 2 1 0 -1 -2 -3)
    #t)

  (defTest >.4
    (> #t #t #f)
    #f)

  (defTest >.5
    (> "foo" "foo" "foo")
    #f)

  (defTest >.6
    (signalsError?
     (> (list (list 1)) (list (list 2)))
     Error))

  (defTest >.7
    (signalsError?
     (>)
     Error :type 'match :operands# +2))

  (defTest >.8
    (signalsError?
     (> 1)
     Error :type 'match :operands# +1))

  (defTest >.9
    (> 3 2 1 1)
    #f)

  (defTest >.different-types
    (signalsError?
     (> 3 2 1 "foo")
     Error :type 'java :member '%> :args '(1 "foo"))))

(defSuite <=

  (defTest <=.1
    (<= 1 1 1)
    #t)

  (defTest <=.2
    (<= 1 1 2)
    #t)

  (defTest <=.3
    (<= -3 -2 -1 0 1 2 3)
    #t)

  (defTest <=.4
    (<= #t #t #f)
    #f)

  (defTest <=.5
     (<= "foo" "foo" "foo")
     #t)

  (defTest <=.6
    (signalsError?
     (<= (list (list 1)) (list (list 2)))
     Error))

  (defTest <=.7
    (signalsError?
     (<=)
     Error :type 'match :operands# +2))

  (defTest <=.8
    (signalsError?
     (<= 1)
     Error :type 'match :operands# +1))

  (defTest <=.9
    (<= 1 2 3 3)
    #t)

  (defTest <=.10
    (<= 1 2 3 3 -1)
    #f)

  (defTest <=.different-types
    (signalsError?
     (<= 1 1 3 "foo")
     Error :type 'java :member '%<= :args '(3 "foo"))))

(defSuite >=

  (defTest >=.1
    (>= 1 1 1)
    #t)

  (defTest >=.2
    (>= 2 1 1)
    #t)

  (defTest >=.3
    (>= 3 2 1 1 0 0 -1 -2 -3 -3)
    #t)

  (defTest >=.4
    (>= #t #t #f)
    #t)

  (defTest >=.5
    (>= "foo" "foo" "foo")
    #t)

  (defTest >=.6
    (signalsError?
     (>= (list (list 1)) (list (list 2)))
     Error))

  (defTest >=.7
    (signalsError?
     (>=)
     Error :type 'match :operands# +2))

  (defTest >=.8
    (signalsError?
     (>= 1)
     Error :type 'match :operands# +1))

  (defTest >=.9
    (>= 3 3 2 1)
    #t)

  (defTest >=.10
    (>= 3 3 2 100)
    #f)

  (defTest >=.different-types
    (signalsError?
     (>= 3 3 2 "foo")
     Error :type 'java :member '%>= :args '(2 "foo"))))

(defSuite +

  (defTest +.1
    (+)
    0)

  (defTest +.2
    (+ 10)
    10)

  (defTest +.3
    (+ 10 10 10)
    30))

(defSuite -

  (defTest -.1
    (signalsError?
     (-)
     Error :type 'match :operands# +1))

  (defTest -.2
    (- 1)
    -1)

  (defTest -.3
    (- -1)
    1)

  (defTest -.4
    (- 100 10 1)
    89))

(defSuite *

  (defTest *.1
    (*)
    1)

  (defTest *.2
    (* 10)
    10)

  (defTest *.3
    (* 10 -10 10)
    -1000))

(defSuite /

  (defTest /.1
    (signalsError?
     (/)
     Error :type 'match :operands# +1))

  (defTest /.2
    (/ 10d)
    0.1)

  (defTest /.3
    (/ 100 10 2)
    5)

  (defTest /.4
    (/ -100 10 2)
    -5))

(defSuite type?

  (defTest type?.1
    (&&
     (type? #t Boolean)
     (type? #f Boolean)
     (type? 12 Integer)
     (type? "foo" String)
     (type? #null Null)
     (type? Object Class)))

  (defTest type?.2
    (&&
     (type? Condition Class)
     (type? Condition Object)))

  (defTest type?.3
    (signalsError?
     (type?)
     Error :type 'match :operands# +2))

  (defTest type?.3
    (signalsError?
     (type? "foo")
     Error :type 'match :operands# +1)))

(defSuite intern

  (defTest intern.1
    (== 'foo (intern "foo")))

  (defTest intern.2
    (signalsError?
     (intern 12)
     Error :type 'type :datum 12 :expected 'String))

  (defTest intern.3
    (signalsError?
     (intern)
     Error :type 'match :operands# +1)))

(defSuite apply

  (defTest apply.1
    (apply list ())
    '())

  (defTest apply.2
    (apply list '(1))
    '(1))

  (defTest apply.3
    (signalsError?
     (apply)
     Error :type 'match :operands# +2))

  (defTest apply.4
    (signalsError?
     (apply list)
     Error :type 'match :operands# +1))

  (defTest apply.5
    (signalsError?
     (apply 12 '())
     Error :type 'type :datum 12 :expected 'Combinable)))

(defSuite findClass

  (defTest findClass.1
    (== (findClass 'String (theEnv))
        (classOf "foo")))

  (defTest findClass.2a
    (signalsError?
     (findClass)
     Error :type 'match :operands# +2))

  (defTest findClass.2b
    (signalsError?
     (findClass 'foo)
     Error :type 'match :operands# +1))

  (defTest findClass.3
    (signalsError?
     (findClass "string" (theEnv))
     Error :type 'type :datum "string" :expected 'Symbol))

  (defTest findClass.4
    (signalsError?
     (findClass 'does-not-exist (theEnv))
     Error :type 'unboundKey :key 'does-not-exist)))

(defSuite newEnv

  (defTest newEnv.1
    (let ((env (newEnv)))
      (bound? 'def env))
    #f)

  (defTest newEnv.2
    (let* ((env (newEnv (theEnv)))
           (child (newEnv env)))
      (assert#t (not (bound? 'x env)))
      (assert#t (not (bound? 'x child)))
      (eval '(def x 1) env)
      (assert#t (bound? 'x env))
      (assert#t (bound? 'x child))
      (assert#t (eq? 1 (eval 'x env)))
      (assert#t (eq? 1 (eval 'x child))))
    #inert)

  (defTest newEnv.3
    (signalsError?
     (newEnv 12)
     Error :type 'type :datum (12) :expected '(or () (2 (or () Env) Obj) (1 oo (or () Env) (or Symbol Keyword String) Any)))))

(defSuite cxxr

  (defTest caar.1
    (caar '((1 2) (3 4) (5 6)))
    1)

  (defTest caar.2
    (signalsError?
     (caar)
     Error :type 'match :operands# +1))

  (defTest caar.3
    (signalsError?
     (caar 1)
     Error :type 'type :datum 1 :expected 'Cons))

  (defTest cadr.1
    (cadr '((1 2) (3 4) (5 6)))
    '(3 4))

  (defTest cadr.2
    (signalsError?
     (cadr)
     Error :type 'match :operands# +1))

  (defTest cadr.3
    (signalsError?
     (cadr 1)
     Error :type 'type :datum 1 :expected 'Cons))

  (defTest cddr.1
    (cddr '((1 2) (3 4) (5 6)))
    '((5 6)))

  (defTest cddr.2
    (signalsError?
     (cddr)
     Error :type 'match :operands# +1))

  (defTest cddr.3
    (signalsError?
     (cddr 1)
     Error :type 'type :datum 1 :expected 'Cons))

  (defTest cdar.1
    (cdar '((1 2) (3 4) (5 6)))
    '(2))

  (defTest cdar.2
    (signalsError?
     (cdar)
     Error :type 'match :operands# +1))

  (defTest cdar.3
    (signalsError?
     (cdar 1)
     Error :type 'type :datum 1 :expected 'Cons))

(defSuite when

  (defTest when.1
    (when #t)
    #inert)

  (defTest when.2
    (when #f)
    #inert)

  (defTest when.3
    (when #t 1 2 (eq? 1 1))
    #t)

  (defTest when.4
    (when #f 1 2 3)
    #inert)

  (defTest when.5
    (signalsError?
     (when)
     Error :type 'match :operands# +1))

  (defTest when.6
    (signalsError?
     (when 1)
     Error :type 'type :datum 1 :expected 'Boolean))))

(defSuite unless

  (defTest unless.1
    (unless #t)
    #inert)

  (defTest unless.2
    (unless #f)
    #inert)

  (defTest unless.3
    (unless #f 1 2 (eq? 1 1))
    #t)

  (defTest unless.4
    (unless #t 1 2 3)
    #inert)

  (defTest unless.5
    (signalsError?
     (unless)
     Error :type 'match :operands# +1))

  (defTest unless.6
    (signalsError?
     (unless 1)
     Error :type 'type :datum 1 :expected 'Boolean)))

(defSuite null?

  (defTest null?.1
    (null? #null)
    #t)

  (defTest null?.2
    (null? '(1))
    #f)

  (defTest null?.3
    (signalsError?
     (null?)
     Error :type 'match :operands# +1))

  (defTest null?.4
    (null? 1)
    #f))

(defSuite cons?

  (defTest cons?.1
    (cons? #null)
    #f)

  (defTest cons?.2
    (cons? '(1))
    #t)

  (defTest cons?.3
    (signalsError?
     (cons?)
     Error :type 'match :operands# +1))

  (defTest cons?.4
    (cons? 1)
    #f))

(defSuite idf

  (defTest idf.1
    (idf #null)
    #null)

  (defTest idf.2
    (idf '(1))
    '(1))

  (defTest idf.3
    (signalsError?
     (idf)
     Error :type 'match :operands# +1))

  (defTest idf.4
    (idf (+ 1 1))
    2))

(defSuite compose

  (defTest compose.1
    (signalsError?
     (compose)
     Error :type 'match :operands# +2))

  (defTest compose.2
    (signalsError?
     (compose (\ ()))
     Error :type 'match :operands# +1))

  (defTest compose.3
    (type? (compose (\ ()) (\ ())) Apv))

  (defTest compose.4
    ((compose idf idf) 12)
    12)

  (defTest compose.5
    ((compose length list) 'a 'b 'c)
    3)

  (defTest compose.6
    ((compose car list) 'a 'b 'c)
    'a))

(defSuite map

  (defTest map.1
    (map intern ())
    ())

  (defTest map.2
    (map intern '("foo" "bar"))
    '(foo bar))

  (defTest map.3
    (signalsError?
     (map)
     Error :type 'match :operands# +2))

  (defTest map.4
    (signalsError?
     (map intern)
     Error :type 'match :operands# +1))

  (defTest map.5
    (signalsError?
     (map intern 12)
     Error :type 'type :datum 12 :expected 'Cons))

  (defTest map.6
  	(if (aQuote) #t
      (signalsError?
        (map 12 '(1))
        Error :type 'type :datum 12 :expected 'Combinable))))

(defSuite reduce

  (defTest reduce.1
    (reduce %* 10 (list 1 2 3))
    60)

  (defTest reduce.2
    (reduce %* 10 (list))
    10)

  (defTest reduce.3
    (signalsError?
     (reduce)
     Error :type 'match :operands# +3))

  (defTest reduce.4
    (signalsError?
     (reduce %*)
     Error :type 'match :operands# +2))

  (defTest reduce.5
    (signalsError?
     (reduce %* (list))
     Error :type 'match :operands# +1))

  (defTest reduce.ansi.3
    (reduce cons 'z '(a b c d e f) )
    '((((((z . a) . b) . c) . d) . e) . f))

  (defTest reduce.clhs.1
    (reduce list 'foo '(1 2 3 4))
    '((((foo 1) 2) 3) 4)))

(defSuite forEach

  (defTest forEach.1
    (signalsError?
     (forEach)
     Error :type 'match :operands# +2))

  (defTest forEach.2
    (signalsError?
     (forEach (\ (x) x))
     Error :type 'match :operands# +1))

  (defTest forEach.3
    (if (aQuote) #t
      (signalsError?
        (forEach "foo" '(1 2 3))
        Error :type 'type :datum "foo" :expected 'Combinable)))

  (defTest forEach.4
    (signalsError?
     (forEach (\ (x) x) "foo")
     Error :type 'type :datum "foo" :expected 'Cons))

  (defTest forEach.5
    (let ((ct 0))
      (def env (theEnv))
      (forEach (\ (x) (set env ct (+ ct x)))
            '(1 2 3 4))
      ct)
    10)

  (defTest forEach.6
    (let ((list (list 1 2 3)))
      (forEach (\ (x)) list))
    (list 1 2 3)))

(defSuite maplist

  (defTest maplist.1
    (map (\ ()) ())
    ())

  (defTest maplist.2
    (maplist list '("foo" "bar"))
    '("foo" "bar"))

  (defTest maplist.3
    (signalsError?
     (maplist)
     Error :type 'match :operands# +2))

  (defTest maplist.4
    (signalsError?
     (maplist list)
     Error :type 'match :operands# +1))

  (defTest maplist.5
    (signalsError?
     (maplist list 12)
     Error :type 'type :datum 12 :expected 'Cons))

  (defTest maplist.6
  	(if (aQuote) #t
      (signalsError?
        (maplist 12 '(1))
        Error :type 'type :datum 12 :expected 'Combinable)))

  (defTest maplist.7
    (maplist (\ (x) (if (type? x Integer) (list x) #null))
            '(a 1 b c 3 4 d 5))
    '(1 3 4 5))

  (defTest maplist.8
    (maplist (\ (x) (list (+ x 10) 'x)) '(1 2 3 4))
    '(11 x 12 x 13 x 14 x)))

(defSuite doList

  (defTest doList.1
    (signalsError?
     (doList)
     Error :type 'match :operands# +1))

  (defTest doList.2
    (signalsError?
     (doList ())
     Error :type 'match :operands# +2))

  (defTest doList.3
    (signalsError?
     (doList (x))
     Error :type 'match :operands# +1))

  (defTest doList.4
    (doList (x '(1 2 3)))
    #inert)

  (defTest doList.5
    (signalsError?
     (doList (x "not-a-list"))
     Error :type 'type :datum "not-a-list" :expected 'Cons))

  (defTest doList.6
    (signalsError?
     (doList ("not-a-symbol" '(1 2 3)))
    Error :type 'type :datum '("not-a-symbol") :expected '(or () #ignore Symbol)))

  (defTest doList.7
    (let ((ct 0))
      (def env (theEnv))
      (assert#t (eq? #inert (doList (x '(1 2 3 4))
                         'bla
                         (set env ct (+ ct x)))))
      ct)
    10)

  (defTest doList.8
    (let ((ct 0))
      (def env (theEnv))
      (doList (x '(1 2 3 4) (+ ct 100))
        'bla
        (set env ct (+ ct x))))
    110)

  (defTest doList.9
    (doList (x '(1 2 3) x))
    '()))

(defSuite nth

  (defTest nth.1
    (signalsError?
     (nth)
     Error :type 'match :operands# +2))

  (defTest nth.2
    (signalsError?
     (nth '())
     Error :type 'type :datum () :expected '(and Integer (>= 0))))

  (defTest nth.3
    (signalsError?
     (nth #t '(1 2))
     Error :type 'type :datum #t :expected '(and Integer (>= 0))))

  (defTest nth.3a
    (signalsError?
     (nth 1 '())
     Error :type 'outOfBounds))

  (defTest nth.4
    (signalsError?
     (nth 0 "foo")
     Error :type 'type :datum "foo" :expected '(or () Cons)))

  (defTest nth.5
    (nth 0 '(1 2))
    1)

  (defTest nth.6
    (nth 1 '(1 2))
    2)

  (defTest nth.7
    (signalsError?
     (nth 2 '(1 2))
     Error :type 'outOfBounds)))

(defSuite reverse

  (defTest reverse.1
    (signalsError?
     (reverse)
     Error :type 'match :operands# +1))

  (defTest reverse.2
    (signalsError?
     (reverse "foo")
     Error :type 'type :datum "foo" :expected '(or () List)))

  (defTest reverse.3
    (signalsError?
     (reverse "foo" "bar")
     Error :type 'type :datum "foo" :expected '(or () List)))

  (defTest reverse.4
    (reverse ())
    ())

  (defTest reverse.5
    (reverse '(1))
    '(1))

  (defTest reverse.6
    (reverse '(1 2 3))
    '(3 2 1)))

(defSuite append

  (defTest append.1
    (signalsError?
     (append)
     Error :type 'match :operands# +2))

  (defTest append.2
    (signalsError?
     (append '())
     Error :type 'match :operands# +1))

  (defTest append.3
    (signalsError?
     (append 1 '())
     Error :type 'type :datum 1 :expected '(or () List)))

  (defTest append.4
    (append '() '())
    '())

  (defTest append.5
    (append '() 12)
    12)

  (defTest append.6
    (append '(1) 12)
    '(1 . 12))

  (defTest append.7
    (append '(1 2) 12)
    '(1 2 . 12))

  (defTest append.8
    (append '(1 2) '(3 4))
    '(1 2 3 4)))

(defSuite length

  (defTest length.1
    (signalsError?
     (length)
     Error))

  (defTest length.2
    (signalsError?
     (length #f)
     Error)))

(defSuite len

  (defTest len.1
    (length '())
    0)

  (defTest len.2
    (length '(1 2 3))
    3))

(defSuite nthCdr

  (defTest nthCdr.1
    (signalsError?
     (nthCdr)
     Error :type 'match :operands# +2))

  (defTest nthCdr.2
    (signalsError?
     (nthCdr 1)
     Error :type 'match :operands# +1))

  (defTest nthCdr.3
    (signalsError?
     (nthCdr "foo" '())
     Error :type 'type :datum "foo" :expected '(and Integer (>= 0))))

  (defTest nthCdr.4
    (signalsError?
     (nthCdr 12 "foo")
     Error :type 'type :datum "foo" :expected '(or () Cons)))

  (defTest nthCdr.5
    (nthCdr 0 '())
    '())

  (defTest nthCdr.6
    (signalsError?
     (nthCdr 1 '())
     Error :type 'outOfBounds))

  (defTest nthCdr.7
    (signalsError?
     (nthCdr 2 '(1))
     Error :type 'outOfBounds))

  (defTest nthCdr.8
    (signalsError?
     (nthCdr 3 '(1))
     Error :type 'outOfBounds))

  (defTest nthCdr.9
    (nthCdr 0 '(1 2 3))
    '(1 2 3))

  (defTest nthCdr.10
    (nthCdr 1 '(1 2 3))
    '(2 3))

  (defTest nthCdr.11
    (nthCdr 2 '(1 2 3))
    '(3))

  (defTest nthCdr.12
    (nthCdr 3 '(1 2 3))
    '())

  (defTest nthCdr.13
    (signalsError?
     (nthCdr 4 '(1 2 3))
     Error :type 'outOfBounds)))

(defSuite subSeq

  (defTest subSeq.1
    (signalsError?
     (subSeq)
     Error))

  (defTest subSeq.2
    (signalsError?
     (subSeq '())
     Error :type 'match :operands# +1))

  (defTest subSeq.3
    (signalsError?
     (subSeq 12 1 2)
     Error :type 'unboundExecutable :class Integer :executable 'subSeq)))

(defSuite listSubseq

  (defTest listSubseq.4
    (signalsError?
     (subSeq '() "a" 2)
     Error :type 'type :datum "a" :expected '(and Integer (>= 0))))

  (defTest listSubseq.5
    (signalsError?
     (subSeq '() 1 "b")
     Error :type 'type :datum '("b") :expected '(or () (1 (and Integer (>= 0))))))

  (defTest listSubseq.6
    (signalsError?
     (subSeq '() 1)
     Error :type 'outOfBounds))

  (defTest listSubseq.7
    (signalsError?
     (subSeq '() 0 1)
     Error :type 'outOfBounds))

  (defTest listSubseq.8
    (subSeq '() 0)
    '())

  (defTest listSubseq.9
    (subSeq '() 0 0)
    '())

  (defTest listSubseq.10
    (subSeq '() 0)
    '())

  (defTest listSubseq.11
    (subSeq '(1 2 3) 0)
    '(1 2 3))

  (defTest listSubseq.12
    (subSeq '(1 2 3) 0)
    '(1 2 3))

  (defTest listSubseq.13
    (subSeq '(0 1 2 3 4 5) 2)
    '(2 3 4 5))

  (defTest listSubseq.14
    (subSeq '(0 1 2 3 4 5) 3 5)
    '(3 4))

  (defTest listSubseq.15
    (subSeq '(0 1 2 3 4 5) 0 6)
    '(0 1 2 3 4 5))

  (defTest listSubseq.16
    (signalsError?
     (subSeq '(0 1 2 3 4 5) 0 7)
     Error :type 'outOfBounds))

  (defTest listSubseq.17
    (signalsError?
     (subSeq '(0 1 2 3 4 5) 7 10)
     Error :type 'outOfBounds))

  (defTest listSubseq.18
    (subSeq '(0 1 2 3 4 5) 6)
    '()))

(defSuite stringSubseq

  (defTest stringSubseq.2
    (signalsError?
     (subSeq "")
     Error :type 'match :operands# +1))

  (defTest stringSubseq.4
    (signalsError?
     (subSeq "" "a" 2)
     Error :type 'type :datum "a" :expected '(and Integer (>= 0))))

  (defTest stringSubseq.5
    (signalsError?
     (subSeq "foo" 1 "b")
     Error :type 'type :datum '("b") :expected '(or () (1 (and Integer (>= 0))))))

  (defTest stringSubseq.6
    (signalsError?
     (subSeq "" 1)
     Error :type 'outOfBounds))

  (defTest stringSubseq.7
    (signalsError?
     (subSeq "" 0 1)
     Error :type 'outOfBounds))

  (defTest stringSubseq.8
    (subSeq "" 0)
    "")

  (defTest stringSubseq.9
    (subSeq "" 0 0)
    "")

  (defTest stringSubseq.10
    (subSeq "" 0)
    "")

  (defTest stringSubseq.10.1
    (signalsError?
     (subSeq "" 1)
     Error :type 'outOfBounds))

  (defTest stringSubseq.11
    (subSeq "123" 0)
    "123")

  (defTest stringSubseq.12
    (subSeq "123" 0)
    "123")

  (defTest stringSubseq.13
    (subSeq "012345" 2)
    "2345")

  (defTest stringSubseq.14
    (subSeq "012345" 3 5)
    "34")

  (defTest stringSubseq.15
    (subSeq "012345" 0 6)
    "012345")

  (defTest stringSubseq.16
    (signalsError?
     (subSeq "012345" 0 7)
     Error :type 'outOfBounds))

  (defTest stringSubseq.17
    (signalsError?
     (subSeq "012345" 7 10)
     Error :type 'outOfBounds))

  (defTest stringSubseq.18
    (subSeq "012345" 6)
     ""))

(defSuite elt

  (defTest elt.1
    (signalsError?
     (elt)
     Error))

  (defTest elt.2
    (signalsError?
     (elt #t 0)
     Error)))

(defSuite list-elt

  (defTest list-elt.2
    (signalsError?
     (elt '())
     Error :type 'unboundExecutable :class () :executable 'elt))

  (defTest list-elt.3a
    (signalsError?
     (elt '() 1)
     Error :type 'unboundExecutable :class () :executable 'elt))

  (defTest list-elt.5
    (elt '(1 2) 0)
    1)

  (defTest list-elt.6
    (elt '(1 2) 1)
    2)

  (defTest list-elt.7
    (signalsError?
     (elt '(1 2) 2)
     Error :type 'outOfBounds)))

(defSuite member

  (defTest member.1
    (signalsError?
     (member)
     Error :type 'match :operands# +2))

  (defTest member.2
    (signalsError?
     (member 'a)
     Error :type 'match :operands# +1))

  (defTest member.3
    (member 'a '() :cmp ==)
    #null)

  (defTest member.3a
    (member 'a '())
    #null)

  (defTest member.4
    (member 'b '(a) :cmp ==)
    #null)

  (defTest member.5
    (member 'b '(a b) :cmp ==)
    '(b))

  (defTest member.5b
    (member  'x '(a b) :cmp ==)
    #null)

  (defTest member.6
    (member 'b '(a b c) :cmp ==)
    '(b c))

  (defTest member.6a
    (member 'b '(a b c))
    '(b c))

  (defTest member.7
    (member "b" '("a" "b" "c") :cmp ==)
    #null)

  (defTest member.7a
    (member "b" '("a" "b" "c"))
    #null)

  (defTest member.8
    (member "b" '("a" "b" "c") :cmp eq?)
    '("b" "c"))

  (defTest member.9
    (member 'b '((2 a) (1 b) (3 c)) :key cadr)
    '((1 b) (3 c)))

  (defTest member.9a
    (member "b" '((2 "a") (1 "b") (3 "c")) :key cadr)
    #null)

  (defTest member.9b
    (member "b" '((2 "a") (1 "b") (3 "c")) :key cadr :cmp eq?)
    '((1 "b") (3 "c"))))

(defSuite remove

  (defTest remove.1
    (signalsError?
     (remove)
     Error :type 'match :operands# +2))

  (defTest remove.2
    (signalsError?
     (remove (\ (item) #t))
     Error :type 'match :operands# +1))

  (defTest remove.3
    (signalsError?
     (remove (\ (item) #t) 12)
     Error :type 'type :datum 12 :expected 'Cons))

  (defTest remove.4
    (signalsError?
     (remove 1 '(1 2))
     Error :type 'type :datum 1 :expected 'Combinable))

  (defTest remove.5
    (remove (\ (item) (eq? 1 item)) '(1 2 3 1 2 3))
    '(2 3 2 3))

  (defTest remove.6
    (remove (\ (item) (eq? 1 item)) '())
    '()))

(defSuite optValue

  (defTest optValue.1
    (optValue :foo '(:foo 1 :bar 2))
    (some 1))

  (defTest optValue.2
    (optValue :bar '(:foo 1 :bar 2))
    (some 2))

  (defTest optValue.3
    (optValue :bar '())
    #null)

  (defTest optValue.4
    (optValue :quux '(:foo 1 :bar 2))
    #null)

  (defTest optValue.5
    (signalsError?
     (optValue)
     Error :type 'match :operands# +2))

  (defTest optValue.6
    (signalsError?
     (optValue '())
     Error :type 'match :operands# +1))

  (defTest optValue.7
    (optValue :quux 12)
    #null))

(defSuite and

  (defTest and.1
    (&&)
    #t)

  (defTest and.2
    (&& #t #f)
    #f)

  (defTest and.3
    (&& #t (eq? 1 1) #t)
    #t)

  (defTest and.4
    (signalsError?
     (&& #t #t 1)
     Error :type 'type :datum 1 :expected 'Boolean))

  (defTest and.5
    (begin
      (def x 1)
      (def env (theEnv))
      (&& #f (set env x 2))
      x)
    1))

(defSuite or

  (defTest ||.1
    (||)
    #f)

  (defTest or.2
    (|| #t #f)
    #t)

  (defTest or.3
    (|| #t #t #t)
    #t)

  (defTest or.4
    (|| #f #f #f)
    #f)

  (defTest or.5
    (signalsError?
     (|| #f #f 1)
     Error :type 'type :datum 1 :expected 'Boolean))

  (defTest or.6
    (begin
      (def x 1)
      (def env (theEnv))
      (|| #t (set env x 2))
      x)
    1))

(defSuite obj

  (defTest obj.1
    (begin
      (def obj (new Error :type 'type :datum 1 :expected 'String))
      (assert#t (eq? (getValue obj 'datum) 1))
      (assert#t (eq? (getValue obj :datum) 1))
      (assert#t (eq? (getValue obj 'expected) 'String))
      (assert#t (eq? (getValue obj :expected) 'String)))
    #inert)

  (defTest obj.2
    (signalsError?
     (new)
     Error :type 'match :operands# 1))

  (defTest obj.3
    (signalsError?
     (new 3)
     Error :type 'type :datum '(3) :expected '(or (1 2 Box) (1 oo Obj (or (1 Env) ((or Symbol Keyword String) Any) (1 oo Throwable (or Symbol Keyword String) Any) (1 oo String (or ((or Symbol Keyword String) Any) (1 oo Throwable (or Symbol Keyword String) Any)))))) ))

  (defTest obj.4
    (signalsError?
     (new Object)
     Error :type 'type :datum '(&java.lang.Object) :expected '(or (1 2 Box) (1 oo Obj (or (1 Env) ((or Symbol Keyword String) Any) (1 oo Throwable (or Symbol Keyword String) Any) (1 oo String (or ((or Symbol Keyword String) Any) (1 oo Throwable (or Symbol Keyword String) Any)))))) ))

  (defTest obj.5
    (signalsError?
     (new Obj :x)
     Error :type 'type :datum '(&Wat.Vm$Obj :x) :expected '(or (1 2 Box) (1 oo Obj (or (1 Env) ((or Symbol Keyword String) Any) (1 oo Throwable (or Symbol Keyword String) Any) (1 oo String (or ((or Symbol Keyword String) Any) (1 oo Throwable (or Symbol Keyword String) Any)))))) )) )

(defSuite keys
  (defTest keys.1
    (begin
      (def obj (new Obj))
      (assert#t (not (keyBound? obj 'x)))
      (assert#t (not (keyBound? obj :x)))
      (assert#t
        (signalsError? (getValue obj 'x)
          Error :type 'unboundKey :key "x" :objEnv obj))
      (assert#t
        (signalsError? (getValue obj :x)
          Error :type 'unboundKey :key "x" :objEnv obj))
      (setValue obj 'x 1)
      (assert#t (keyBound? obj 'x))
      (assert#t (keyBound? obj :x))
      (assert#t (eq? (getValue obj 'x) 1))
      (assert#t (eq? (getValue obj :x) 1))
      (setValue obj 'x 2)
      (assert#t (eq? (getValue obj 'x) 2))
      (assert#t (eq? (getValue obj :x) 2)))
    #inert)

  (defTest getValue.1
    (signalsError?
     (getValue "foo" 'x)
     Error :type 'type :datum "foo" :expected 'ObjEnv))

  (defTest getValue.1a
    (signalsError?
     (getValue (new Obj) "x")
     Error :type 'type :datum "x" :expected 'Intern))

  (defTest getValue.2
    (signalsError?
     (getValue (new Obj))
     Error :type 'match :operands# +1))

  (defTest getValue.3
    (signalsError?
     (getValue)
     Error :type 'match :operands# +2))

  (defTest setValue.1
    (signalsError?
     (setValue "foo" 'x 1)
     Error :type 'type :datum "foo" :expected 'ObjEnv))

  (defTest setValue.1a
    (signalsError?
     (setValue (new Obj) "x" 1)
     Error :type 'type :datum "x" :expected 'Intern))

  (defTest setValue.2
    (signalsError?
     (setValue (new Obj))
     Error :type 'match :operands# +2))

  (defTest setValue.3
    (signalsError?
     (setValue (new Obj) 'x)
     Error :type 'match :operands# +1))

  (defTest keyBound?.1
    (signalsError?
     (keyBound? "foo" 'x)
     Error :type 'type :datum "foo" :expected 'ObjEnv))

  (defTest keyBound?.1a
    (signalsError?
     (keyBound? (new Obj) "x")
     Error :type 'type :datum "x" :expected 'Intern))

  (defTest keyBound?.2
    (signalsError?
     (keyBound?)
     Error :type 'match :operands# +2))

  (defTest keyBound?.3
    (signalsError?
     (keyBound? (new Obj))
     Error :type 'match :operands# +1)))

(defSuite let

  (defTest let.1
    (let ((x 1))
      x)
    1)

  (defTest let.2
    (let ((x 1))
      (let ((x 2))
        x))
    2)

  (defTest let.3
    (let ((x 1))
      (let ((x 2)))
      x)
    1)

  (defTest let.4
    (let ((x 1))
      (let ((x 2)
            (it x))
        it))
    1)

  (defTest let.5
    (let ())
    #inert)

  (defTest let.6
    (signalsError?
     (let)
     Error :type 'match :operands# +1))

  (defTest let.7
    (signalsError?
     (let #t)
     Error :type 'type :datum #t :expected 'Cons))

  (defTest let.8
    (signalsError?
     (let ((#t 1)))
     Error :type 'type :datum '(#t) :expected '(or () #ignore Symbol))))

(defSuite let*

  (defTest let*.1
    (let* ((x 1)
           (y x)
           (z y))
      (list x y z))
    '(1 1 1))

  (defTest let*.2
    (let* ())
    #inert)

  (defTest let*.3
    (signalsError?
     (let*)
     Error :type 'match :operands# +1))

  (defTest let*.4
    (signalsError?
     (let* #t)
     Error :type 'type :datum #t :expected 'Cons))

  (defTest let*.5
    (signalsError?
     (let* ((#t 1)))
     Error :type 'type :datum '(#t) :expected '(or () #ignore Symbol))))

(defSuite let\

  (defTest let\.1
    (let\ ((f () 1))
          (let\ ((f () 2)
                 (g () (f)))
                (g)))
    1)

  (defTest let\.2
    (let\ ((foo ()))
          (foo))
    #inert)

  (defTest let\.2
    (let\ ((foo (x) x))
          (foo 1))
    1)

  (defTest let\.3
    (signalsError?
     (let\ )
     Error :type 'match :operands# +1))

  (defTest let\.4
    (signalsError?
     (let\ #t)
     Error :type 'type :datum #t :expected 'Cons))

  (defTest let\.5
    (let\ ())
    #inert))

(defSuite labels

  (defTest labels.1
    (labels ((f () 1))
            (labels ((f () 2)
                     (g () (f)))
                    (g)))
    2)

  (defTest labels.2
    (labels ((foo ()))
            (foo))
    #inert)

  (defTest labels.3
    (labels ((foo (x) x))
            (foo 1))
    1)

  (defTest labels.4
    (signalsError?
     (labels)
     Error :type 'match :operands# +1))

  (defTest labels.5
    (signalsError?
      (labels #t)
      Error :type 'type :datum #t :expected 'Cons))

  (defTest labels.6
    (signalsError?
      (labels ())
      Error :type 'type :datum () :expected '(or Symbol Cons))))

(defSuite letLoop

  (defTest letLoop.1
    (signalsError?
     (letLoop)
     Error :type 'match))

  (defTest letLoop.2
    (signalsError?
     (letLoop -name-)
     Error :type 'match :operands# +1))

  (defTest letLoop.3
    (letLoop -name- ())
    #inert)

  (defTest letLoop.4
    (letLoop -sum- ((as (list 1 2 3))
                     (bs (list 4 5 6)))
      (if (null? as)
          #null
          (cons (+ (car as) (car bs))
                (-sum- (cdr as) (cdr bs)))))
    '(5 7 9)))

(defSuite while

  (defTest while.1
    (signalsError?
     (while)
     Error :type 'match :operands# +1))

  (defTest while.2
    (while (eq? 1 2))
    #inert)

  (defTest while.3
    (if (> (typeT) 0) #t
      (signalsError?
        (while 12)
        Error :type 'type :datum 12 :expected 'Boolean)))

  (defTest while.4
    (begin
      (def x 0)
      (def y 0)
      (def env (theEnv))
      (while (< x 5)
        (set env x (+ x 1))
        (set env y (+ y 1)))
      (list x y))
    '(5 5)))

(defSuite until

  (defTest until.1
    (signalsError?
     (until)
     Error :type 'match :operands# +1))

  (defTest until.2
    (until (/= 1 2))
    #inert)

  (defTest until.3
    (if (> (typeT) 0) #t
      (signalsError?
        (until 12)
        Error :type 'type :datum 12 :expected 'Boolean)))

  (defTest until.4
    (begin
      (def x 0)
      (def y 0)
      (def env (theEnv))
      (until (> x 4)
        (set env x (+ x 1))
        (set env y (+ y 1)))
      (list x y))
    '(5 5)))

(defSuite doTimes

  (defTest doTimes.1
    (doTimes (temp-one 10 temp-one))
    10)

  (defTest doTimes.2
    (begin
      (def temp-two 0)
      (def env (theEnv))
      (doTimes (temp-one 10 #t) (set env temp-two (+ temp-two 1)))
      temp-two)
    10)

  (defTest doTimes.3
    (signalsError?
     (doTimes)
     Error :type 'match :operands# +1))

  (defTest doTimes.4
    (signalsError?
     (doTimes (x))
     Error :type 'match :operands# +1))

  (defTest doTimes.5
    (signalsError?
      (doTimes (x 0))
      Error :type 'type :datum 0 :expected '(and Integer (> 0)) ))

  (defTest doTimes.6
    (doTimes (x 1))
    #inert)

  (defTest doTimes.7
    (doTimes (x 1) 1 2 3)
    3)

  (defTest doTimes.8
    (signalsError?
     (doTimes (x "foo") 1 2 3)
     Error :type 'type :datum "foo" :expected '(and Integer (> 0)) ))

  (defTest doTimes.9
    (begin
      (def x 0)
      (def y 0)
      (def env (theEnv))
      (doTimes (i 5 (list x y))
        (set env x (+ x 1))
        (set env y (+ y 1))))
    '(5 5)))

(defSuite opt

  (defTest opt.1
    (optDft '())
    #null)

  (defTest opt.2
    (optDft '() "default")
    "default")

  (defTest opt.3
    (optDft (some 1))
    1)

  (defTest opt.4
    (optDft (some 1) "default")
    1)

  (defTest opt.5
    (signalsError?
     (optDft)
     Error :type 'match :operands# +1))

  (defTest opt.6
    (signalsError?
     (optDft 1)
     Error :type 'type :datum 1 :expected '(or () List) ))

  (defTest opt.lazy.1
    (optDft (some 1) (error (makeSimpleError "foo")))
    1)

  (defTest opt.lazy.2
    (signalsError?
     (optDft #null (error (makeSimpleError "foo")))
     SimpleError :type 'simple @getMessage "foo")))

(defSuite optDft*

  (defTest optDft*.1
    (optDft* '())
    '())

  (defTest optDft*.2
    (optDft* '() 1)
    '(1))

  (defTest optDft*.3
    (optDft* '() 1 2)
    '(1 2))

  (defTest optDft*.4
    (optDft* '(4) 1 2)
    '(4 2))

  (defTest optDft*.5
    (optDft* '(4 5) 1 2)
    '(4 5))

  (defTest optDft*.6
    (optDft* '(4 5 6) 1 2)
    '(4 5 6))

  (defTest optDft*.7
    (optDft* '(4 5 6))
    '(4 5 6))
    
  (defTest optDft*.8
    (optDft* '(4 () 6) 1 2 3 4)
    '(4 2 6 4)) )

(defSuite getOpt

  (defTest getOpt.1
    (signalsError?
     (optDft!)
     Error :type 'match :operands# +1))

  (defTest getOpt.2
    (optDft! (some 2))
    2)

  (defTest getOpt.3
    (signalsError?
     (optDft! #null)
     SimpleError :type 'simple @getMessage "Option is #null")))

(defSuite some

  (defTest some.1
    (some 1)
    (list 1))

  (defTest some.2
    (signalsError?
     (some)
     Error :type 'match :operands# +1))

  (defTest some.3
    (signalsError?
     (some 1 2)
     Error :type 'match :operands# -1)))

(defSuite ifOpt

  (defTest ifOpt1
    (ifOpt (x (some 12))
               x
               14)
    12)

  (defTest ifOpt2
    (ifOpt (x #null)
               x
               14)
    14)

  (defTest ifOpt3
    (signalsError?
     (ifOpt)
     Error :type 'match :operands# +2))

  (defTest ifOpt4
    (signalsError?
     (ifOpt (name))
     Error :type 'match :operands# +1))

  (defTest ifOpt4.2
    (signalsError?
     (ifOpt (name) then)
     Error :type 'match :operands# +1))

  (defTest ifOpt5
    (signalsError?
     (ifOpt (name option))
     Error :type 'match :operands# +1))

  (defTest ifOpt6
    (signalsError?
     (ifOpt (name option) then)
     Error :type 'unboundKey :key 'option)))

(defSuite whenOpt

  (defTest whenOpt0
    (whenOpt (x (some 12)))
    #null)

  (defTest whenOpt1
    (whenOpt (x (some 12))
                 x)
    12)

  (defTest whenOpt2
    (whenOpt (x #null)
                 x)
    #null)

  (defTest whenOpt3
    (signalsError?
     (whenOpt)
     Error :type 'match :operands# +1))

  (defTest whenOpt4
    (signalsError?
     (whenOpt (name))
     Error :type 'match :operands# +1)))

(defSuite unlessOpt

  (defTest unlessOpt0
    (unlessOpt (some 12) 2 3 (+ 2 2))
    #null)

  (defTest unlessOpt1
    (unlessOpt #null 2 3 (+ 2 2))
    4)

  (defTest unlessOpt2
    (unlessOpt #null)
    #null)

  (defTest unlessOpt3
    (signalsError?
     (unlessOpt)
     Error :type 'match :operands# +1)))

(defSuite classOf

  (defTest classOf.1
    (begin
      (assert#t (== (classOf "foo") String))
      (assert#t (== (classOf 12) Integer))
      (assert#t (== (classOf String) Class)))
    #inert)

  (defTest classOf.2
    (signalsError?
     (classOf)
     Error :type 'match :operands# +1)))

(defSuite set

  (defTest set.1
    (begin
      (set (theEnv) x 1)
      x)
    1)

  (defTest set.2
    (begin
      (def x 0)
      (set (theEnv) x 1)
      x)
    1)

  (defTest set.3
    (begin
      (set (theEnv) (x y) (list 1 2))
      (list x y))
    '(1 2))

  (defTest set.4
    (signalsError?
     (set)
     Error :type 'match :operands# +3))

  (defTest set.5
    (signalsError?
     (set (theEnv))
     Error :type 'match :operands# +2))

  (defTest set.6
    (signalsError?
     (set (theEnv) x)
     Error :type 'match :operands# +1))

  (defTest set.7
    (signalsError?
     (set 33 x y)
     Error :type 'type :datum 33 :expected 'Env)))

(defSuite className

  (defTest className.1
    (signalsError?
     (className)
     Error :type 'match :operands# +1))

  (defTest className.2
    (signalsError?
     (className "foo")
     Error :type 'type :datum "foo" :expected 'Class))

  (defTest className.3
    (className Object)
    'Object))

(defSuite subClass?

  (defTest subClass?.1
    (signalsError?
     (subClass?)
     Error :type 'match :operands# +2))

  (defTest subClass?.2
    (signalsError?
     (subClass? Object)
     Error :type 'match :operands# +1))

  (defTest subClass?.3
    (signalsError?
     (subClass? Object "foo")
     Error :type 'type :datum "foo" :expected 'Class))

  (defTest subClass?.4
    (signalsError?
     (subClass? "foo" Object)
     Error :type 'type :datum "foo" :expected 'Class))

  (defTest subClass?.5
    (&& (subClass? Object Object)
        (subClass? Class Object))
    #t))

;; Utility used by `%newClass' and `defClass' tests.

(def\ classes-test (c d p q)
  (assert#t (type? c Class))
  (assert#t (type? c Object))
  (assert#t (eq? (className c) 'Point2d))
  (assert#t (subClass? c Obj))
  (assert#t (subClass? c Object))

  (assert#t (type? p c))
  (assert#t (type? p Obj))
  (assert#t (type? p Object))
  (assert#t (eq? (getValue p 'x) 1))
  (assert#t (eq? (getValue p 'y) 2))

  (assert#t (type? d Class))
  (assert#t (type? d Object))
  (assert#t (eq? (className d) 'Point3d))
  (assert#t (subClass? d c))
  (assert#t (subClass? d Obj))
  (assert#t (subClass? d Object))

  (assert#t (type? q d))
  (assert#t (type? q c))
  (assert#t (type? q Obj))
  (assert#t (type? q Object))
  (assert#t (eq? (getValue q 'x) 1))
  (assert#t (eq? (getValue q 'y) 2))
  (assert#t (eq? (getValue q 'z) 3)))

(defSuite %newClass

  (defTest %newClass.1
    (let* ((c (%newClass 'Point2d Obj))
           (d (%newClass 'Point3d c))
           (p (new c :x 1 :y 2))
           (q (new d :x 1 :y 2 :z 3)))
      (classes-test c d p q))
    #inert)

  (defTest %newClass.2
    (signalsError?
     (%newClass 'Foo Object)
     Error :type 'type :datum Object :expected '(or Box Obj)))

  (defTest %newClass.3
     (%newClass 'Foo)
     &Ext.Foo)

  (defTest %newClass.4
    (signalsError?
     (%newClass)
     Error :type 'match :operands# +1))

  (defTest %newClass.5
    (signalsError?
     (%newClass "foo" Obj)
     Error :type 'type :datum "foo" :expected 'Symbol)))

(defSuite %reinitialize-standard-class

  (defTest %reinitialize-standard-class.1
    (let* ((a (%newClass 'A Obj))
           (b (%newClass 'B a))
           (c (%newClass 'C b))
           (d (%newClass 'D Obj))
           (e (%newClass 'E d)))
      (assert#t (subClass? b a))
      (assert#t (subClass? c a))
      (assert#t (subClass? c b))
      (%reinitialize-standard-class b e)
      (assert#t (subClass? b e))
      (assert#t (subClass? b d))
      (assert#t (subClass? c e))
      (assert#t (subClass? c d))
      (assert#t (subClass? c b)))
     Error :type 'unboundKey :key '%reinitialize-standard-class ))

(defSuite defClass

  (defTest defClass.1
    (signalsError?
     (defClass Foo () ("a"))
     Error :type 'type :datum "a" :expected 'Symbol))

  (defTest defClass.2
    (signalsError?
     (defClass)
     Error :type 'match :operands# +3))

  (defTest defClass.3
    (signalsError?
     (defClass Foo)
     Error :type 'match :operands# +2))

  (defTest defClass.4
    (signalsError?
     (defClass Foo ())
     Error :type 'match :operands# +1))

  (defTest defClass.5
    (type? (defClass C () ()) (if (== (bndRes) :rhs) Class Inert)))

  (defTest defClass.6
    (begin
      (defClass Point2d () (x y))
      (defClass Point3d (Point2d) (z))
      (def p (new Point2d :x 1 :y 2))
      (def q (new Point3d :x 1 :y 2 :z 3))
      (classes-test Point2d Point3d p q))
    #inert)

  (defTest defClass.redefine.1
    (begin 
      (defClass A () ())
      (defClass B (A) ())
      (defGeneric foo (x))
      (defMethod foo ((a A)) "foo")
      (def b (new B))
      (assert#t (subClass? B A))
      (assert#t (type? b B))
      (assert#t (type? b A))
      (assert#t (eq? "foo" (foo b)))
      (defClass C () ())
      (defMethod foo ((c C)) "bar")
      (defClass B (C) ())
      (assert#t (subClass? B C))
      (assert#t (== (classOf b) B))
      (assert#t (type? b B))
      (assert#t (type? b C))
      (assert#t (eq? "bar" (foo b))) )
    Error :type 'assert :datum #f :expected #t ))

(defSuite generics

  (defTest generics.1
    (begin
      (defClass Foo () ())
      (defClass Bar (Foo) ())
      (def foo (new Foo))
      (def bar (new Bar))

      (defGeneric g1 (new param))
      (assert#t (type? g1 Apv))

      (assert#t (signalsError?
               (g1 12 (+ 1 1))
               Error :type 'unboundExecutable :class Integer :executable 'g1))
      (assert#t (signalsError?
               (g1 foo (+ 1 1))
               Error :type 'unboundExecutable :class Foo :executable 'g1))
      (assert#t (signalsError?
               (g1 bar (+ 1 1))
               Error :type 'unboundExecutable :class Bar :executable 'g1))

      (defMethod g1 ((new Foo) param)
        (+ param 100))

      (assert#t (signalsError?
               (g1 12 (+ 1 1))
               Error :type 'unboundExecutable :class Integer :executable 'g1))
      (assert#t (eq? 102 (g1 foo (+ 1 1))))
      (assert#t (eq? 102 (g1 bar (+ 1 1))))

      (defMethod g1 ((new Bar) param)
        (+ param 1000))

      (assert#t (signalsError?
               (g1 12 (+ 1 1))
               Error :type 'unboundExecutable :class Integer :executable 'g1))
      (assert#t (eq? 102 (g1 foo (+ 1 1))))
      (assert#t (eq? 1002 (g1 bar (+ 1 1))))

      (defMethod g1 ((new Integer) param)
        (+ param 10000))

      (assert#t (eq? 10002 (g1 12 (+ 1 1))))
      (assert#t (eq? 102 (g1 foo (+ 1 1))))
      (assert#t (eq? 1002 (g1 bar (+ 1 1))))

      (defMethod g1 ((new Integer) param)
        (+ param 100000))

      (assert#t (eq? 100002 (g1 12 (+ 1 1))))
      (assert#t (eq? 102 (g1 foo (+ 1 1))))
      (assert#t (eq? 1002 (g1 bar (+ 1 1))))

      (defMethod g1 ((new Object) param)
        (- param))

      (assert#t (eq? 100002 (g1 12 (+ 1 1))))
      (assert#t (eq? 102 (g1 foo (+ 1 1))))
      (assert#t (eq? 1002 (g1 bar (+ 1 1))))
      (assert#t (eq? -2 (g1 #t (+ 1 1))))
      (assert#t (eq? -2 (g1 #inert (+ 1 1))))
      (assert#t (eq? -2 (g1 "hello" (+ 1 1)))))
    #inert))

(defSuite newBox

  (defTest newBox.1
    (let ((c (newBox)))
      (c))
    #inert)

  (defTest newBox.2
    (let ((c (newBox (+ 1 1))))
      (c))
    2)

  (defTest newBox.3
    (let ((c (newBox (+ 1 1))))
      (c (+ 2 2))
      (assert#t (eq? (c) 4))
      (c (+ 4 4))
      (c))
    8))
