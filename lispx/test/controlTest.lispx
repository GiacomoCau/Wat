;;; Control-related Tests

(defsuite fibers

  (deftest fiber.1
    (fiber 1 2 (eq? 1 1))
    #t)

  (deftest fiber.2
    (begin
      (def yield-record (fiber 1 2 (+ (fiberYield (eq? 1 1)) 3)))
      (assert#t (type? yield-record YieldRecord))
      (assert#t (eq? #t (getSlot yield-record 'value)))
      (assert#t (eq? 33 (fiberResume yield-record 30))))
    #inert)

  (deftest fiber.begin.1
    (runFiber
     (\ ()
       (begin
         (fiberYield 1)
         (fiberYield 2)
         3)))
    '(1 2 3))

  (deftest fiber.begin.2
    (runFiberWithValues
     (\ ()
       (begin
         (fiberYield 1)
         (fiberYield 2)))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.vau.1
    (runFiber
     (\ ()
       ((vau () #ignore
          (fiberYield 1)
          (fiberYield 2)
          3))))
    '(1 2 3))

  (deftest fiber.vau.2
    (runFiberWithValues
     (\ ()
       ((vau () #ignore
          (fiberYield 1)
          (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.\.1
    (runFiber
     (\ ()
       ((\ ()
          (fiberYield 1)
          (fiberYield 2)
          3))))
    '(1 2 3))

  (deftest fiber.\.2
    (runFiberWithValues
     (\ ()
       ((\ ()
          (fiberYield 1)
          (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.def.1
    (runFiber
     (\ ()
       (def (x y) (list (fiberYield 1) (fiberYield 2)))
       (list x y)))
    '(1 2 (#inert #inert)))

  (deftest fiber.def.2
    (runFiberWithValues
     (\ ()
       (def (x y) (list (fiberYield 1) (fiberYield 2)))
       (list x y))
     '(3 4))
    '(1 2 (3 4)))

  (deftest fiber.if.1
    (runFiber
     (\ ()
       (if #t (fiberYield 1) (fiberYield 2))))
    '(1 #inert))

  (deftest fiber.if.2
    (runFiberWithValues
     (\ ()
       (if #t (fiberYield 1) (fiberYield 2)))
     '(3))
    '(1 3))

  (deftest fiber.if.3
    (runFiber
     (\ ()
       (if #f (fiberYield 1) (fiberYield 2))))
    '(2 #inert))

  (deftest fiber.if.4
    (runFiberWithValues
     (\ ()
       (if #f (fiberYield 1) (fiberYield 2)))
     '(3))
    '(2 3))

  (deftest fiber.if.5
    (runFiberWithValues
     (\ ()
       (if (fiberYield 1) (fiberYield 2) (fiberYield 3)))
     '(#t 4))
    '(1 2 4))

  (deftest fiber.if.6
    (runFiberWithValues
     (\ ()
       (if (fiberYield 1) (fiberYield 2) (fiberYield 3)))
     '(#f 4))
    '(1 3 4))

  (deftest fiber.if.7
    (runFiberWithValues
     (\ ()
       (if (begin (fiberYield 1) (fiberYield 2))
           (begin (fiberYield 3) (fiberYield 3.5))
           (begin (fiberYield 4) (fiberYield 4.5))))
     '(#inert #t #inert 5))
    '(1 2 3 3.5 5))

  (deftest fiber.if.8
    (runFiberWithValues
     (\ ()
       (if (begin (fiberYield 1) (fiberYield 2))
           (begin (fiberYield 3) (fiberYield 3.5))
           (begin (fiberYield 4) (fiberYield 4.5))))
     '(#inert #f #inert 5))
    '(1 2 4 4.5 5))

  (deftest fiber.loop.1
    (runFiber
     (\ ()
       (def ct 1)
       (def env (theEnv))
       (block exit
         (loop
          (if (eq? ct 5)
              (returnFrom exit ct)
              (begin
                (fiberYield ct)
                (fiberYield (- ct))
                (set env ct (+ ct 1))))))))
    '(1 -1 2 -2 3 -3 4 -4 5))

  (deftest fiber.block.1
    (runFiber
     (\ ()
       (block b
         (fiberYield 1)
         (fiberYield 2)
         3)))
    '(1 2 3))

  (deftest fiber.block.2
    (runFiberWithValues
     (\ ()
       (block b
         (fiberYield 1)
         (fiberYield 2)))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.block.3
    (runFiber
     (\ ()
       (block b
         (fiberYield 1)
         (fiberYield 2)
         (returnFrom b 3))))
    '(1 2 3))

  (deftest fiber.block.4
    (runFiberWithValues
     (\ ()
       (block b
         (fiberYield 1)
         (returnFrom b (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.catchTag.1
    (runFiber
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (fiberYield 2)
         3)))
    '(1 2 3))

  (deftest fiber.catchTag.2
    (runFiberWithValues
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (fiberYield 2)))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.catchTag.3
    (runFiber
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (fiberYield 2)
         (throwTag 'b 3))))
    '(1 2 3))

  (deftest fiber.catchTag.4
    (runFiberWithValues
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (throwTag 'b (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.finally.1
    (runFiberWithValues
     (\ ()
       (finally (fiberYield 1)
         (fiberYield 2)
         (fiberYield 2.5)
         3))
     '(4 #inert #inert))
    '(1 2 2.5 4))

  (deftest fiber.finally.1'
    (runFiberWithValues
     (\ ()
       (atEnd
         (begin
           (fiberYield 2)
           (fiberYield 2.5)
           3 ) 
         (fiberYield 1) ))
     '(4 #inert #inert))
    '(1 2 2.5 4))

  (deftest fiber.finally.2
    (runFiberWithValues
     (\ ()
       (block exit
         (finally (returnFrom exit (fiberYield 1))
           (fiberYield 2)
           (fiberYield 2.5)
           3)))
     '(4 #inert #inert))
    '(1 2 2.5 4))

  (deftest fiber.finally.3
    (runFiberWithValues
     (\ ()
       (block exit
         (finally (returnFrom exit 4)
           (fiberYield 2)
           (fiberYield 2.5)
           3)))
     '(#inert #inert))
    '(2 2.5 4))

  (deftest fiber.finally.4
    (runFiberWithValues
     (\ ()
       (block exit
         (finally (begin (fiberYield 1) (fiberYield 1.5))
           (fiberYield 2)
           (fiberYield 2.5)
           3)))
     '(#inert 4 #inert #inert))
    '(1 1.5 2 2.5 4))

  (deftest fiber.progv.1
    (runFiber
     (\ ()
       (ddef *x*)
       (progv (*x*) (1)
         (fiberYield (dget *x*))
         (fiberYield (dget *x*))
         (progv (*x*) (2)
           (fiberYield (dget *x*))
           (fiberYield (dget *x*))
           3))))
    '(1 1 2 2 3))

  (deftest fiber.progv.2
    (runFiberWithValues
     (\ ()
       (ddef *x*)
       (progv (*x*) (1)
         (fiberYield (dget *x*))
         (fiberYield (dget *x*))
         (progv (*x*) (2)
           (fiberYield (dget *x*))
           (fiberYield (dget *x*)))))
     '(#inert #inert #inert 3))
    '(1 1 2 2 3))

  (deftest fiber.fun.1
    (runFiber
     (\ ()
       (list (fiberYield 1) (fiberYield 2))))
    '(1 2 (#inert #inert)))

  (deftest fiber.fun.2
    (runFiberWithValues
     (\ () (list (fiberYield 1) (fiberYield 2)))
     '(3 4))
    '(1 2 (3 4))))

;;; Basic Operator Tests

(defsuite pushPrompt

  (deftest pushPrompt.1
    (signalsError?
     (pushPrompt)
     Error :type 'match :operands# +1))

  (deftest pushPrompt.2
    (pushPrompt 'p)
    #inert)

  (deftest pushPrompt.3
    (pushPrompt 'p 1 2 (eq? 1 1))
    #t)

  (deftest pushPrompt.4
    (begin
      (block ret
        (pushPrompt 'p
          (assert#t (promptSet? 'p))
          (returnFrom ret)))
      (assert#t (not (promptSet? 'p))))
    #inert)

  (deftest pushPrompt.5
    (begin
      (assert#t (not (promptSet? 'p)))
      (assert#t (not (promptSet? 'q)))
      (pushPrompt 'p
        (assert#t (promptSet? 'p))
        (assert#t (not (promptSet? 'q)))
        (pushPrompt 'q
          (assert#t (promptSet? 'p))
          (assert#t (promptSet? 'q)))
        (assert#t (promptSet? 'p))
        (assert#t (not (promptSet? 'q))))
      (assert#t (not (promptSet? 'p)))
      (assert#t (not (promptSet? 'q))))
    #inert))

(defsuite takeSubcont

  (deftest takeSubcont.1
    (signalsError?
     (takeSubcont)
     Error :type 'match :operands# +2))

  (deftest takeSubcont.2
    (signalsError?
     (takeSubcont 'p)
     Error :type 'match :operands# +1))

  (deftest takeSubcont.3
    (signalsError?
     (takeSubcont 'p #ignore)
     Error :type 'unboundPrompt :prompt 'p))

  (deftest takeSubcont.4
    (signalsError?
     (pushPrompt 'p (takeSubcont 'q #ignore))
     Error :type 'unboundPrompt :prompt 'q))

  (deftest takeSubcont.5
    (pushPrompt 'p (takeSubcont 'p #ignore))
    #inert)

  (deftest takeSubcont.6
    (pushPrompt 'p (takeSubcont 'p #ignore (eq? 1 1)))
    #t)

  (deftest takeSubcont.7
    (pushPrompt 'p (takeSubcont 'p k (pushDelimSubcont 'p k (eq? 1 1))))
    #t))

(defsuite pushDelimSubcont

  (deftest pushDelimSubcont.1
    (signalsError?
     (pushDelimSubcont)
     Error :type 'match :operands# +2))

  (deftest pushDelimSubcont.2
    (signalsError?
     (pushDelimSubcont 'p)
     Error :type 'match :operands# +1))

  (deftest pushDelimSubcont.3
    (signalsError?
     (pushDelimSubcont 'p 12)
     Error :type 'type :datum 12))

  (deftest pushDelimSubcont.4
    (let ((k (pushPrompt 'p (+ 100 (takeSubcont 'p k k)))))
      (assert#t (eq? 102 (pushDelimSubcont 'p k (+ 1 1))))
      (assert#t (eq? 120 (pushDelimSubcont 'p k (+ 10 10)))))
    #inert)

  (deftest pushDelimSubcont.5
    (let ((k (pushPrompt 'p (pushPrompt 'q (takeSubcont 'p k k)))))
      (pushDelimSubcont 'p k
        (assert#t (promptSet? 'q))
        (assert#t (promptSet? 'p))))
    #inert))

(defsuite promptSet?

  (deftest promptSet?.1
    (signalsError?
     (promptSet?)
     Error :type 'match :operands# +1))

  (deftest promptSet?.2
    (promptSet? 'p)
    #f)

  (deftest promptSet?.3
    (pushPrompt 'p (begin (promptSet? 'p)))
    #t))

(defsuite pushSubcontBarrier

  (deftest pushSubcontBarrier.1
    (signalsError?
     (pushSubcontBarrier
      (takeSubcont 'p1 sk))
     Error :type 'unboundPrompt :prompt 'p1))

  (deftest pushSubcontBarrier.2
    (signalsError?
     (pushPrompt 'p1
       (pushSubcontBarrier
         (takeSubcont 'p1 sk)))
     Error :type 'unboundPrompt :prompt 'p1)))

(defsuite dynamics

  (deftest ddef.1
    (begin
      (ddef *x* 1)
      (ddef *y* (+ 1 1))
      (assert#t (eq? (dget *x*) 1))
      (assert#t (eq? (dget *y*) 2))
      (dlet ((*x* 3))
        (assert#t (eq? (dget *x*) 3))
        (assert#t (eq? (dget *y*) 2))
        (dlet ((*y* 4))
          (assert#t (eq? (dget *x*) 3))
          (assert#t (eq? (dget *y*) 4)))
        (assert#t (eq? (dget *x*) 3))
        (assert#t (eq? (dget *y*) 2)))
      (assert#t (eq? (dget *x*) 1))
      (assert#t (eq? (dget *y*) 2)))
    #inert)

  (deftest* ddef.redefine
    (ddef *a* (+ 1 1))
    (def old-a *a*)
    (assert#t (eq? (dget *a*) 2))
    (assert#t (eq? (dget old-a) 2))
    (ddef *a* (+ 2 2))
    (assert#t (eq? (dget *a*) 4))
    (assert#t (eq? (dget old-a) 4))
    (assert#t (== old-a *a*))
    (ddef *a*)
    (assert#t (eq? (dget *a*) #inert))
    (assert#t (eq? (dget old-a) #inert))
    (assert#t (== old-a *a*)))

  (deftest progv.1
    (begin
      (ddef *x* 1)
      (ddef *y* 2)
      (assert#t (eq? (dget *x*) 1))
      (assert#t (eq? (dget *y*) 2))
      (progv (*x*) (3)
        (assert#t (eq? (dget *x*) 3))
        (assert#t (eq? (dget *y*) 2))
        (progv (*y*) (4)
          (assert#t (eq? (dget *x*) 3))
          (assert#t (eq? (dget *y*) 4)))
        (assert#t (eq? (dget *x*) 3))
        (assert#t (eq? (dget *y*) 2)))
      (assert#t (eq? (dget *x*) 1))
      (assert#t (eq? (dget *y*) 2)))
    #inert)

  (deftest dget.1
    (begin
      (ddef *foo*)
      (assert#t (eq? (dget *foo*) #inert))
      (assert#t (type? *foo* DVar))
      (assert#t (type? *foo* Box))
      (assert#t (type? *foo* Object))
      (assert#t (subClass? DVar Box))
      (assert#t (subClass? DVar Object)))
    #inert)

  (deftest dset.1
    (begin
      (ddef *bar*)
      (dlet ((*bar* 1))
        (dset *bar* 2)
        (assert#t (eq? 2 (dget *bar*)))
        (dlet ((*bar* 3))
          (assert#t (eq? 3 (dget *bar*))))
        (assert#t (eq? 2 (dget *bar*)))
        (dset *bar* 4)
        (assert#t (eq? 4 (dget *bar*))))
      (assert#t (eq? #inert (dget *bar*)))
      #t))

  (deftest dlet*.1
    (dlet* () (+ 1 1))
    2)

  (deftest dlet*.2
    (begin
      (ddef *x* 1)
      (dlet* ((*x* 2)) (+ 1 (dget *x*))))
    3)

  (deftest dlet*.2
    (begin
      (ddef *x* 1)
      (ddef *y* 0)
      (dlet* ((*x* 2) (*y* (+ (dget *x*) 1)))
        (list (dget *x*) (dget *y*))))
    '(2 3))

  (deftest dlet-sanity-check
    (begin
      (ddef *x* 1)
      (ddef *y* 0)
      (dlet ((*x* 2) (*y* (+ (dget *x*) 1)))
        (list (dget *x*) (dget *y*))))
    '(2 2)))

(defsuite built-in-prompts

  (deftest |Default prompt exists|
    (bound? 'coroutinePrompt (theEnv)))

  (deftest |Root prompt exists|
    (bound? 'rootPrompt (theEnv)))

  (deftest |Root prompt is set|
    ;; I have no idea why this works.  I mean it's the right thing,
    ;; but it's unclear how it interacts with test-util.lispx's
    ;; Mocha stuff that runs this test.
    (takeSubcont rootPrompt #ignore)
    #inert))

;;; Simple Control Operators

(defsuite loop

  (deftest loop.1
    (let ((ct 0))
      (def env (theEnv))
      (block exit
        (loop 'just-a-symbol-to-test-implicit-begin
              (if (eq? ct 10)
                  (returnFrom exit ct)
                  (set env ct (+ ct 1))))))
    10))

(defsuite catchTag/throwTag

  (deftest catchTag.1
    (signalsError?
     (catchTag)
     Error :type 'match :operands# +1))

  (deftest catchTag.2
    (catchTag 'x)
    #inert)

  (deftest catchTag.3
    (catchTag 'x 1 2 3 (eq? 1 1))
    #t)

  (deftest catchTag.4
    (catchTag 'x 1 (throwTag 'x (eq? 1 2)) 3 (eq? 1 1))
    #f)

  (deftest catchTag.5
    (catchTag 'x 1 (throwTag 'x) 3 (eq? 1 1))
    #inert)

  (deftest catchTag.6
    (catchTag 'x 1 (catchTag 'y (throwTag 'x 44)) 3 (eq? 1 1))
    44)

  (deftest catchTag.7
    (catchTag 'x 1 (catchTag 'y (throwTag 'y 2)) 3 55)
    55)

  (deftest catchTag.8
    (catchTag 'x 1 (catchTag 'y (throwTag 'y 2)))
    2)

  (deftest catchTag.9
    (catchTag 'x 1 (catchTag 'y (throwTag 'y)))
    #inert))

(defsuite block/returnFrom

  (deftest block.1
    (signalsError?
     (block)
     Error :type 'match :operands# +1))

  (deftest block.2
    (block x)
    #inert)

  (deftest block.3
    (block x 1 2 3 (eq? 1 1))
    #t)

  (deftest block.4
    (block x 1 (returnFrom x (eq? 1 2)) 3 (eq? 1 1))
    #f)

  (deftest block.5
    (block x 1 (returnFrom x) 3 (eq? 1 1))
    #inert)

  (deftest block.6
    (block x 1 (block y (returnFrom x (eq? 1 2))) 3 (eq? 1 1))
    #f)

  (deftest block.7
    (block x 1 (block y (returnFrom y 2)) 3 (eq? 1 1))
    #t)

  (deftest block.8
    (block x 1 (block y (returnFrom y 2)))
    2)

  (deftest block.9
    (block x 1 (block y (returnFrom y)))
    #inert))

(defsuite finally

  (deftest finally.1
    (signalsError?
     (finally)
     Error :type 'match :operands# +1))

  (deftest finally.2
    (finally (eq? 1 1))
    #t)

  (deftest finally.3
    (begin
      (def env (theEnv))
      (+ (finally 1 2 3 (set env x 10))
         x))
    11)

  (deftest finally.4
    (begin
      (def env (theEnv))
      (+ (block exit
           (finally (returnFrom exit 1) 2 3 (set env x 10)))
         x))
    11)

  (deftest finally.5
    (block exit
      (finally 1 2 3 (returnFrom exit 4)))
    4)

  (deftest finally.6
    (block exit
      (finally (returnFrom exit 1) 2 3 (returnFrom exit 4)))
    4))
