;;; Control-related Tests

;;; Fibers

;; The following implementation of fibers follows the one at URL
;; `http://okmij.org/ftp/continuations/implementations.html#dget-wind'
;;
;; We're calling them fibers instead of coroutines so as to not
;; conflict with the built-in coroutine operators.
;;
;; We use it for testing that built-in operators properly suspend and
;; resume.

(defConstant fiberPrompt
  #|The prompt used for delimiting fibers.
   |#
  'fiber-prompt)

(defClass YieldRecord ()
  #|Instances of this class are yielded.
   |#
  (value continuation) )

(def\ makeYieldRecord (v k)
  #|Create a new yield record with the given yielded value and resume continuation.
   |#
  (newObj YieldRecord :value v :continuation k))

(def\ fiberYield v?
  #|Yield a value (which defaults to void).
   |#
  (takeSubcont fiberPrompt k
    (makeYieldRecord (opt? v? #inert) k)))

(def\ fiberResume (yieldRecord . v?)
  #|Resume a suspended fiber with a value (which defaults to void).
   |#
  (pushDelimSubcont fiberPrompt (getSlot yieldRecord 'continuation)
    (opt? v? #inert)))

(defMacro fiber body
  #|Evaluate the body expressions as a fiber.
   |#
  (list* pushPrompt 'fiberPrompt body))

(def\ runFiber (thunk)
  #|Get all values yielded by a fiber, and its final result, and
   |collect them in a list.
   |#
  (let1 run (result (fiber (thunk)))
    (if (type? result YieldRecord)
        (cons (getSlot result 'value) (run (fiberResume result)))
        (list result))))

(def\ runFiberWithValues (thunk values)
  #|Like `runFiber' but uses a list of values that are sent to the
   |fiber with `fiberResume'.
   |#
  (let run ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
        (cons (getSlot result 'value)
              (run (fiberResume result (car values)) (cdr values)))
        (list result))))


(defsuite fibers

  (deftest fiber.1
    (fiber 1 2 (eq? 1 1))
    #t)

  (deftest fiber.2
    (begin
      (def yield-record (fiber 1 2 (+ (fiberYield (eq? 1 1)) 3)))
      (assert (type? yield-record YieldRecord))
      (assert (eq? #t (getSlot yield-record 'value)))
      (assert (eq? 33 (fiberResume yield-record 30))))
    #inert)

  (deftest fiber.begin.1
    (runFiber
     (\ ()
       (begin
         (fiberYield 1)
         (fiberYield 2)
         3)))
    '(1 2 3))

  (deftest fiber.begin.2
    (runFiberWithValues
     (\ ()
       (begin
         (fiberYield 1)
         (fiberYield 2)))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.vau.1
    (runFiber
     (\ ()
       ((vau () #ignore
          (fiberYield 1)
          (fiberYield 2)
          3))))
    '(1 2 3))

  (deftest fiber.vau.2
    (runFiberWithValues
     (\ ()
       ((vau () #ignore
          (fiberYield 1)
          (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.\.1
    (runFiber
     (\ ()
       ((\ ()
          (fiberYield 1)
          (fiberYield 2)
          3))))
    '(1 2 3))

  (deftest fiber.\.2
    (runFiberWithValues
     (\ ()
       ((\ ()
          (fiberYield 1)
          (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.def.1
    (runFiber
     (\ ()
       (def (x y) (list (fiberYield 1) (fiberYield 2)))
       (list x y)))
    '(1 2 (#inert #inert)))

  (deftest fiber.def.2
    (runFiberWithValues
     (\ ()
       (def (x y) (list (fiberYield 1) (fiberYield 2)))
       (list x y))
     '(3 4))
    '(1 2 (3 4)))

  (deftest fiber.if.1
    (runFiber
     (\ ()
       (if #t (fiberYield 1) (fiberYield 2))))
    '(1 #inert))

  (deftest fiber.if.2
    (runFiberWithValues
     (\ ()
       (if #t (fiberYield 1) (fiberYield 2)))
     '(3))
    '(1 3))

  (deftest fiber.if.3
    (runFiber
     (\ ()
       (if #f (fiberYield 1) (fiberYield 2))))
    '(2 #inert))

  (deftest fiber.if.4
    (runFiberWithValues
     (\ ()
       (if #f (fiberYield 1) (fiberYield 2)))
     '(3))
    '(2 3))

  (deftest fiber.if.5
    (runFiberWithValues
     (\ ()
       (if (fiberYield 1) (fiberYield 2) (fiberYield 3)))
     '(#t 4))
    '(1 2 4))

  (deftest fiber.if.6
    (runFiberWithValues
     (\ ()
       (if (fiberYield 1) (fiberYield 2) (fiberYield 3)))
     '(#f 4))
    '(1 3 4))

  (deftest fiber.if.7
    (runFiberWithValues
     (\ ()
       (if (begin (fiberYield 1) (fiberYield 2))
           (begin (fiberYield 3) (fiberYield 3.5))
           (begin (fiberYield 4) (fiberYield 4.5))))
     '(#inert #t #inert 5))
    '(1 2 3 3.5 5))

  (deftest fiber.if.8
    (runFiberWithValues
     (\ ()
       (if (begin (fiberYield 1) (fiberYield 2))
           (begin (fiberYield 3) (fiberYield 3.5))
           (begin (fiberYield 4) (fiberYield 4.5))))
     '(#inert #f #inert 5))
    '(1 2 4 4.5 5))

  (deftest fiber.loop.1
    (runFiber
     (\ ()
       (def ct 1)
       (def env (theEnv))
       (block exit
         (loop
          (if (eq? ct 5)
              (returnFrom exit ct)
              (begin
                (fiberYield ct)
                (fiberYield (- ct))
                (set env ct (+ ct 1))))))))
    '(1 -1 2 -2 3 -3 4 -4 5))

  (deftest fiber.block.1
    (runFiber
     (\ ()
       (block b
         (fiberYield 1)
         (fiberYield 2)
         3)))
    '(1 2 3))

  (deftest fiber.block.2
    (runFiberWithValues
     (\ ()
       (block b
         (fiberYield 1)
         (fiberYield 2)))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.block.3
    (runFiber
     (\ ()
       (block b
         (fiberYield 1)
         (fiberYield 2)
         (returnFrom b 3))))
    '(1 2 3))

  (deftest fiber.block.4
    (runFiberWithValues
     (\ ()
       (block b
         (fiberYield 1)
         (returnFrom b (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.catchTag.1
    (runFiber
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (fiberYield 2)
         3)))
    '(1 2 3))

  (deftest fiber.catchTag.2
    (runFiberWithValues
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (fiberYield 2)))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.catchTag.3
    (runFiber
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (fiberYield 2)
         (throwTag 'b 3))))
    '(1 2 3))

  (deftest fiber.catchTag.4
    (runFiberWithValues
     (\ ()
       (catchTag 'b
         (fiberYield 1)
         (throwTag 'b (fiberYield 2))))
     '(#inert 3))
    '(1 2 3))

  (deftest fiber.finally.1
    (runFiberWithValues
     (\ ()
       (finally (fiberYield 1)
         (fiberYield 2)
         (fiberYield 2.5)
         3))
     '(4 #inert #inert))
    '(1 2 2.5 4))

  (deftest fiber.finally.2
    (runFiberWithValues
     (\ ()
       (block exit
         (finally (returnFrom exit (fiberYield 1))
           (fiberYield 2)
           (fiberYield 2.5)
           3)))
     '(4 #inert #inert))
    '(1 2 2.5 4))

  (deftest fiber.finally.3
    (runFiberWithValues
     (\ ()
       (block exit
         (finally (returnFrom exit 4)
           (fiberYield 2)
           (fiberYield 2.5)
           3)))
     '(#inert #inert))
    '(2 2.5 4))

  (deftest fiber.finally.4
    (runFiberWithValues
     (\ ()
       (block exit
         (finally (begin (fiberYield 1) (fiberYield 1.5))
           (fiberYield 2)
           (fiberYield 2.5)
           3)))
     '(#inert 4 #inert #inert))
    '(1 1.5 2 2.5 4))

  (deftest fiber.progv.1
    (runFiber
     (\ ()
       (ddef *x*)
       (progv (*x*) (1)
         (fiberYield (dget *x*))
         (fiberYield (dget *x*))
         (progv (*x*) (2)
           (fiberYield (dget *x*))
           (fiberYield (dget *x*))
           3))))
    '(1 1 2 2 3))

  (deftest fiber.progv.2
    (runFiberWithValues
     (\ ()
       (ddef *x*)
       (progv (*x*) (1)
         (fiberYield (dget *x*))
         (fiberYield (dget *x*))
         (progv (*x*) (2)
           (fiberYield (dget *x*))
           (fiberYield (dget *x*)))))
     '(#inert #inert #inert 3))
    '(1 1 2 2 3))

  (deftest fiber.fun.1
    (runFiber
     (\ ()
       (list (fiberYield 1) (fiberYield 2))))
    '(1 2 (#inert #inert)))

  (deftest fiber.fun.2
    (runFiberWithValues
     (\ () (list (fiberYield 1) (fiberYield 2)))
     '(3 4))
    '(1 2 (3 4))))

;;; Basic Operator Tests

(defsuite pushPrompt

  (deftest pushPrompt.1
    (signalsError
     (pushPrompt)
     MatchError))

  (deftest pushPrompt.2
    (pushPrompt 'p)
    #inert)

  (deftest pushPrompt.3
    (pushPrompt 'p 1 2 (eq? 1 1))
    #t)

  (deftest pushPrompt.4
    (begin
      (block ret
        (pushPrompt 'p
          (assert (promptSet? 'p))
          (returnFrom ret)))
      (assert (not (promptSet? 'p))))
    #inert)

  (deftest pushPrompt.5
    (begin
      (assert (not (promptSet? 'p)))
      (assert (not (promptSet? 'q)))
      (pushPrompt 'p
        (assert (promptSet? 'p))
        (assert (not (promptSet? 'q)))
        (pushPrompt 'q
          (assert (promptSet? 'p))
          (assert (promptSet? 'q)))
        (assert (promptSet? 'p))
        (assert (not (promptSet? 'q))))
      (assert (not (promptSet? 'p)))
      (assert (not (promptSet? 'q))))
    #inert))

(defsuite takeSubcont

  (deftest takeSubcont.1
    (signalsError
     (takeSubcont)
     MatchError))

  (deftest takeSubcont.2
    (signalsError
     (takeSubcont 'p)
     MatchError))

  (deftest takeSubcont.3
    (signalsError
     (takeSubcont 'p #ignore)
     PromptNotFoundError :prompt 'p))

  (deftest takeSubcont.4
    (signalsError
     (pushPrompt 'p (takeSubcont 'q #ignore))
     PromptNotFoundError :prompt 'q))

  (deftest takeSubcont.5
    (pushPrompt 'p (takeSubcont 'p #ignore))
    #inert)

  (deftest takeSubcont.6
    (pushPrompt 'p (takeSubcont 'p #ignore (eq? 1 1)))
    #t)

  (deftest takeSubcont.7
    (pushPrompt 'p (takeSubcont 'p k (pushDelimSubcont 'p k (eq? 1 1))))
    #t))

(defsuite pushDelimSubcont

  (deftest pushDelimSubcont.1
    (signalsError
     (pushDelimSubcont)
     MatchError))

  (deftest pushDelimSubcont.2
    (signalsError
     (pushDelimSubcont 'p)
     MatchError))

  (deftest pushDelimSubcont.3
    (signalsError
     (pushDelimSubcont 'p 12)
     Error :type 'type :datum 12))

  (deftest pushDelimSubcont.4
    (let ((k (pushPrompt 'p (+ 100 (takeSubcont 'p k k)))))
      (assert (eq? 102 (pushDelimSubcont 'p k (+ 1 1))))
      (assert (eq? 120 (pushDelimSubcont 'p k (+ 10 10)))))
    #inert)

  (deftest pushDelimSubcont.5
    (let ((k (pushPrompt 'p (pushPrompt 'q (takeSubcont 'p k k)))))
      (pushDelimSubcont 'p k
        (assert (promptSet? 'q))
        (assert (promptSet? 'p))))
    #inert))

(defsuite promptSet?

  (deftest promptSet?.1
    (signalsError
     (promptSet?)
     MatchError))

  (deftest promptSet?.2
    (promptSet? 'p)
    #f)

  (deftest promptSet?.3
    (pushPrompt 'p (begin (promptSet? 'p)))
    #t))

(defsuite pushSubcontBarrier

  (deftest pushSubcontBarrier.1
    (signalsError
     (pushSubcontBarrier
      (takeSubcont 'p1 sk))
     PromptNotFoundError :prompt 'p1))

  (deftest pushSubcontBarrier.2
    (signalsError
     (pushPrompt 'p1
       (pushSubcontBarrier
         (takeSubcont 'p1 sk)))
     PromptNotFoundError :prompt 'p1)
    #f))

(defsuite dynamics

  (deftest ddef.1
    (begin
      (ddef *x* 1)
      (ddef *y* (+ 1 1))
      (assert (eq? (dget *x*) 1))
      (assert (eq? (dget *y*) 2))
      (dlet ((*x* 3))
        (assert (eq? (dget *x*) 3))
        (assert (eq? (dget *y*) 2))
        (dlet ((*y* 4))
          (assert (eq? (dget *x*) 3))
          (assert (eq? (dget *y*) 4)))
        (assert (eq? (dget *x*) 3))
        (assert (eq? (dget *y*) 2)))
      (assert (eq? (dget *x*) 1))
      (assert (eq? (dget *y*) 2)))
    #inert)

  (deftest* ddef.redefine
    (ddef *a* (+ 1 1))
    (def old-a *a*)
    (assert (eq? (dget *a*) 2))
    (assert (eq? (dget old-a) 2))
    (ddef *a* (+ 2 2))
    (assert (eq? (dget *a*) 4))
    (assert (eq? (dget old-a) 4))
    (assert (== old-a *a*))
    (ddef *a*)
    (assert (eq? (dget *a*) #inert))
    (assert (eq? (dget old-a) #inert))
    (assert (== old-a *a*)))

  (deftest progv.1
    (begin
      (ddef *x* 1)
      (ddef *y* 2)
      (assert (eq? (dget *x*) 1))
      (assert (eq? (dget *y*) 2))
      (progv (*x*) (3)
        (assert (eq? (dget *x*) 3))
        (assert (eq? (dget *y*) 2))
        (progv (*y*) (4)
          (assert (eq? (dget *x*) 3))
          (assert (eq? (dget *y*) 4)))
        (assert (eq? (dget *x*) 3))
        (assert (eq? (dget *y*) 2)))
      (assert (eq? (dget *x*) 1))
      (assert (eq? (dget *y*) 2)))
    #inert)

  (deftest dget.1
    (begin
      (ddef *foo*)
      (assert (eq? (dget *foo*) #inert))
      (assert (type? *foo* DVar))
      (assert (type? *foo* Box))
      (assert (type? *foo* Object))
      (assert (subClass? DVar Box))
      (assert (subClass? DVar Object)))
    #inert)

  (deftest dset.1
    (begin
      (ddef *bar*)
      (dlet ((*bar* 1))
        (dset *bar* 2)
        (assert (eq? 2 (dget *bar*)))
        (dlet ((*bar* 3))
          (assert (eq? 3 (dget *bar*))))
        (assert (eq? 2 (dget *bar*)))
        (dset *bar* 4)
        (assert (eq? 4 (dget *bar*))))
      (assert (eq? #inert (dget *bar*)))
      #t))

  (deftest dlet*.1
    (dlet* () (+ 1 1))
    2)

  (deftest dlet*.2
    (begin
      (ddef *x* 1)
      (dlet* ((*x* 2)) (+ 1 (dget *x*))))
    3)

  (deftest dlet*.2
    (begin
      (ddef *x* 1)
      (ddef *y* 0)
      (dlet* ((*x* 2) (*y* (+ (dget *x*) 1)))
        (list (dget *x*) (dget *y*))))
    '(2 3))

  (deftest dlet-sanity-check
    (begin
      (ddef *x* 1)
      (ddef *y* 0)
      (dlet ((*x* 2) (*y* (+ (dget *x*) 1)))
        (list (dget *x*) (dget *y*))))
    '(2 2)))

(defsuite built-in-prompts

  (deftest |Default prompt exists|
    (bound? 'coroutinePrompt (theEnv)))

  (deftest |Root prompt exists|
    (bound? 'rootPrompt (theEnv)))

  (deftest |Root prompt is set|
    ;; I have no idea why this works.  I mean it's the right thing,
    ;; but it's unclear how it interacts with test-util.lispx's
    ;; Mocha stuff that runs this test.
    (takeSubcont rootPrompt #ignore)
    #inert))

;;; Simple Control Operators

(defsuite loop

  (deftest loop.1
    (let ((ct 0))
      (def env (theEnv))
      (block exit
        (loop 'just-a-symbol-to-test-implicit-begin
              (if (eq? ct 10)
                  (returnFrom exit ct)
                  (set env ct (+ ct 1))))))
    10))

(defsuite catchTag/throwTag

  (deftest catchTag.1
    (signalsError
     (catchTag)
     MatchError))

  (deftest catchTag.2
    (catchTag 'x)
    #inert)

  (deftest catchTag.3
    (catchTag 'x 1 2 3 (eq? 1 1))
    #t)

  (deftest catchTag.4
    (catchTag 'x 1 (throwTag 'x (eq? 1 2)) 3 (eq? 1 1))
    #f)

  (deftest catchTag.5
    (catchTag 'x 1 (throwTag 'x) 3 (eq? 1 1))
    #inert)

  (deftest catchTag.6
    (catchTag 'x 1 (catchTag 'y (throwTag 'x 44)) 3 (eq? 1 1))
    44)

  (deftest catchTag.7
    (catchTag 'x 1 (catchTag 'y (throwTag 'y 2)) 3 55)
    55)

  (deftest catchTag.8
    (catchTag 'x 1 (catchTag 'y (throwTag 'y 2)))
    2)

  (deftest catchTag.9
    (catchTag 'x 1 (catchTag 'y (throwTag 'y)))
    #inert))

(defsuite block/returnFrom

  (deftest block.1
    (signalsError
     (block)
     MatchError))

  (deftest block.2
    (block x)
    #inert)

  (deftest block.3
    (block x 1 2 3 (eq? 1 1))
    #t)

  (deftest block.4
    (block x 1 (returnFrom x (eq? 1 2)) 3 (eq? 1 1))
    #f)

  (deftest block.5
    (block x 1 (returnFrom x) 3 (eq? 1 1))
    #inert)

  (deftest block.6
    (block x 1 (block y (returnFrom x (eq? 1 2))) 3 (eq? 1 1))
    #f)

  (deftest block.7
    (block x 1 (block y (returnFrom y 2)) 3 (eq? 1 1))
    #t)

  (deftest block.8
    (block x 1 (block y (returnFrom y 2)))
    2)

  (deftest block.9
    (block x 1 (block y (returnFrom y)))
    #inert))

(defsuite finally

  (deftest finally.1
    (signalsError
     (finally)
     MatchError))

  (deftest finally.2
    (finally (eq? 1 1))
    #t)

  (deftest finally.3
    (begin
      (def env (theEnv))
      (+ (finally 1 2 3 (set env x 10))
         x))
    11)

  (deftest finally.4
    (begin
      (def env (theEnv))
      (+ (block exit
           (finally (returnFrom exit 1) 2 3 (set env x 10)))
         x))
    11)

  (deftest finally.5
    (block exit
      (finally 1 2 3 (returnFrom exit 4)))
    4)

  (deftest finally.6
    (block exit
      (finally (returnFrom exit 1) 2 3 (returnFrom exit 4)))
    4))
