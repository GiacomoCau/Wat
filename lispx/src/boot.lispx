;;                                                     -*- mode: Scheme -*-
;; LispX Bootstrap
;;

;; Copyright (c) 2021, 2022 Manuel J. Simoni

;; ``72. An adequate bootstrap is a contradiction in terms.''

;;; Core Built-Ins for Macro and Definition Forms

(%def def
  #|Match the DEFINIEND-TREE against the VALUE and define resulting bindings into the current environment, throws an error otherwise.
   |without bindResult or with bindResult #ignore use as bindResult (bndRes)
   |with bindResult #inert return #inert
   |with bindResult :rhs return the right side of the last binding
   |with bindResult :prv return the previous value of the last binding
   |with bindResult :obj return the env
   |$(fn definiendTree value)
   |$(fn definiendTree bindResult value)
   |$(syntax bindResult (or #ignore #inert :rhs :prv))  
   |$(type fexpr)
   |#
  %def )

(def vau
  #|Return a anonymous fexpr with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER and FORMS as body.
   |$(fn parameterTree environmentParameter . forms)
   |$(type fexpr)
   |$(derivation (vau (pt ep . forms) env (eval (list 'vau pt ep (cons 'begin forms)) env)))
   |#
  %vau )

(def \
  #|Return an anonymous function with the given PARAMETER-TREE and FORMS as body.
   |$(fn parameterTree . forms)
   |$(type function)
   |$(derivation (vau (parameterTree . forms) env (wrap (eval (list* 'vau parameterTree #ignore forms) env))))
   |#
  %\ )
(def lambda
  #|alias for \ :-)
   |#
  \ )

(def wrap
  #|Return a new function that wraps around an underlying OPERATOR, and induces argument evaluation around it.
   |$(fn operator)
   |$(type function)
   |#
  %wrap )

(def assert
  #|Reports an error if:
   |- EXPRESSION does not equal VALUE
   |- VALUE is not present and the EXPRESSION does not throws
   |- EXPRESSION throws or returns an object and the object is not of the same CLASS with the ATTRIBUTES of the given VALUE.
   |$(fn expression value)
   |$(fn expression)
   |$(fn expression class attribute value . attributes)
   |$(syntax attributes (or () (attribute value . attributes)))
   |$(syntax attribute (or Symbol Keyword String .Field @Method))
   |$(type fexpr)
   |#
  %assert )

(def apply
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn fun args . env)
   |$(type function)
   |$(derivation (eval (cons (unwrap fun) args) (if (null? env) (newEnv) (car! env)) ))
   |#
  %apply )

(def begin
  #|Sequentially evaluate FORMS returning the value of the last one or #inert if FORMS is null.
   |$(fn . forms)
   |$(type fexpr)
   |#
  %begin )

(def car
  #|Return the contents of the address part of the register.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ ((car . #_)) car))
   |$(derivation (@car cons))
   |#
  %car )

(def car!
  #|Return the contents of the address part of the register
   |if decrement part of the register is null, else error.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ ((car)) car))
   |#
  (\ ((car)) car) )

(def cadr
  #|Return the `car' of the `cdr' of the CONS.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ ((#_ cadr . #_)) cadr))
   |$(derivation (car (cdr cons)))
   |$(derivation (@car cons 1))
   |#
  %cadr )

(def cdr
  #|Return the contents of the decrement part of the register.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ ((#_ . cdr)) cdr))
   |$(derivation (@cdr cons))
   |#
  %cdr )

(def cons
  #|Return a cons with the given CAR and CDR.
   |$(fn car cdr)
   |$(type function)
   |$(derivation (@new vm Cons car cdr))
   |#
  %cons )

(def cons?
  #|Return true if the OBJECT is a cons, false otherwise.
   |$(fn object)
   |$(type function)
   |$(derivation (\ (object) (type? object Cons)))
   |#
  %cons? )

(def eval
  #|Evaluate the FORM in the ENVIRONMENT, returning its result.
   |$(fn form . environment)
   |$(type function)
   |$(derivation (eval (if (null? environment) ((vau () env env)) (car! environment))))
   |#
  %eval )

(def if
  #|Evaluate the TEST which must yield a boolean.
   |Then evaluate either the THEN or ELSE expression depending on whether the TEST yielded true or false.
   |Idea stolen from Anarki https://github.com/arclanguage/anarki :-) 
   |$(fn test then . forms)
   |$(syntax forms (or () (else) (test then . forms)))
   |$(type fexpr)
   |$(derivation (vau (test then . forms) env (if (eval test env) (eval then env) (null? forms) #inert (null? (cdr forms)) (eval (car forms) env) (apply if forms env))))
   |#
  %if )

(def list
  #|Return the list of evaluated ARGUMENTS.
   |$(fn . arguments)
   |$(type function)
   |$(derivation (wrap (vau arguments #ignore arguments)))
   |#
  %list )

(def list*
  #|Return a list of evaluated ARGUMENTS so that
   |the last argument becomes the `cdr' of the list.
   |$(fn . arguments)
   |$(type function)
   |#
  %list* )

(def newBox
  #|Return a new box with the optional VALUE.
   |The Box are functions that encapsulates a mutable value.
   |Calling the box without arguments returns the value in the box.
   |Calling the box with an attribute update the value in the box.
   |$(fn)
   |$(fn value)
   |$(type function)
   |#
  %newBox )

(def null?
  #|Return true if the OBJECT is #null, false otherwise.
   |$(fn object)
   |$(type function)
   |$(derivation (\ (object) (type? object Null)))
   |#
  %null? )

(def quote
  #|Return the unevaluated OPERAND.
   |$(fn operand)
   |$(type fexpr)
   |$(derivation (vau (operand) #ignore operand))
   |#
  %' )


;;; Macro

(def evalMacro (newBox #t))

(def makeMacro
  #|Return a macro from an EXPANDER operator.
   |A macro is an operator that receives an operand and produces a form
   |(by calling the expander with the operand as argument)
   |that is then evaluated in place of the operand.
   |$(fn expander)
   |$(type function)
   |#
  (wrap
    (vau (expander) #ignore
      (vau operands env
        (def evalMacro (evalMacro :prv #t))
        (def exp (apply expander operands))
        (if evalMacro (eval exp env) exp) ))))

(def macro
  #|Return an anonymous macro with the given PARAMETER-TREE and FORMS as body.
   |$(fn parameterTree . forms)
   |$(type macro)
   |#
  (makeMacro
    (vau (pt . forms) #ignore
      (list 'makeMacro (list* 'vau pt #ignore forms)) )))

(def expand
  #|Expands a macro rather than evaluates it.
   |$(fn form)
   |$(type macro)
   |#
  (macro (form)
    (list 'begin (list 'evalMacro #f) form) ))


;;; Definition Forms

#|!
 |defMacro defVau def\ def*\ rec\ let1\ let1rec\ let\ and letrec\ have two equivalent forms
 |
 |    (_ name parameterTree . forms)
 |    (_ (name . parameterTree) . forms)
 |
 |rec rec\ let1rec let1rec\ letrec and letrec\ pre-initialize all bindings to #inert before evaluating values.
 |#

(def defMacro
  #|Defines the named macro NAME with the given PARAMETER-TREE and FORMS as body into the current environment.
   |$(fn name parameterTree . forms)
   |$(fn (name parameterTree) . forms)
   |$(type macro)
   |#
  (macro (lhs . rhs)
    (if (cons? lhs)
      (list 'def (car lhs) (list* 'macro (cdr lhs) rhs))
      (list 'def lhs (cons 'macro rhs)) )))

(defMacro (defVau lhs . rhs)
  #|Defines the named fexpr NAME with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER and FORMS as body into the current environment.
   |$(fn name parameterTree . forms)
   |$(fn (name parameterTree) . forms)
   |$(type macro)
   |#
  (if (cons? lhs)
    (list 'def (car lhs) (list* 'vau (cdr lhs) rhs))
    (list 'def lhs (cons 'vau rhs)) ))

(def defConstant
  #|Define a constant with the given NAME and VALUE into the current environment.
   |This is mostly for documentation purposes, as constants are still mutable.
   |alias for def.
   |#
  def )

(defMacro (def* lhs . rhs)
  #|Match the DEFINIEND-TREE against the VALUES and define resulting bindings into the current environment.
   |$(fn definiendTree . values)
   |$(type macro)
   |#
  (list 'def lhs (cons 'list rhs)) )

(defMacro (def\ lhs . rhs)
  #|Defines the named function NAME with the given PARAMETER-TREE and FORMS as body into the current environment.
   |$(fn name parameterTree . forms)
   |$(fn (name parameterTree) . forms)
   |$(type macro)
   |#
  (if (cons? lhs)
    (list 'def (car lhs) (list* '\ (cdr lhs) rhs))
    (list 'def lhs (cons '\ rhs)) ))


;;; Other Core Built-Ins

(def apply*
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn fun . args) 
   |$(type function)
   |$(derivation (apply fun args (newEnv)))
   |#
  %apply* )

(def apply**
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn fun . args)
   |$(type function)
   |$(derivation (apply fun (apply list* args) (newEnv)))
   |#
  %apply** )

(defVau set (ep dt value) env
  #|Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT, creating or updating existing bindings.
   |Unlike Common Lisp `setq' (or Scheme `set!') that allows updating arbitrary bindings
   |you always need to know the environment where a binding is in to change it.
   |Therefore, we usually use boxes instead of mutating bindings directly.
   |$(fn ep dt value)
   |$(type fexpr)
   |#
  (eval
    (list 'def dt (list (unwrap eval) value env))
    (eval ep env) ))

(def set!
  #|Update the bindings defined of the environment, throws an error if the binding is not defined.
   |So 'def' match the DEFINIEND-TREE against the VALUE and update the resulting bindings into environment if exist.
   |without bindResult or with bindResult #ignore use as bindResult (bndRes)
   |with bindResult #inert return #inert
   |with bindResult :rhs return the right side of the last binding
   |with bindResult :prv return the previous value of the last binding
   |with bindResult :obj return the env
   |$(fn definiendTree value)
   |$(fn definiendTree bindResult value)
   |$(syntax bindResult (or #ignore #inert :rhs :prv))  
   |$(type fexpr)
   |#
  %set! )

(def unwrap
  #|Return the underlying operator of a FUNCTION.
   |$(fn function)
   |$(type function)
   |#
  %unwrap )

(defMacro (wrau pt ep . forms)
  #|Return an anonymous function with the given PARAMETER-TREE and FORMS as body.
   |which accesses the execution environment rather than the definition environment.
   |Useful for defining the primitive for dynamically-scoped variables.
   |$(fn pt ep . forms)
   |$(type function)
   |#
  (list 'wrap (list* 'vau pt ep forms)) )


;;; Env

#|! 
 |The Env are functions that encapsulates mutable values.
 |Calling the env:
 |- without arguments returns the env.
 |- with an attribute return the value of the attribute in the env.
 |- with couples of attribute and value defines or update the attribute with the value in the env.
 |- without bindResult or with bindResult #ignore use as bindResult (bndRes)
 |- with bindResult #inert return #inert
 |- with bindResult :rhs return the right side of the last binding
 |- with bindResult :prv return the previous value of the last binding
 |- with bindResult :obj return the env
 |- without bindType use the bindType :def
 |- with bindType :def define or update the bindings in the env
 |- with bindType :set! update the bindings in env, throws an error if the binding is not defined.
 |
 |$(env)
 |$(env attribute)
 |$(env attribute value . attributes)
 |$(env bindType attribute value . attributes)
 |$(env bindResult attribute value . attributes)
 |$(env bindType bindResult attribute value . attributes)
 |$(syntax attributes (or () (attribute value . attributes)))
 |$(syntax attribute (or Symbol Keyword String))
 |$(syntax bindResult (or #ignore #inert :rhs :prv :obj))  
 |$(syntax bindType (or :def :set!))  
 |#

(def newEnv
  #|Return a new environment with an optional PARENT environment in which bindings are looked up if they are not found.
   |The BINDINGS must be of even length, and alternately contain bindings names (symbols, keywords or string) and values.
   |When called with an obj the obj bindings also become env bindings.
   |$(fn)
   |$(fn parent . bindings)
   |$(fn parent obj)
   |$(syntax parent (or () Env))
   |$(syntax bindings (or () (attribute value . bindings)))
   |$(syntax attribute (or Symbol Keyword String))
   |$(type function)
   |#
  %newEnv )

(def theEnv
  #|Return the current environment.
   |$(fn)
   |$(type fexpr)
   |$(derivation (vau () environment environment))
   |#
  %theEnv )


;;; Obj

#|! 
 |The Obj are functions that encapsulates mutable values.
 |Calling the obj:
 |- without arguments returns the env.
 |- with an attribute return the value of the attribute in the obj.
 |- with couples of attribute and value defines or update the attribute with the value in the obj.
 |- without bindResult or with bindResult #ignore use as bindResult (bndRes)
 |- with bindResult #inert return #inert
 |- with bindResult :rhs return the right side of the last binding
 |- with bindResult :prv return the previous value of the last binding
 |- with bindResult :obj return the obj
 |
 |$(obj)
 |$(obj attribute)
 |$(obj attribute value . attributes)
 |$(obj bindResult attribute value . attributes)
 |$(syntax attributes (or () (attribute value . attributes)))
 |$(syntax attribute (or Symbol Keyword String))
 |$(syntax bindResult (or #ignore #inert :rhs :prv :obj))  
 |#

(def new
  #|Return a new instance of CLASS (that must be a `standard-class').
   |The BINDINGS must be of even length, and alternately contain bindings names (symbols, keywords or string) and values.
   |$(fn boxClass)
   |$(fn boxClass value)
   |$(fn objClass . bindings)
   |$(fn objClass string . bindings)
   |$(fn objClass string throwableObject . bindings)
   |$(syntax bindings (or () (attribute value . bindings)))
   |$(syntax attribute (or Symbol Keyword String))
   |#
  %new )

(defMacro (defObj name class . attr)
  #|Define a new instance of CLASS with the given NAME into the current environment.
   |$(fn name boxClass)
   |$(fn name boxClass value)
   |$(fn name objClass . bindings)
   |$(fn name objClass string . bindings)
   |$(fn name objClass string throwableObject . bindings)
   |$(syntax bindings (or () (attribute value . bindings)))
   |$(syntax attribute (or Symbol Keyword String))
   |$(type macro)
   |#
  (list 'def name (list* 'new class attr)) )


;;; Env & Obj

(def bound?
  #|Return true if the SYMBOL or KEYWORD or STRING is bound in the ENVIRONMENT or OBJ, false otherwise.
   |$(fn attribute object)
   |$(syntax attribute (or Symbol Keyword String))
   |$(syntax object (or Env Obj))
   |$(type function)
   |$(derivation (@isBound object attribute))
   |#
  %bound? )

(def value
  #|Return the value of SYMBOL or KEYWORD or STRING is bound in the ENVIRONMENT or OBJ, #null otherwise.
   |$(fn attribute object)
   |$(syntax attribute (or Symbol Keyword String))
   |$(syntax object (or Env Obj))
   |$(type function)
   |$(derivation (@value object attribute))
   |#
  %value )

(def\ slotBound? (object attribute)
  #|Return true if the SYMBOL or KEYWORD or STRING is bound in the ENVIRONMENT or OBJ, false otherwise.
   |$(fn object attribute)
   |$(syntax object (or Env Obj))
   |$(syntax attribute (or Symbol Keyword String))
   |$(type function)
   |$(derivation (@isBound object attribute))
   |#
  (%slotBound? object attribute) )

(def\ getSlot (object attribute)
  #|Return the value of SYMBOL or KEYWORD or STRING is bound in the ENVIRONMENT or OBJ, throws an error otherwise.
   |$(fn object attribute)
   |$(syntax object (or Env Obj))
   |$(syntax attribute (or Symbol Keyword String))
   |$(type function)
   |$(derivation (object attribute))
   |#
  (%getSlot object attribute) )

(def\ setSlot (object attribute value)
  #|Update the value of SYMBOL or KEYWORD or STRING in the ENVIRONMENT or OBJ to VALUE.
   |$(fn object attribute value)
   |$(syntax object (or Env Obj))
   |$(syntax attribute (or Symbol Keyword String))
   |$(type function)
   |$(derivation (object attribute value))
   |#
  (%setSlot object attribute value) )


;;; Cons

(def\ (caar x)
  #|Return the `car' of the `car' of the CONS.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ (((caar . #_) . #_)) caar))
   |$(derivation (car (car cons)))
   |#
  (car (car x)) )

(def\ (cadr! (#_ cadr))
  #|Return the `car' of the `cdr' of the CONS if 'cddr' is null, else error.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ ((#_ cadr)) cadr))
   |#
  cadr)

(def\ (cdar x)
  #|Return the `cdr' of the `car' of the CONS.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ (((#_ . cdar) . #_)) cdar))
   |$(derivation (cdr (car cons)))
   |#
  (cdr (car x)) )

(def cddr
  #|Return the `cdr' of the `cdr' of the CONS.
   |$(fn cons)
   |$(type function)
   |$(derivation (\ ((#_ #_ . cddr)) cddr))
   |$(derivation (cdr (cdr cons)))
   |$(derivation (@cdr cons 1))
   |#
  %cddr)

(def\ (cons! car)
  #|Return a cons with the given CAR and #null.
   |$(fn car)
   |$(type function)
   |$(derivarion (cons car))
   |#
  (cons car))

(def nth
  #|Return element number N of LIST, where the `car' is element zero.
   |$(fn n list)
   |$(type function)
   |#
  %nth)

(def nthCdr
  #|Returns the tail of LIST that would be obtained by calling `cdr' N times in succession.
   |$(fn n list)
   |$(type function)
   |#
  %nthCdr)


;;; List

(def append
  #|Append two lists. The first one must be proper and is copied.
   |The second one is not copied (and doesn't even have to be a list).
   |It becomes the `cdr' of the final cons of the first list,
   |or is returned directly if the first list is empty.
   |$(fn list1 list2)
   |$(type function)
   |#
  %append)

(def len
  #|Return the number of elements in the LIST.
   |$(fn list)
   |$(type function)
   |#
  %len)

(def list?
  #|Return true if the OBJECT is a list, false otherwise.
   |$(fn object)
   |$(type function)
   |$(derivation (\ (object) (type? object Keyword)))
   |#
  %list?)

(def reverse
  #|Reverse the LIST.
   |$(fn list)
   |$(type function)
   |#
  %reverse)


;;; Symbol & Keyword

;;!Symbol and Keyword extends Intern

(def intern
  #|Return the unique symbol or keyword with STRING as name.
   |Keyword if STRING start with ':', symbol otherwise
   |$(fn string)
   |$(type function)
   |#
  %intern)

(def name
  #|Return the name of the SYMBOL or KEYWORD as a string.
   |$(fn intern)
   |$(type function)
   |#
  %name)
  
(def keyword
  #|Return the unique keyword with STRING as name.
   |$(fn string)
   |$(type function)
   |#
  %keyword)

(def keyword?
  #|Return true if the OBJECT is a keyword, false otherwise.
   |$(fn object)
   |$(type function)
   |$(derivation (\ (object) (type? object Keyword)))
   |#
  %keyword?)

(def\ (keywordName (#! Keyword keyword))
  #|Return the name of the KEYWORD as a string.
   |$(fn keyword)
   |$(type function)
   |#
  (name keyword) )

(def symbol
  #|Return the unique symbol with STRING as name.
   |$(fn string)
   |$(type function)
   |#
  %symbol)

(def symbol?
  #|Return true if the OBJECT is a symbol, false otherwise.
   |$(fn object)
   |$(type function)
   |$(derivation (\ (object) (type? object Symbol)))
   |#
  %symbol?)

(def\ (symbolName (#! Symbol symbol))
  #|Return the name of the SYMBOL as a string.
   |$(fn symbol)
   |$(type function)
   |#
  (name symbol) )


;;; Equals

(def ==
  #|Return true if A istanceof Number && A equals B || A == B, false otherwise.
   |$(fn a b)
   |$(type function)
   |#
  %==)

(def !=
  #|Return false if A istanceof Number && A equals B || A == B, thrue otherwise.
   |$(fn a b)
   |$(type function)
   |#
  %!=)

(def eq?
  #|Return true if A is equals B, false otherwise.
   |$(fn a b)
   |$(type function)
   |#
  %eq?)

(def\ (ignore? o) (== o #_))
(def\ (sheBang? o) (== o #!))
(def\ (inert? o) (== o #inert))


;;; Boolean

(def !
  #|Invert the BOOLEAN.
   |$(fn boolean)
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  %!)

(def not
  #|Alias of !.
   |#
  !)

(def !!
  #|Convert a VALUE to boolean when tTrue != 0.
   |$(fn value)
   |$(type function)
   |$(derivation (if value #t #f))
   |#
  %!!)


;;; Number

(def number?
  #|Return true if the OBJECT is a number, false otherwise.
   |$(fn object)
   |$(type function)
   |$(derivation (\ (object) (type? object Number)))
   |#
  %number?)

(def +
  #|Java binary + operator, sums the values after the conversion of the operands to the same type.
   |Converts to BigDecimal, Double, BigInteger, Long or Integer if one operands is BigDecimal, Double, BigInteger, Long or Integer
   |$(fn a b)
   |$(type function)
   |#
  %+)

(def *
  #|Java binary - operator, multiplies the values after the conversion of the operands to the same type.
   |Converts to BigDecimal, Double, BigInteger, Long or Integer if one operands is BigDecimal, Double, BigInteger, Long or Integer
   |$(fn a b)
   |$(type function)
   |#
  %*)

(def -
  #|Java binary - operator, subtracts the values after the conversion of the operands to the same type.
   |Converts to BigDecimal, Double, BigInteger, Long or Integer if one operands is BigDecimal, Double, BigInteger, Long or Integer
   |$(fn a b)
   |$(type function)
   |#
  %-)

(def /
  #|Java binary / operator, divides the values after the conversion of the operands to the same type.
   |Converts to BigDecimal, Double, BigInteger, Long or Integer if one operands is BigDecimal, Double, BigInteger, Long or Integer
   |$(fn a b)
   |$(type function)
   |#
  %/)

(def %
  #|Java binary % operator, rest of the division of the values after the conversion of the operands to the same type.
   |Converts to BigDecimal, Double, BigInteger, Long or Integer if one operands is BigDecimal, Double, BigInteger, Long or Integer
   |$(fn a b)
   |$(type function)
   |#
  %%)

(def\ (1+ n) (+ n 1))
(def\ (1- n) (- n 1))
(def\ (0? n) (== n 0))
(def\ (1? n) (== n 1))
(def\ (-1? n) (== n -1))
(def\ (even? n) (== (% n 2) 0))
(def\ (odd? n)  (== (% n 2) 1))


;;; String

(def string?
  #|Return true if the OBJECT is a string, false otherwise.
   |$(fn object)
   |$(type function)
   |$(derivation (\ (object) (type? object String)))
   |#
  %string?)

(def $
  #|Java binary + operator, join the values after the conversion of the operands to string.
   |$(fn a b)
   |$(type function)
   |#
  %$)


;;; Comparators

(def <
  #|Java binary < operator.
   |$(fn a b)
   |$(type function)
   |#
  %<)

(def >
  #|Java binary > operator.
   |$(fn a b)
   |$(type function)
   |#
  %>)

(def <=
  #|Java binary <= operator.
   |$(fn a b)
   |$(type function)
   |#
  %<=)

(def >=
  #|Java binary >= operator.
   |$(fn a b)
   |$(type function)
   |#
  %>=)

(def\ (min a b) (if (< a b) a b))
(def\ (max a b) (if (> a b) a b))


;;; Bitwise and Shift Operators

(def ~
  #|Java binary ~ operator.
   |$(fn a b)
   |$(type function)
   |#
  %~)

(def &
  #|Java binary & operator.
   |$(fn a b)
   |$(type function)
   |#
  %&)

(def \|
  #|Java binary | operator.
   |$(fn a b)
   |$(type function)
   |#
  %|)

(def ^
  #|Java binary ^ operator.
   |$(fn a b)
   |$(type function)
   |#
  %^)

(def <<
  #|Java binary << operator.
   |$(fn a b)
   |$(type function)
   |#
  %<<)

(def >>
  #|Java binary >> operator.
   |$(fn a b)
   |$(type function)
   |#
  %>>)

(def >>>
  #|Java binary >>> operator.
   |$(fn a b)
   |$(type function)
   |#
  %>>>)


;;; First-Order Controls

(def* (then else)
  #|Alias of begin.
   |#
  begin begin )

(def loop
  #|Evaluate the FORMS as an implicit `begin' in an infinite loop.
   |$(fn . forms)
   |$(type fexpr)
   |#
  %loop)

(def atEnd
  #|Evaluate the PROTECTED-FORMS as an implicit `begin' and return its result.
   |Regardless of whether the protected form returns normally, or via a nonlocal exit or panic,
   |the CLEANUP-FORM are evaluated after the protected forms.
   |$(fn cleanupForm . protectedForms)
   |$(type fexpr)
   |#
  %atEnd)

(defMacro (finally protected . cleanUp)
  #|Evaluate the PROTECTED-FORM and return its result.
   |Regardless of whether the protected form returns normally, or via a nonlocal exit, or panic,
   |the CLEANUP-FORMS are evaluated as an implicit `begin' after the protected forms.
   |$(fn protectedForm . cleanupForms)
   |$(type macro)
   |$(derivation (list 'atEnd (cons 'begin cleanupForms) protectedForm)
   |#
  (list 'atEnd (cons 'begin cleanUp) protected) )  

(def throwTag
  #|Abort to a nesting catch TAG established by `catch', evaluate FORMS as an implicit `begin' and return its result.
   |$(fn tag . forms)
   |$(type fexpr)
   |#
  %throwTag)

(defMacro (throw . forms)
  #|Abort to a nesting generic catch, evaluate FORMS as an implicit `begin' and return its result.
   |$(fn . forms)
   |$(type fexpr)
   |$(derivation (list* 'throwTag #ignore forms))
   |#
  (list* 'throwTag #_ forms) )

(def catchTagWth
  #|Establish a catch TAG with an HANDLER (one arg function or any value) and evaluate FORMS as an implicit `begin' and return its result.
   |The FORMS may use `throw' to nonlocally exit from the TAG. if FORMS throw and HANDLER is a value, value will be the result of `catchTagWth'
   |otherwise the value of the `throw' is passed to the HANDLER and the value returned by the HANDLER will be the result of the `catchTagWth'
   |$(fn tag handler . forms)
   |$(type (if (ctApv) macro fexpr))
   |#
  (if (ctApv) ;; ctApv non andrebbe cambiato dopo il boot, anche la riassegnazione di catchTagWth potrebbe non bastare!
    (macro (tag hdl . forms)
      (list '%catchTagWth tag hdl (list* '\ () forms)) )
    %catchTagWth ))

(defMacro (catchWth hdl . forms)
  #|Establish an generic catch all with HANDLER (one arg function or any value) and evaluate FORMS as an implicit `begin' and return its result.
   |The FORMS may use `throw' to nonlocally exit. if FORMS throw and HANDLER is a value, value will be the result of `catchWth'
   |otherwise the value of the `throw' is passed to the HANDLER and the value returned by the HANDLER will be the result of the `catchWth'
   |$(fn handler . forms)
   |$(type macro)
   |$(derivation (list* 'catchTagWth #ignore handler forms))
   |#
  (list* 'catchTagWth #_ hdl forms))

(defMacro (catchTag tag . forms)
  #|Establish a catch TAG without handler and evaluate FORMS as an implicit `begin' and return its result.
   |The FORMS may use `throw' to nonlocally exit from the tag. if FORMS throw the value returned by the `throw' will be the result of the `catchTag'
   |$(fn tag . forms)
   |$(type macro)
   |$(derivation (list* 'catchTagWth tag #ignore forms))
   |#
  (list* 'catchTagWth tag #_ forms) )

(defMacro (catch . forms)
  #|Establish an generic catch all without handler and evaluate FORMS as an implicit `begin' and return its result.
   |The FORMS may use `throw' to nonlocally exit. if FORMS throw the value returned by the `throw' will be the result of the `catch'
   |$(fn . forms)
   |$(type macro)
   |$(derivation (list* 'catchTagWth #ignore #ignore forms))
   |#
  (list* 'catchTagWth #_ #_ forms))


;;; Delimited-Control Operators

;;!These operators follow the API put forth in the delimcc library at URL `http://okmij.org/ftp/continuations/implementations.html'.

(def takeSubcont
  #|Abort outwards to the PROMPT.
   |When the prompt is reached, evaluate the FORMS as an implicit `begin' with SYMBOL bound to the captured continuation (which does not include the prompt) and return its result.
   |$(fn prompt symbol . forms)
   |$(type fexpr)
   |#
  %takeSubcont)

(def pushPrompt
  #|Push the PROMPT and evaluate the FORMS as an implicit `begin' inside the prompt and return its result.
   |This delimits the continuation.
   |$(fn prompt . forms)
   |$(type fexpr)
   |#
  %pushPrompt)

(def pushDelimSubcont
  #|Push the PROMPT and compose the previously captured CONTINUATION inside it 
   |before evaluated the FORMS as an implicit `begin' inside the new continuation and return its result.
   |$(fn prompt continuation . forms)
   |$(type fexpr)
   |#
  %pushDelimSubcont)

(defMacro (pushSubcont continuation . forms)
  #|We don't have `pushSubcont' but we can emulate it with a `pushDelimSubcont' that pushes an #ignore prompt.
   |$(fn continuation . forms)
   |$(type macro)
   |$(derivation (list* 'pushDelimSubcont #ignore continuation forms))
   |#
  (list* 'pushDelimSubcont #_ continuation forms) )

(def pushSubcontBarrier
  #|Push a continuation barrier that prevents the FORMS from capturing any continuations to the outside,
   |before evaluated the FORMS as an implicit `begin'
   |$(fn . forms)
   |$(type fexpr)
   |#
  %pushSubcontBarrier)


;;; Errors

(def rootPrompt
  #|The prompt used for delimiting all.
   |#
  %rootPrompt)

(def\ makeTypeError (datum expected)
  #|Return a new type error with DATUM and EXPECTED.
   |$(fn datum expected)
   |$(type function)
   |#
  (new Error "not a {expected}: {datum}" :type 'type :datum datum :expected expected) )

(def\ typeError (datum expected)
  #|Signal a type error with DATUM and EXPECTED.
   |$(fn datum expected)
   |$(type function)
   |#
  (error (makeTypeError datum expected)) )


;;; Classes

(def className
  #|Return the name symbol of the CLASS.
   |$(fn class)
   |$(type function)
   |$(derivation (symbol (@getSimpleName class)))) 
   |#
  %className)

(def classOf
  #|Return the class of the OBJECT.
   |$(fn object)
   |$(type function)
   |$(derivation (if (null? object) #null (@getClass object))) 
   |#
  %classOf)

(def instanceOf? %instanceOf?)

(def subClass?
  #|Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.
   |A class is considered a subclass of itself.
   |$(fn class superclass)
   |$(type function)
   |$(derivation (@isAssignableFrom superClass class))) 
   |#
  %subClass?)

(def type?
  #|Return true if the OBJECT is an instance of the CLASS, false otherwise.
   |$(fn object class)
   |$(type function)
   |$(derivation (if (null? class) (null? object) (null? object) #f (subClass? (classOf object) class))) 
   |#
  %type?)


;;; Basic Functions and Macros

(def\ (idf x)
  #|Identity function.
   |$(fn object)
   |$(type function)
   |#
  x)

(defMacro _ forms
  #|"Implicit" Argument Lambda.
   |$(fn . forms)
   |$(type macro)
   |$(derivation (list* '\ '(_) forms))
   |#
  (list* '\ '(_) forms) )

(def\ (peval f v)
  #|Single arg partial evaluation.
   |$(fn f v)
   |$(type function)
   |$(derivation (\ args (apply f (cons v args))))
   |#
  (\ args (apply f (cons v args))) )

(def\ (peval* f . v*)
  #|Multiple args partial evaluation.
   |$(fn f v*)
   |$(type function)
   |$(derivation (\ args (apply f (append v* args))))
   |#
  (\ args (apply f (append v* args))) )

(def\ (compose f g)
  #|Compose two functions, creating a new function equivalent to (f (g . args)).
   |$(fn f g)
   |$(type function)
   |$(derivation (\ args (f (apply g args))))
   |#
  (\ args (f (apply g args))) )

(def\ (compose* . f*)
  #|Compose multiple functions, creating a new function equivalent to (f1 (f2 (... (fn . args)))).
   |$(fn . f*)
   |$(type function)
   |#
  (\ args ((rec\ (loop (f . f*)) (if (null? f*) (apply f args) (f (loop f*)))) f*)) )

;(defMacro compose* f* 
;  (list '\ 'args ((rec\ (loop (f . f*)) (if (null? f*) (list 'apply f 'args) (list f (loop f*)))) f*)) )

(defMacro (rec name value)
  #|Return VALUE, after lexically bind NAME with #inert,
   |and update NAME with VALUE so that it can reference itself.
   |$(fn name value)
   |$(type macro)
   |#
  (list (list '\ (list name) (list 'def name :rhs value)) #inert) )

(def label
  #|Alias of rec.
   |#
  rec )

(defMacro (rec\ lhs . rhs)
  #|Return the function with given PARAMETER-TREE and FORMS as body, after lexically bind NAME with #inert,
   |and updated NAME with the function so that it can reference to itself.
   |$(fn name parameterTree . forms)
   |$(fn (name . parameterTree) . forms)
   |$(type macro)
   |#
  (if (cons? lhs)
    (list 'rec (car lhs) (list* '\ (cdr lhs) rhs))
    (list 'rec lhs (cons '\ rhs)) ))

(def label\
  #|Alias of rec\.
   |#
  rec\ )

#|
Some importanti equivalences
apply: (eval (cons opv args) env) <=> (apply opv args env)
apply: (eval (cons apv args) env) <=> (apply apv (evlis env args) env)
evlis: (eval (cons 'list args) env) <=> (map (\ (arg) (eval arg env)) args)
|#

(def\ (map f lst . lst*)
  #|Return a new list by applying the FUNCTION to each element of the LIST or the LISTS which must be of the same length
   |$(fn function list)
   |$(fn function list1 list2 ... listN)
   |$(type function)
   |#
  (if (null? lst*)
    ((rec\ (map lst) (if (null? lst) #null (cons (f (car lst)) (map (cdr lst))) )) lst)
    ((rec\ (map* lst*) (if (null? (car lst*)) #null (cons (apply f (map car lst*)) (map* (map cdr lst*))) )) (cons lst lst*)) ))

(defMacro (def*\ lhs* . rhs*)
  #|Define multiple named functions with given PARAMETER-TREES and FORMS as body.
   |Match the DEFINIEND-TREES against the BODIES and define resulting bindings into the current environment.
   |$(fn definiendTrees . bodies)
   |$(fn ((name parameterTree) . definiendTrees) . (forms . bodies))
   |$(fn (name . definiendTrees) . ((parameterTree . forms) . bodies))
   |$(syntax definiendTrees ((name parameterTree) . definiendTrees)
   |$(syntax bodies (forms . bodies)
   |$(syntax definiendTrees (name . definiendTrees)
   |$(syntax bodies ((parameterTree . forms) . bodies)
   |$(type macro)
   |$(example (def*\ ((f a) g) ((1+ a)) ((a) (1+ a))) )
   |#
  (list* 'def*
    (map (\ (lhs) (if (cons? lhs) (car lhs) lhs)) lhs*)
    (map (\ (lhs rhs) (cons '\ (if (cons? lhs) (cons (cdr lhs) rhs) rhs))) lhs* rhs*) ))


;;; Lexical Bindings

(def\ (->begin binding) (cons 'begin (cdr binding)))
(def\ (->name+#inert (lhs . #_)) (list (if (cons? lhs) (car lhs) lhs) #inert))
(def\ (->name+lambda (lhs . rhs)) (if (cons? lhs) (list (car lhs) (list* '\ (cdr lhs) rhs)) (list lhs (cons '\ rhs)) ))


(defMacro (wth1 dt value . forms)
  #|Establish the BINDING, before the evaluation of FORMS as an implicit `begin'.
   |Idea stolen from Anarki https://github.com/arclanguage/anarki :-) 
   |$(fn binding . forms)
   |$(type macro)
   |$(syntax binding . (definiendTree initForm))
   |#
  (list (list* '\ (cons dt) forms) value))

(defMacro (wth* bindings . forms)
  #|Establish BINDINGS serially, so that every binding can refer to previous one,
   |before the evaluation of FORMS as an implicit `begin'.
   |Idea stolen from Anarki https://github.com/arclanguage/anarki :-)
   |$(fn bindings . forms)
   |$(type macro)
   |$(syntax bindings (or () (definiendTree intiForm . bindings)))
   |#
  ( (rec\ (loop bindings)
      (if (null? bindings)
        (cons (list* '\ () forms))
        (wth1 (dt value . bindings) bindings
          (list* 'wth1 dt value (cons (loop bindings))) ))) 
    bindings ))

(defMacro (wth b* . forms)
  #|Establish BINDINGS parallelly, so that no binding can refer to itself or the other ones,
   |before the evaluation of FORMS as an implicit `begin'.
   |Idea stolen from Anarki https://github.com/arclanguage/anarki :-)
   |$(fn bindings . forms)
   |$(fn name bindings . forms)
   |$(type macro)
   |$(syntax bindings (or () (definiendTree initForm . bindings))
   |#
  (def dt* ((rec\ (loop b*) (if (null? b*) #null (wth1 (dt #_ . b*) b* (cons dt (loop b*))))) b*))
  (def vl* ((rec\ (loop b*) (if (null? b*) #null (wth1 (#_ vl . b*) b* (cons vl (loop b*))))) b*))
  (cons (list* '\ dt* forms) vl*) )


(defMacro (let1Loop lhs . rhs)
  #|Labelled recursive loop.
   |Lexically bind NAME with the function with the specified PARAMETER-TREE and FORMS as body,
   |so that it can recursively refer to itself.
   |The function is immediately applied to the list containing the value of the INIT_FORMS evaluate as an implicit `begin',
   |and then FORMS is evaluate as an implicit `begin'.
   |$(fn name binding . forms)
   |$(fn (name . binding) . forms)
   |$(type macro)
   |$(syntax binding (parameterTree . initForms))
   |#
  (if (cons? lhs)
    (def* ((name . binding) forms) lhs rhs)
    (def* (name (binding . forms)) lhs rhs) )
  (list
    (list* 'rec\ name (cons (car binding)) forms)
    (->begin binding) ))


(defMacro (let1 lhs . rhs)
  #|Establishes the BINDING, before the evaluation of FORMS as an implicit `begin'.
   |The INIT_FORMS is evaluate as an implicit `begin'.
   |If the first argument is a symbol is like 'let1Loop'.
   |$(fn binding . forms)
   |$(fn name binding . forms)
   |$(type macro)
   |$(syntax binding (definiendTree . initForms))
   |#
  (if (symbol? lhs)
    (list* 'let1Loop lhs rhs)
    (list (list* '\ (list (car lhs)) rhs)
      (->begin lhs) )))

(defMacro (let1\ binding . forms)
  #|Establishes the FUNCTION-BINDINGS, before the evaluation of FORMS as an implicit `begin'.
   |$(fn functionBinding . forms)
   |$(type macro)
   |$(syntax functionBinding (name parameterTree . bodyForms))
   |$(syntax functionBinding ((name . parameterTree) . bodyForms))
   |#
  (list* 'let1 (->name+lambda binding) forms))

(defMacro (let1rec binding . forms)
  #|Establishes the BINDING recursively so that the binding can recursively refer to itself,
   |before the evaluation of FORMS as an implicit `begin'.
   |The binding is initializated to #inert before evaluating INIT_FORMS as an implicit `begin'. 
   |$(fn binding . forms)
   |$(type macro)
   |$(syntax binding (name . intForms))
   |#
  (def name (car binding))
  (list* 'let1 (list name #inert)
    (list 'def (car name (->begin binding))
      forms )))

(defMacro (let1rec\ binding . forms)
  #|Establishes the FUNCTION-BINDING recursively, so that the function can refer to itself,
   |before the evaluation of FORMS as an implicit `begin'.
   |The binding is initializated to #inert before the bind of the function. 
   |$(fn functionBinding . forms)
   |$(type macro)
   |$(syntax functionBinding (name parameterTree . bodyForms))
   |$(syntax functionBinding ((name . parameterTree) . bodyForms))
   |#
  (list* 'let1 (->name+#inert binding)
    (cons 'def\ binding)
    forms ))


(defMacro (let* bindings . forms)
  #|Establishes BINDINGS serially, so that every binding can refer to previous one,
   |before the evaluation of FORMS as an implicit `begin'.
   |The INIT_FORMS are evaluate as an implicit `begin'.
   |$(fn bindings . forms)
   |$(type macro)
   |$(syntax bindings (or () ((definiendTree . intiForms) . bindings)))
   |#
  ( (rec\ loop (bindings)
      (if (null? bindings)
        (cons (list* '\ () forms))
        (list* 'let1 (car bindings) (cons (loop (cdr bindings)))) ))
    bindings ))


(defMacro (letLoop lhs . rhs)
  #|Labelled recursive loop.
   |Lexically bind NAME with the function with the specified multiple PARAMETER-TREES and FORMS as body,
   |so that it can recursively refer to itself. 
   |The function is immediately applied to the list containing the values of INIT_FORM evaluate as an implicit `begin',
   |and then FORMS is evaluate as an implicit `begin'.
   |$(fn name bindings . forms)
   |$(fn (name . bindings) . forms)
   |$(type macro)
   |$(syntax bindings (or () ((parameterTree . initForms) . bindings)))
   |#
  (if (cons? lhs)
    (def* ((name . bindings) forms) lhs rhs)
    (def* (name (bindings . forms)) lhs rhs) )
  (cons
    (list* 'rec\ name (map car bindings) forms)
    (map ->begin bindings) ))


(defMacro (let lhs . rhs)
  #|Establishes the BINDINGS parallelly, so that no binding can refer to itself or the other ones,
   |before the evaluation of FORMS as an implicit `begin'.
   |The INIT_FORMS are evaluate as an implicit `begin'.
   |If the first argument is a symbol is like 'letLoop'.
   |$(fn bindings . forms)
   |$(fn name bindings . forms)
   |$(type macro)
   |$(syntax bindings (or () ((definiendTree . initForms) . bindings))
   |#
  (if (symbol? lhs)
    (list* 'letLoop lhs rhs)
    (cons (list* '\ (map car lhs) rhs)
      (map ->begin lhs) )))

(defMacro (let\ bindings . forms)
  #|Establishes the FUNCTION-BINDINGS parallelly, so that no function can refer to itself or the other ones,
   |before the evaluation evaluation of FORMS as an implicit `begin'.
   |$(fn functionBindings . forms)
   |$(type macro)
   |$(syntax functionBindings (or () (functionBinding . functionBindings)))
   |$(syntax functionBinding (name parameterTree . bodyForms))
   |$(syntax functionBinding ((name . parameterTree) . bodyForms))
   |#
  (list* 'let (map ->name+lambda bindings) forms))

(defMacro (letrec bindings . forms)
  #|Establishes the BINDINGS recursively, so that the bindings can refer to itself and the other ones,
   |before the evaluation of FORMS as an implicit `begin'.
   |The bindings are initializated to #inert before evaluating the INIT_FORMS as an implicit `begin'.
   |$(fn bindings . forms)
   |$(type macro)
   |$(syntax bindings (or () ((name . intForms) . bindings)))
   |#
  (def names (map car bindings))
  (list* 'let (map (\ (name) (list name #inert)) names)
    (list* 'def* names (map ->begin bindings))
    forms ))

(defMacro (letrec\ bindings . forms)
  #|Establishes the FUNCTION-BINDINGS recursively, so that the functions can refer to itself and the other ones,
   |before the evaluation of FORMS as an implicit `begin'.
   |The bindings are initializated to #inert before the bind of the functions.
   |$(fn functionBindings . forms)
   |$(type macro)
   |$(syntax functionBindings (or () (functionBinding . functionBindings)))
   |$(syntax functionBinding ((name parameterTree . bodyForms) . functionBindings))
   |$(syntax functionBinding (((name . parameterTree) . bodyForms) . functionBindings))
   |#
  (list* 'let (map ->name+#inert bindings)
    (list* 'def*\ (map car bindings) (map cdr bindings))
    forms ))

(def labels
  #|Alias of letrec\.
   |#
  letrec\)


;;; Simple Controls

(defVau prog1 (form . forms) env
  #|Evaluate FORM and return the result after evaluate any additional FORMS as an implicit `begin'.
   |$(fn form . forms)
   |$(type fexpr)
   |#
  (let1 (result (eval form env))
    (apply begin forms env)
    result))

(defMacro (when test . forms)
  #|If TEST yields true, evaluate the FORMS as an implicit `begin', inert otherwise.
   |$(fn test . forms)
   |$(type macro)
   |#
  (list 'if test (cons 'then forms)))

(defMacro (unless test . forms)
  #|If TEST yields false, evaluate the FORMS as an implicit `begin', inert otherwise.
   |$(fn test . forms)
   |$(type macro)
   |#
  (list 'if test #inert (cons 'else forms)))

(defVau && ops env
  #|Return true if all OPERANDS evaluate to true, false otherwise.
   |If an operand evaluates to false, later operands are not evaluated.
   |If there are no operands, return false.
   |$(fn . operands)
   |$(type fexpr)
   |#
  (if
    (null? ops) #t
    (eval (car ops) env) (apply && (cdr ops) env)
    #f ))

(def and
  #|Alias of &&.
   |#
  &&)

(defVau || ops env
  #|Return true if one of the OPERANDS evaluates to true, false otherwise.
   |If an operand evaluates to true, later operands are not evaluated.
   |If there are no operands, return true.
   |$(fn . operands)
   |$(type fexpr)
   |#
  (if
    (null? ops) #f
    (eval (car ops) env) #t
    (apply || (cdr ops) env) ))

(def or
  #|Alias of ||.
   |#
  ||)

(def\ &&f f*
  #|Return a function the return true if all FUNCTIONS evaluate to true when applied to the arguments, false otherwise.
   |If an function evaluates to false, later FUNCTIONS are not evaluated.
   |If there are no FUNCTIONS, when applied return false.
   |Idea stolen from Anarki https://github.com/arclanguage/anarki :-)
   |$(fn . functions)
   |$(type function)
   |#
  (\ args
    ( (rec\ (&&f f*)
        (if
          (null? f*) #t
          (apply (car f*) args) (&&f (cdr f*))
          #f ))
      f* )))  

(def\ ||f f*
  #|Return a function the return true if one FUNCTIONS evaluate to true when applied the the arguments, false otherwise.
   |If an function evaluates to true, later FUNCTIONS are not evaluated.
   |If there are no FUNCTIONS, when applied return true.
   |Idea stolen from Anarki https://github.com/arclanguage/anarki :-)
   |$(fn . functions)
   |$(type function)
   |#
  (\ args
    ( (rec\ (||f f*)
        (if
          (null? f*) #f
          (apply (car f*) args) #t
          (||f (cdr f*)) ))
      f* )))    


;;; Bind Bind? IfBind? CaseVau DefCaseVau Case\ DefCase\ Match Cond

(def bind
  #|return #inert if VALUE match the DEFINIEND-TREE and define resulting bindings into ENVIRONMENT, throws an error otherwise.
   |$(fn environment definiendTree value)
   |$(type function)
   |#
  %bind)

(def bind?
  #|return true if VALUE match the DEFINIEND-TREE and define resulting bindings into ENVIRONMENT, false otherwise. 
   |$(fn environment definiendTree value)
   |$(type function)
   |#
  %bind?)

(defVau (ifBind? (pt exp) then . else) env
  #|return the evaluation of THEN into resulting ENVIRONMENT if VALUE match the DEFINIEND-TREE, inert otherwise. 
   |$(fn (definiendTree value) then . forms)
   |$(type fexpr)
   |#
  (let1 (env+ (newEnv env))
    (if (bind? env+ pt (eval exp env))
      (eval then env+)
      (unless (null? else)
        (eval (car! else) env) ))))

(defVau (caseVau . clauses) env
  #|Multi-armed vau.
   |Go through the CLAUSES in order.
   |If CLAUSES in null return #inert.
   |If car of CLAUSE is else
   |  if the cadr of CLAUSES is =>, evaluate caddr of CLAUSE and apply it to the operands,
   |  otherwise evaluate FORMS as an implicit `begin'.
   |If the operands match the DEFINIEND-TREE evaluate FORMS as an implicit `begin' into resulting ENVIRONMENT.
   |Otherwise go to the next CLAUSE.
   |$(fn . clauses)
   |$(type fexpr)
   |$(syntax clauses (or () (clause . clauses)))
   |$(syntax clause (else . forms))
   |$(syntax clause (else => apv1))
   |$(syntax clause (definiendTree . forms))
   |#
  (vau values #ignore
    (let1 loop (clauses clauses)
      (unless (null? clauses)
        (let1 (((dt . forms) . clauses) clauses)
          (if (== dt 'else)
            (if (== (car forms) '=>)
              ((eval (cadr! forms) env) values)
              (apply begin forms env) )
            (let1 (env+ (newEnv env)) 
              (if (bind? env+ dt values)
                (apply begin forms env+)
                (loop clauses) ))))))))

(defMacro (defCaseVau name . clauses)
  #|Defines the named caseVau NAME with the given CLAUSES into the current environment.
   |$(fn name . clauses)
   |$(type fexpr)
   |$(derivation (list 'def name (cons 'caseVau clauses)))
   |#
  (list 'def name (cons 'caseVau clauses)) )

(defMacro (case\ . clauses)
  #|Multi-armed \.
   |Go through the CLAUSES in order.
   |If CLAUSES in null return #inert.
   |If car of CLAUSE is else
   |  if the cadr of CLAUSES is =>, evaluate caddr of CLAUSE and apply it to the arguments,
   |  otherwise evaluate FORMS as an implicit `begin'.
   |If the arguments match the DEFINIEND-TREE evaluate FORMS as an implicit `begin' into resulting ENVIRONMENT.
   |Otherwise go to the next CLAUSE.
   |$(fn . clauses)
   |$(type function)
   |$(syntax clauses (or () (clause . clauses)))
   |$(syntax clause (else . forms))
   |$(syntax clause (else => apv1))
   |$(syntax clause (definiendTree . forms))
   |$(derivation (list 'wrap (cons 'caseVau clauses)))
   |#
  (list 'wrap (cons 'caseVau clauses)) )

(defMacro (defCase\ name . clauses)
  #|Defines the named case\ NAME with the given CLAUSES into the current environment.
   |$(fn name . clauses)
   |$(type fexpr)
   |$(derivation (list 'def name (cons 'case\ clauses)))
   |#
  (list 'def name (cons 'case\ clauses)) )

(defMacro (match exp . clauses)
  #|Evaluates VALUE and go through the CLAUSES in order.
   |If CLAUSES in null return #inert.
   |If car of CLAUSE is else
   |  if the cadr of CLAUSES is =>, evaluate caddr of CLAUSE and apply it to the arguments,
   |  otherwise evaluate FORMS as an implicit `begin'.
   |If VALUE match the DEFINIEND-TREE evaluate FORMS as an implicit `begin' into resulting ENVIRONMENT.
   |Otherwise go to the next CLAUSE.
   |$(fn value . clauses)
   |$(type fexpr)
   |$(syntax clauses (or () (clause . clauses)))
   |$(syntax clause (else . forms))
   |$(syntax clause (else => apv1))
   |$(syntax clause (definiendTree . forms))
   |$(derivation (list 'wrap (cons 'caseVau clauses)))
   |#
  (list (cons 'case\ (map (\ ((a . b)) (list* (if (== a 'else) a (list a)) b)) clauses)) exp) )

(defVau (cond . clauses) env
  #|Multi-armed conditional.
   |Go through the CLAUSES in order.
   |If CLAUSES is null return #inert.
   |If car of CLAUSE is else evaluate FORMS as an implicit `begin'.
   |Otherwise evaluate the TEST.
   |If TEST is a boolean
   |  if is true, evaluate the FORMS as an implicit `begin',
   |  otherwise go to the next CLAUSE.
   |If FORMS is null return TEST.
   |If car di FORMS is => evaluate the cadr of FORMS and apply it to TEST.
   |If cadr di FORMS is => evaluate car of FORMS
   |  if is true evaluate the caddr of FORMS and apply it to TEST
   |  otherwise go to the next CLAUSE.
   |Otherwise go to the next CLAUSE.
   |$(fn . clauses)
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (else . forms))
   |$(syntax clause (test->bool . forms))
   |$(syntax clause (test))
   |$(syntax clause (test => apv1))
   |$(syntax clause (test guard => apv1))
   |#
  (unless (null? clauses)
    (let1 (((test . forms) . clauses) clauses)
      (if (== test 'else)
        (apply begin forms env)
        (let1 (test (eval test env))
          (if (instanceOf? test Boolean)
            (if test
              (apply begin forms env)
              (apply cond clauses env) )
            (match forms
              (() test)
              (('=> apv1) ((eval apv1 env) test))
              ((guard '=> apv1)
                 (if ((eval guard env) test)
                   ((eval apv1 env) test)
                   (apply cond clauses env) ))
              (else (apply cond clauses env)) )))))))


;;; Quasiquote

;;!Idea from Alf Petrofsky http://scheme-reports.org/mail/scheme-reports/msg00800.html

(defVau %` (x) env
  #|TODO
   |#
  (defCase\ qq
    ( ((('%,@ x) . y) #f . d) (append (map (\ (x) (list '%,@ x)) (apply** qq (list x) d)) (apply** qq y #f d)) )
    ( ((('%,@ x) . y) . d)    (append (eval x env) (apply** qq y d)) )
    ( ((('%, x) . y) #f . d)  (append (map (\ (x) (list '%, x))  (apply** qq (list x) d)) (apply** qq y #f d)) )
    ( (('%, x) #f . d)        (list '%, (apply** qq x d)) )
    ( (('%, x) . d)           (eval x env) )
    ( (('%` x) . d)           (list '%` (apply** qq x #f d)) )
    ( ((x . y) . d)           (cons (apply** qq x d) (apply** qq y d)) )
    ( (x . d)                 x) )
  (qq x))


;;; Options

;;!An option is either null ("none"), or a one-element list ("some").

(def some
  #|Create a one-element list from the VALUE.
   |Alias of cons!. 
   |#
  cons!)

(defVau (ifOpt (pt opt) then . else) env
  #|Single-value OPTION destructuring.
   |If the evaluation of OPTION it's not null, evaluate the THEN form with the NAME bound to the contents of the OPTION.
   |Otherwise, evaluate the ELSE forms as an implicit `begin'.
   |Idea from Taylor R. Campbell's blag. https://mumble.net/~campbell/blag.txt
   |$(fn (name option) then . else)
   |$(type fexpr)
   |#
  (let1 (opt (eval opt env))
    (if (null? opt)
      (if (null? else) #null
        (eval (cons 'begin else) env))
      (if (list? opt)
        (eval (list* (list 'vau (list pt) #ignore then) opt) env)
        (typeError opt '(or () List)) ))))

(defVau (ifOpt* (pt opt) then . else) env
  #|Multi-valued OPTION destructuring.
   |If the evaluation of OPTION it's not null, evaluate THEN form with the DEFINIEND-TREE bound to OPTION value .
   |Otherwise, evaluate the ELSE forms as an implicit `begin'.
   |$(fn (definiendTree option) then . else)
   |#
  (let1 (opt (eval opt env))
    (if (null? opt)
      (if (null? else) #null
        (eval (cons 'begin else) env))
      (if (list? opt)
        (eval (list* (list 'vau pt #ignore then) opt) env)
        (typeError opt '(or () List)) ))))

(defMacro whenOpt ((pt opt) . forms)
  #|Destructure the OPTION.
   |If the evaluation of OPTION it's not null, evaluate the FORMS as an implicit `begin'. Otherwise, return null
   |with the NAME bound to the contents of the option, and return the result.
   |$(fn (name option) . forms)
   |$(type fexpr)
   |#
  (list 'ifOpt (list pt opt) (if (null? forms) #null (cons 'begin forms))) )

(defMacro unlessOpt (opt . forms)
  #|Destructure the OPTION.
   |If the evaluation of OPTION it's null, evaluate the FORMS as an implicit `begin'. Otherwise, return null.
   |$(fn option . forms)
   |$(type fexpr)
   |#
  (list* 'ifOpt (list #ignore opt) #null (if (null? forms) #null (cons 'begin forms))) )

(defVau (caseOpt opt . clauses) env
  #|Multi-armed ifOpt.
   |Evaluate OPTION and go through the CLAUSES in order.
   |If CLAUSES in null return null.
   |If car of CLAUSE is else evaluate FORMS as an implicit `begin'.
   |If the OPTION match the DEFINIEND-TREE evaluate FORMS as an implicit `begin' into resulting ENVIRONMENT.
   |Otherwise go to the next CLAUSE.
   |$(fn option . clauses)
   |$(type fexpr)
   |$(syntax clauses (or () (clause . clauses)))
   |$(syntax clause (else . forms))
   |$(syntax clause (definiendTree . forms))
   |#
  (let1 (opt (eval opt env))
    (if (null? opt) #null
      (let1 loop (clauses clauses)
        (if (null? clauses) #null
          (let ( (env+ (newEnv env))
                 (((dt . forms) . clauses) clauses) )
            (if (|| (== dt 'else) (bind? env+ dt opt))
              (apply begin forms env+)
              (loop clauses) )))))))

(defVau (optDft opt . dft) env
  #|Return the contents of the OPTION, or the DEFAULT if the option is null.
   |The default itself defaults to #inert.
   |The DEFAULT is evaluated lazily, only when the OPTION is null.
   |$(fn option . default)
   |$(type fexpr)
   |#
  (ifOpt (opt (eval opt env)) opt
    (ifOpt (dft (eval (cons 'list dft) env)) dft) ))

(defVau optDft* (lst . dft) env
  #|Similar to `opt', but provides DEFAULTS for any number of elements of LIST.
   |This is useful for implementing functions that take multiple optDft arguments.
   |Each default is evaluated lazily, only when needed.
   |$(fn list . defaults)
   |$(type fexpr)
   |#
  (let loop ((lst (eval lst env)) (dft dft))
    (if (null? lst)
      (if (null? dft) #null
         (cons (eval (car dft) env) (loop #null (cdr dft))) )
      (if (null? (car lst))
        (if (null? dft)
          (cons #null (loop (cdr lst) #null))
          (cons (eval (car dft) env) (loop (cdr lst) (cdr dft))) )
        (cons (car lst)
          (loop (cdr lst) (if (null? dft) #null (cdr dft)))) ))))

(def\ optDft! (opt)
  #|Returns the contents of the OPTION or signals an error if it is null.
   |$(fn option)
   |$(type fexpr)
   |#
  (optDft opt (simpleError "Option is #null")))


;;; OptValue Member Member? !Member? OptKey Assoc Member*?

(def\ (optValue key lst)
  #|Search for the KEYWORD in the property list LST (a list of alternating keywords and values) and return the found value as an option.
   |#
  (let1 loop (lst lst)
    (if (cons? lst)
      (let1 ((k v . lst) lst)
        (if (== k key) (cons v) (loop lst)) )
      #null )))

(def\ (member k lst . keywords)
  #|Search for ITEM in the LIST according to the TEST predicate (defaults to `==').
   |Return the tail of the list starting withITEM if found, #null otherwise.
   |The KEY function is applied to each list element before comparison (defaults to `idf').
   |$(fn (item list &key test key))
   |#
  (let ( (cmp (optDft (optValue :cmp keywords) ==))
         (key (optDft (optValue :key keywords) idf))
         (ret (optDft (optValue :ret keywords) idf)) )
    (let1 loop (lst lst)
      (if (cons? lst)
        (if (cmp (key (car lst)) k) (ret lst)
          (loop (cdr lst)) )
        #null ))))

(def\ (member? key lst . keywords)
  (cons? (apply** member key lst keywords)) )
  
(def\ (!member? key lst . keywords)
  (null? (apply** member key lst keywords)) )

(def\ (optKey key lst)
  (if (cons? key) ((rec\ (loop lst) (if (cons? lst) (let1 (k (car lst)) (if (member? k key) k (loop (cdr lst)))) #null)) lst)
    (member? key lst) key
    #null ))

(def\ (assoc k lst) 
  (member k lst :key car :ret car) )

(def\ (member*? key . lst)
  (member? key lst) )


;;; Case MatchObj? CaseType CaseType\

(defVau (case exp . clauses) env
  (let1 (value (eval exp env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((values . forms) . clauses) clauses)
          (if (|| (== values 'else) (eq? value values) (member? value values :cmp eq?))
            (if (null? forms) #inert
              (if (== (car forms) '=>)
                ((eval (cadr! forms) env) value)
                (apply begin forms env) ))
            (next clauses) ))))))

(def matchObj? %matchObj?)

(def\ (matchObj*? obj class . slots) 
  (matchObj? obj (cons class slots)) )

; vedi signalsError? in vm.lispx (o test-util.lispx) per codice simile
(defVau (caseType key . clauses) env
  #|Multi-armed type test.
   |Evaluate the KEYFORM. Go through the CLAUSES.
   |If the result of evaluating KEYFORM is an instance of the class named by CLASS-NAME, evaluate the FORMS as an implicit `begin', and return the result.
   |Return #inert if there are no more clauses, go to the next clause otherwise. 
   |$(fn (key . clauses))
   |$(type fexpr)
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (className . forms))
   |$(syntax clause ((className . slotSpecs) . forms))
   |#
  (let1 (key (eval key env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((test . forms) . clauses) clauses)
          (if (|| (== test 'else)
                  (let* ( (symbol? (symbol? test))
                          (class (eval (if symbol? test (car test)) env)) )
                    (if symbol? (type? key class) (matchObj? key (eval (cons 'list test) env))) ))
            (if (== (car forms) '=>)
              ((eval (cadr! forms) env) key)
              (apply begin forms env) )
            (next clauses) ))))))

#|TODO sostituito dal seguente, eliminare
(defMacro (caseType\ (#! Symbol key) . clauses)
  (list '\ (cons key) (list* 'caseType key clauses) ))
|#

(defMacro (caseType\ (#! (1 Symbol) key) . clauses)
  (list '\ key (list* 'caseType (car key) clauses) ))   


;;; Sort

(def\ (sort lst . opt)
  (def cmp (case (optKey (:up :dn) opt) ((#null :up) <) (:dn >=)))
  (def key (optDft (optValue :key opt) idf))
  (def\ (sort lst)  
    (if (<= (len lst) 1) lst
      (let loop ( (left ()) (right ()) (pivot (car lst)) (rest (cdr lst)) )
        (if (null? rest)
            (append (append (sort left) (list pivot)) (sort right))
          (cmp (key (car rest)) (key pivot))
            (loop (append left (list (car rest))) right pivot (cdr rest))
            (loop left (append right (list (car rest))) pivot (cdr rest)) ))))
  (sort lst) )


;;; Checks

(def\ assert#t (boolean)
  #|Signal an error if the BOOLEAN is false or not a boolean, #inert otherwise.
   |#
  (unless boolean (error (new Error "invalid assetion" :type 'assert :datum boolean :expected #t))))

(def\ makeTypeError (datum expected)
  #|Create a `type-error' with the given DATUM and EXPECTED-TYPE.
   |#
  (new Error "not a {expected}: {datum}" :type 'type :datum datum :expected expected) )

(def\ typeError (datum expected)
  #|Signal a `type-error'
   |#
  (error (makeTypeError datum expected)) )

(def the
  #|Signal a `type-error' if the OBJECT is not an instance of the CLASS, else return object.
   |$(fn (class object)
   |$(type function)
   |#
  %the)

(defVau (check o ck) env
  ((wrap %check) (eval o env) ck) )

(defVau (check o ck) env
  (apply %check (list (eval o env) ck) env) )

(defMacro (check* o . cks)
    (list 'check o cks) )

(defVau check? args env
  (catch
    (handlerBind ((Error (\ (#_) (throw #f))))
      (apply check args env)
      #t )))

(defMacro (the+ ck obj) (list 'let1 (list 'obj obj) (list 'check 'obj ck) 'obj))

; TODO non  pi cos costosa la conversione, si pu fare
; (def the the+)


;;; Block Loop For While Until Repeat DoTimes

(defVau block (blockName . forms) env
  #|Establish a block named BLOCK-NAME and evaluate the FORMS as an implicit `begin', and return the result.
   |The forms may use `returnFrom' to nonlocally exit from the block.
   |Note that unlike in Common Lisp, there is no separate namespace for block names;
   |a block is named in the normal variable namespace.
   |#
  (let* ( (tag (cons #inert)) ; cons up a fresh object as tag
          (escape (\ value (throwTag tag (if (cons? value) (car! value))))) )
    (catchTag tag
      (eval (list (list* '\ (list blockName) forms) escape) env) )))

(def\ returnFrom (blockName . value?)
  #|Abort evaluation and return the optional VALUE? (which lsts to #inert) from the block named BLOCK-NAME.
   |It is an error to return from a block whose dynamic extent has ended.
   |$(fn (blockName . value?))
   |#
  (blockName (optDft value? #inert)) )

(defVau while (testForm . forms) env
  #|Evaluate FORMS as an implicit `begin' while TEST-FORM evaluates to true.
   |#
  (let ((forms (cons 'begin forms)))
    (block exit
      (loop
        (if (eval testForm env)
            (eval forms env)
            (returnFrom exit #inert))))))

(def %loop
  (let1 (%loop ((.parent (theEnv)) '%loop))
    (vau forms env
      (let1 (%deep (let1 (%deep (value :%deep env)) (if (null? %deep) 0 (1+ %deep))))
        (let ( (break (symbol ($ 'break %deep)))
               (continue (symbol ($ 'continue %deep))) )
          (def\ (mkThrow tag (#! (and Integer (>= 0) (<= %deep)) n) forms)
            (list* 'throwTag (list 'quote (symbol ($ tag (- %deep n)))) forms) )
          (let1 (env (newEnv (newEnv env
                  :%deep %deep
                  :break (macro forms (mkThrow 'break 0 forms))
                  :break- (macro (n . forms) (mkThrow 'break n forms))
                  :break? (macro (b . forms) (list 'if b (mkThrow 'break 0 forms)))
                  :break-? (macro (n b . forms) (list 'if b (mkThrow 'break n forms)))
                  :continue (macro forms (mkThrow 'continue 0 forms)) 
                  :continue- (macro (n . forms) (mkThrow 'continue n forms))
                  :continue? (macro (b . forms) (list 'if b (mkThrow 'continue 0 forms))) 
                  :continue-? (macro (n b . forms) (list 'if b (mkThrow 'continue n forms)))
                  :until? (macro (b . forms) (list 'if b (mkThrow 'break 0 forms))) ; same of break?
                  :while? (macro (b . forms) (list 'if b #inert (mkThrow 'break 0 forms))) ))) 
            (if (check? forms (2 oo 'for ((2 3)) )) ;loop for
              (let ( (for (cadr forms))
                     (forms (cons 'begin (cddr forms))) )
                (def increments (list* 'def* (map car for) (map (\((#_ init . incr)) (optDft incr init)) for)))
                (catchTag break
                  (eval (list* 'def* (map car for) (map cadr for)) env)   
                  (%loop
                    (catchTag continue (eval forms env) )
                    (eval increments env) )))
              (if (check? forms (2 oo 'for1 (2 3))) ;loop for1
                (let ( ((pt init . incr) (cadr forms))
                       (forms (cons 'begin (cddr forms))) )
                  (def increment (list 'def pt (optDft incr init)))
                  (catchTag break
                    (eval (list 'def pt init) env)
                    (%loop
                      (catchTag continue (eval forms env) )
                      (eval increment env) )))
                (let1 (forms (cons 'begin forms)) ;loop
                  (catchTag break
                    (%loop
                      (catchTag continue
                        (eval forms env) )))) )))))) ))

(def loop %loop)

(defMacro (for1 binding cond . forms)
  (list* 'loop 'for1 binding
    (if (%ignore? cond) forms
      (cons (list 'while? cond) forms) )))

(defMacro (for bindings cond . forms)
  (list* 'loop 'for bindings
    (if (%ignore? cond) forms
      (cons (list 'while? cond) forms) )))

(defMacro (while cond . forms)
  #|Evaluate FORMS as an implicit `begin' while TEST-FORM evaluates to true.
   |#
  (list* 'loop (list 'while? cond) forms) )

(defMacro until (cond . forms)
  #|Evaluate FORMS as an implicit `begin' until TEST-FORM evaluates to true.
   |#
  (list* 'loop (list 'until? cond) forms) )

(defMacro doTimes ((var times . result) . forms)
  #|Cf. Common Lisp's DOTIMES.
   |#
  (let1\
    (doTimes (times forms result)
      (let1 (i (newBox 0))
        (while (< (i) times) (forms (i)) (++ i) )
        (result (i)) ))
    (list doTimes
      times
      (list* '\ (list var) forms)
      (list* '\ (list var) result) )))

(defVau (repeat times . forms) env
  (if (cons? times) 
    (let* ( (((#! Symbol var) times . ending) times)
            ((#! (and Integer (> 0)) times) (eval times env))
            (env (newEnv env var 0)) )
      (loop (def result (apply begin forms env))
        (break? (>= (eval (list 'set! var :rhs (list '1+ var)) env) times)
          (if (null? ending) result (apply begin ending env)) )))
    (let1 ((#! (and Integer (> 0)) times) (eval times env))
      (loop (def result (apply begin forms env))
        (break? (0? (set! times :rhs (1- times))) result) ))))

(defMacro doTimes ((var times . result) . forms)
  (list* 'repeat (list* var times result) forms) )

#| TODO in alternativa del precedente, da verificare
(defVau (repeat times . forms) env
  (if (cons? times) 
    (let* ( (((#! Symbol var) times . ending) times)
            ((#! (and Integer (>= 0)) times) (eval times env))
            (env (newEnv env var 0)) )
      (loop (break? (>= (env var) times) (if (cons? ending) (apply begin ending env) (0? times) #inert result) ) 
            (def result (apply begin forms env))
            (eval (list '++ var) env) ))
    (let1 ((#! (and Integer (> 0)) times) (eval times env))
      (loop (def result (apply begin forms env))
        (if (0? (-- times)) (break result)) ))))

(defMacro doTimes ((var times . result) . forms)
  (list* 'repeat (list* var times (if (null? result) (cons #inert) result)) forms) )
|#


;;; Lists

(def\ (any? f lst . lst*)
  (if (null? lst*)
    ((rec\ (any? lst) (if (null? lst) #f (f (car lst)) #t (any? (cdr lst))) ) lst)
    ((rec\ (any*? lst*) (if (null? (car lst*)) #f (apply f (map car lst*)) #t (any*? (map cdr lst*))) ) (cons lst lst*)) ))

(defMacro (any?* f . lst) (list 'any? f lst))

(def\ (all? f lst . lst*)
  (if (null? lst*)
    ((rec\ (all? lst) (if (null? lst) #t (f (car lst)) (all? (cdr lst)) #f) ) lst)
    ((rec\ (all*? lst*) (if (null? (car lst*)) #t (apply f (map car lst*)) (all*? (map cdr lst*)) #f) ) (cons lst lst*)) ))

(defMacro (all?* f . lst) (list 'all? f lst))

(def\ (forEach# f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect. Return the #inert.
   |#
  (if (null? lst*)
    ((rec\ (forEach lst) (unless (null? lst) (f (car lst)) (forEach (cdr lst)))) lst)
    ((rec\ (forEach* lst*) (unless (null? (car lst*)) (apply f (map car lst*)) (forEach* (map cdr lst*)) )) (cons lst lst*)) ))

(def\ (forEach f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect. Return the list.
   |#
  (if (null? lst*)
    (let1 (res lst) ((rec\ (forEach lst) (if (null? lst) res (else (f (car lst)) (forEach (cdr lst)) ))) res))
    (let1 (res* (cons lst lst*)) ((rec\ (forEach* lst*) (if (null? (car lst*)) res* (else (apply f (map car lst*)) (forEach* (map cdr lst*)) ))) res*) )) )

(def\ maplist (f lst . lst*)
  #|Apply the FUNCTION, which must return a list, to every element of the
   |LIST, and append the results.  (Note: this currently uses `append',
   |but might be changed to use `nconc' in the future, like Common Lisp.)
   |#
  (if (null? lst*)
    ((rec\ (maplist lst) (if (null? lst) #null (append (f (car lst)) (maplist (cdr lst))))) lst)
    ((rec\ (maplist* lst*) (if (null? (car lst*)) #null (append (apply f (map car lst*)) (maplist* (map cdr lst*))))) (cons lst lst*)) ))

(def\ (filter f lst . lst*)
  (if (null? lst*)
    ((rec\ (filter lst) (if (null? lst) #null (if (f (car lst)) (cons (car lst) (filter (cdr lst))) (filter (cdr lst))))) lst)
    ((rec\ (filter* lst*) (if (null? (car lst*)) #null (let1 (cars (map car lst*)) (if (apply f cars) (cons cars (filter* (map cdr lst*))) (filter* (map cdr lst*)) )))) (cons lst lst*)) ))

(defMacro (remove f lst . lst*)
  #|Return a new list from which the elements that satisfy the TEST have been removed.
   |#
  (list* 'filter (list 'compose '! f) lst lst*) )

(def\ (reduceL f init lst . lst*)
  #|Use the binary FUNCTION to combine the elements of the LIST.
   |The INITIAL-VALUE is logically placed before the list.
   |#
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (reduce (f acc (car lst)) (cdr lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (reduce* (apply* f acc (map car lst*)) (map cdr lst*)) )) init (cons lst lst*)) ))

(def reduce
  #|Alias of reduceL.
   |#
  reduceL)

(def\ (reduceR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (f (reduce acc (cdr lst)) (car lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (apply* f (reduce* acc (map cdr lst*)) (map cadr lst*)) )) init (cons lst lst*)) ))

(def\ (foldL f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldl acc lst) (if (null? lst) acc (foldl (f (car lst) acc) (cdr lst)) )) init lst)
    ((rec\ (foldl* acc lst*) (if (null? (car lst*)) acc (foldl* (apply* f (map car lst*) acc) (map cdr lst*)) )) init (cons lst lst*)) ))

(def\ (foldR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldr acc lst) (if (null? lst) acc (f (car lst) (foldr acc (cdr lst)) ) )) init lst)
    ((rec\ (foldr* acc lst*) (if (null? (car lst*)) acc (apply* f (map car lst*) (foldr* acc (map cdr lst*)) ) )) init (cons lst lst*)) ))

(defMacro dolist ((var lst . resultForms) . bodyForms)
  #|Cf. Common Lisp's DOLIST.
   |#
  (let1rec\
    (dolist (lst body\ result\)
      (if (null? lst) (result\ lst)
        (else
          (body\ (car lst))
          (dolist (cdr lst) body\ result\) )))
    (list dolist
      lst
      (list* '\ (list var) bodyForms)
      (list* '\ (list var) resultForms) )))

(def\ (make\* n f)
  (def\ (resize n lst)
    (let loop ((n n) (h ()) (t lst))
      (if (null? t) (reverse h)
        (if (<= n 1)
          (reverse (cons (if (null? (cdr t)) (car t) t) h))
          (loop (- n 1) (cons (car t) h) (cdr t)) ))))
  (\ lst (apply f (resize n lst))))

(def\ (minMax a . b)
  (let loop [ (x ((caseType a (Double .POSITIVE_INFINITY) (Long .MAX_VALUE) (Integer .MAX_VALUE)) a))
              (y ((caseType a (Double .NEGATIVE_INFINITY) (Long .MIN_VALUE) (Integer .MIN_VALUE)) a))
              (a (cons a b)) ]
    (if (null? a) (list x y)
      (loop (min x (car a)) (max y (car a)) (cdr a)) )))


;;; Arrays

(def\ (array->list arr)
  (%array->list #t arr) )

(def\ (array->cons arr)
  (%array->list #f arr) )

(def list->array %list->array)

(def\ (array . args) (list->array args))

(def Object[] &java.lang.Object[])

(def\ (arrayMap fun (#! Object[] arr))
  (list->array (map fun (array->list arr))) )

(def\ (arrayFilter pred (#! Object[] arr))
  (list->array (filter pred (array->list arr))) )

(def\ (newInstance class dim . dims)
  (apply** @newInstance Array class dim dims))

(def\ (arrayGet array index)
  (if (cons? index)
    (apply** arrayGet* array index)
    (@get Array array index) ))

(def\ (arrayGet* array . indexes)
  (let loop ((array array) (indexes indexes))
    (if (null? indexes) array
      (loop (arrayGet array (car indexes)) (cdr indexes)) )))  

(def\ (arraySet array index value)
  (if (cons? index)
    (apply** arraySet* array value index)
    (else
      (@set Array array index value)
      array )))

(def\ (arraySet* array0 value . indexes)
  (if (null? indexes) array
    (let loop ((array array0) (indexes indexes))
       (if (null? (cdr indexes))
         (then (arraySet array (car indexes) value) array0)
         (loop (arrayGet array (car indexes)) (cdr indexes)) ))))  


;;; Simple Sets

;(def set? /=) ; TODO solo se (/=) -> #t

(def\ (set? lst) (if (null? lst) #t (apply /= lst)))

(def\ (set+ v lst)
  (if (member? v lst) lst (cons v lst)))
  
(defVau (defSet+ (#! Symbol plc) v) env
  (let ( (v (eval v env)) (lst (env plc)) )
    (if (member? v lst) lst (env :def :rhs plc (cons v lst))) ))

(def\ ->set (lst)
  (let loop ( (res ()) (lst lst) )
    (if (null? lst) (reverse res)
      (let1 ((v . lst) lst)
        (loop (if (member? v res) res (cons v res)) lst) ))))

#| TODO da valutare
(def\ ->set (lst)
  (let1 loop (res ())
    (if (null? lst) (reverse res)
      (let1 (v (car lst))
        (set! lst (cdr lst)) 
        (loop (if (member? v res) res (cons v res))) ))))
|#


;;; Syntetic Expressions

;;!Idea stolen from Anarki https://github.com/arclanguage/anarki :-)

(defMacro % ((#! (or Symbol List) x))
  #|a;b -> (compose a b c)
   |a;b;c -> (compose* a b c)
   |!a -> (compose ! a)
   |ab -> (a b)
   |a'b -> (a 'b)
   |a'bc -> (a 'b c)
   |a,b -> (peval a b)
   |a,'b,c -> (peval* a 'b c) 
   |a,_,'b,c -> (\ (_) (a _ 'b c))
   |dd,_c,1,_b,"a",_a,_a,'c,_,:ff,_* -> (\ (_ _a _b _c . _*) (dd _c 1 _b "a" _a _a 'c _ :ff _*))
   |(dd _c 1 _b "a" _a _a 'c _ :ff _*) -> (\ (_ _a _b _c . _*) (dd _c 1 _b "a" _a _a 'c _ :ff _*))
   |#
  (def (comma semicolon apostrophe ellipsis bang) (map symbol (array->list (@split ",;'!" ""))))
  (def\ (mkc t)
    (def\ (pt t)
      (if
        (&& (symbol? t) (@startsWith (.name t) "_")) (cons t)
        (cons? t) (append (pt (car t)) (pt (cdr t))) 
        #null ))
    (let1 (pt (sort (->set (pt t))))
      (if (null? pt)
        (cons (if (null? (cddr t)) 'peval 'peval*) t)
        (list* '\ (if (member? '_* pt) (append (remove [_ (== _ '_*)] pt) '_*) pt) (cons t)) )))
  (def\ (end? r . s*) (|| (null? r) (member? (car r) s*)) )
  (def\ (expd1 t r)
    (if (null? r)
      (if (null? (cdr t)) (car t) (cons (if (null? (cddr t)) 'compose 'compose*) (reverse t)))
      (let1 ((f . r) r)
        (if 
          (== f bang) ;negate
            (if (end? r semicolon comma ellipsis) (%error "! without function")
              (expd1 (cons (list 'compose bang (car r)) t) (cdr r)) )
          (== f comma) ;peval
            (let1 ((f . r) (expd2 0 comma mkc (list (car r) (car t)) (cdr r)))
              (expd1 (cons f (cdr t)) r) )
          (== f ellipsis) ;eval
            (let1 ((f . r) (expd2 0 ellipsis idf (list (car r) (car t)) (cdr r)))
              (expd1 (cons f (cdr t)) r) )
          (expd1 (if (== f semicolon) t (cons f t)) r) ))))
  (def\ (switch sep a b) (if (== sep a) b a))
  (def\ (expd2 lev sep mk t r)
    (if (end? r semicolon) 
        (cons (if (null? (cdr t)) (car t) (mk (reverse t))) (if (null? r) r (cdr r)))
      (end? r (switch sep comma ellipsis))
        (if (0? lev)
          (let1 ((f . r) (expd2 (1+ lev) (switch sep comma ellipsis) (switch mk mkc idf) (car t) r))
            (expd2 lev sep mk (cons f (cdr t)) r) )
          (cons (mk (reverse t)) r) )    
      (let1 ((f . r) r) 
        (if 
          (== f apostrophe) ;quote
            (if (end? r semicolon sep) (%error "' without value")
              (expd2 lev sep mk (cons (list 'quote (car r)) t) (cdr r)) )
          (== f bang) ;not
            (if (end? r semicolon sep) (%error "! without value")
              (expd2 lev sep mk (cons (list bang (car r)) t) (cdr r)) )
          (== f sep)
            (if (member*? (car r) apostrophe bang)
              (expd2 lev sep mk t r)
              (expd2 lev sep mk (cons (car r) (if (cons? t) t (cons t))) (cdr r)) )
          (%error ("invalid syntax " f)) ))))
  (def\ (expd0 x)
     (map [_ (if (>= (@indexOf ";!,'_" (%subString _ 0 1)) 0) (symbol _) (car (@toLispList vm _)))]
       (filter [_ (!= _ "")] (array->list (@splitWithDelimiters (name x) ";|!|,|'||_[1-9a-z*]?" -1)) )) )
  (if (symbol? x)
    (expd1 () (expd0 x))
    (mkc x)) )


;;; Boxes

#|! 
 |The Box are functions that encapsulates a mutable value.
 |Calling the box:
 |- without arguments returns the value in the box.
 |- with an attribute update the value in the box.
 |- without bindResult or with bindResult #ignore use as bindResult (bndRes)
 |- with bindResult #inert return #inert
 |- with bindResult :rhs return the right side of the last binding
 |- with bindResult :prv return the previous value of the last binding
 |- with bindResult :obj return the box
 |
 |$(box)
 |$(box value)
 |$(box bindResult value)
 |$(syntax bindResult (or #ignore #inert :rhs :prv :obj))  
 |#

(def newBox
  #|Create a new box with the optional VALUE.
   |without VALUE use as VALUE (boxDft).
   |$(fn)
   |$(fn value)
   |#
  %newBox)

(defMacro (defBox name . value?)
  (list 'def name (cons 'newBox value?)) )


;;; Dynamic Bindings

#|!
 |DVar estends Box
 |#

(def newDVar %newDVar)
(def dval %dVal)

(defMacro (ddef var . val)
  #|Define a new or update an existing dynamic variable with the given NAME and optDft default VALUE.
   |$(fn (name))
   |$(fn (name value))
   |#
  (list* (list '%d\ (list var)) val) )

(defMacro (ddef* var* . val*)
  (list* (list '%d\ var*) val*) )

(def\ (dget dvar)
  #|Return the current value of the DYNAMIC-VARIABLE.
   |#
  (dvar))

(def\ (dset dvar value)
  #|Set the current value of the DYNAMIC-VARIABLE.
   |#
  (dvar value))

(defMacro (dlet bindings form . forms)
  #|Evaluate the FORMS as an implicit `begin' with the dynamic variables specified by BINDINGS temporarily bound to new VALUES, and return the result.
   |Bindings are established parallely as per `let'.
   |$(fn binding . forms)
   |$(type macro)
   |$(syntax binding (dynamicVariable value))
   |#
  (cons (list* '%d\ (map car bindings) form forms) (map cadr bindings)) )

(defMacro (progv var* val* exp . exps)
  #|Evaluate the FORMS as an implicit `begin' with the dynamic variables specified by DYNAMIC-VARIABLES temporarily bound to new VALUES, and return the result.
   |The DYNAMIC-VARIABLES and VALUES lists must have the same length.
   |#
  (cons (list* '%d\ var* exp exps) val*) )

(defMacro (dlet* bindings . forms)
  #|Evaluate the FORMS as an implicit `begin' with the dynamic variables specified by BINDINGS temporarily bound to new VALUES, and return the result.
   |Bindings are established serially as per `let*'.
   |#
  (if (null? bindings)
    (cons 'begin forms)
    (list 'dlet
      (list (car bindings))
      (list* 'dlet* (cdr bindings) forms) )))


;;; Classes

(def\ findClass ((#! Symbol name) env)
  #|Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT.
   |#
  (eval name env))

(defVau defClass (name (#! (0 1 Symbol) superClass?) (#! (Symbol) slotSpecs) . properties) env
  #|Define a new `StandardClass' with the given NAME, optional SUPERCLASS?, and SLOT-SPECS.
   |The superclass defaults to `standard-object'.
   |The SLOT-SPECS and PROPERTIES are currently ignored.
   |$(syntax slotSpec symbol)
   |#
  ;; Slot-specs are ignored for now, but check that they are symbols nevertheless.
  (def superClass (findClass (optDft superClass? 'Obj) env))
  (eval (list 'def name (%newClass name superClass)) env) )


;;; Generic Functions

;; receiverName e parameters dei defMethod dovrebbero corrispondere a quelli del corrispondente defGeneric con quel nome

(defVau (defGeneric . args) env
  #|Define a new generic function with the given NAME.
   |The RECEIVER-NAME, PARAMETERS, and PROPERTIES are currently ignored.
   |#
  (if (cons? (car args))
    (def ((name receiverName . parameters) . properties) args)
    (def (name (receiverName . parameters) . properties) args) )
  (let1\ (generic args ((%getMethod (classOf (car args)) name) args))
    (eval (list 'def name generic) env) ))

(defVau (defMethod . args) env
  #|Add a new method to the generic function named by NAME specialized for the class named by CLASS-NAME.
   |#
  (if (cons? (car args))
    (def ((name (receiverName class) . parameters) . forms) args)
    (def (name ((receiverName class) . parameters) . forms) args) )
  (def\ (method args)
    (apply
      (eval
        (list* '\ (cons receiverName parameters) forms)
        (let1 (receiver (car args)) (if (type? receiver Obj) (newEnv env receiver) env)) )
      args ))
  (def prv (%addMethod (eval class env) name method))
  (case (bndRes) (#inert #inert) (:rhs method) (:prv prv)) )


;;; Modules

(defVau (provide symbols . forms) env
  (eval
    (list 'def symbols
      (list 'let ()
        (cons 'begin forms)
        (cons 'list symbols) ))
    env ))

(defVau (module exports . forms) env
  (let1 (env (newEnv env))
    (eval (list* 'provide exports forms) env)
    (newEnv env) ))

(defMacro (defModule name exports . forms)
  (list 'def name (list* 'module exports forms)) )

(defVau (import module imports) env
  (let* ((module (eval module env))
         (values (eval (cons 'list imports) module)) )
    (eval (list* 'def* imports values) env) ))


;;; Relational Operators

#|!
 |Note that unlike in Common Lisp, these operators currently require at least two arguments.  
 |This will be improved in the future.
 |#

(def\ (relationalOp binop)
  #|Utility to create an n-ary relational operator from a BINARY-OPERATOR.
   |$(fn binop)
   |$(type function)
   |#
  (rec\ (op arg1 arg2 . rest)
    (if (binop arg1 arg2)
      (if (null? rest) #t
        (apply op (cons arg2 rest)))
      #f )))

(def <
  #|Return true if the ARGUMENTS are in monotonically increasing order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |$(derivation (relationalOp <))
   |#
  (relationalOp <) )

(def >
  #|Return true if the ARGUMENTS are in monotonically decreasing order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |$(derivation (relationalOp >))
   |#
  (relationalOp >) )

(def <=
  #|Return true if the ARGUMENTS are in monotonically nondecreasing order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |$(derivation (relationalOp <=))
   |#
  (relationalOp <=) )

(def >=
  #|Return true if the ARGUMENTS are in monotonically nonincreasing order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |$(derivation (relationalOp >=))
   |#
  (relationalOp >=) )

(def eq?
  #|Return true if all ARGUMENTS are equal, false otherwise.
   |$(fn arguments)
   |$(type function)
   |$(derivation (relationalOp eq?))
   |#
  (relationalOp eq?) )

(def ==
  #|Return true if all ARGUMENTS are ==, false otherwise.
   |$(fn arguments)
   |$(type function)
   |$(derivation (relationalOp eq?))
   |#
  (relationalOp ==))

(def !=
  #|Return false if all ARGUMENTS are ==, true otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp !=))

(def\ /= (arg . args)
  #|Return true if all ARGUMENTS are distinct, false otherwise.
   |$(fn argument . arguments)
   |$(type function)
   |#
  (if (null? args) #t
    (if (member? arg args :cmp eq?) #f
      (apply /= args) )))

#| TODO in sostituzione del prededente, utile?
(def\ /= args
  (if (null? args) #t
    (let1 ((arg . args) args)
      (if (member? arg args :cmp eq?) #f
        (apply /= args) ))))
|#


;;; Thetics & Lytics

;;!The terms thetic (for + and *) and lytic (for - and /) are due to Hankel.

(def\ (theticOp binOp unit)
  #|Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |$(fn binOp unit)
   |$(type function)
   |#
  (\ args (reduce binOp unit args)) )

(def +
  #|Return the sum of the ARGUMENTS, or 0 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |$(derivation (tethicOp + 0))
   |#
  (theticOp + 0) )

(def *
  #|Return the product of the ARGUMENTS, or 1 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |$(derivation (tethicOp * 1))
   |#
  (theticOp * 1) )

(def $
  #|Return the join of the ARGUMENTS, or "" if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |$(derivation (tethicOp $ ""))
   |#
  (theticOp $ "") )

(def\ (lyticOp binOp unit)
  #|Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |$(fn binOp unit)
   |$(type function)
   |#
  (\ (arg1 . rest)
    (if (null? rest)
      (binOp unit arg1)
      (reduce binOp arg1 rest) )))

(def -
  #|If only one number is supplied in the ARGUMENTS, return the negation of that number.
   |If more than one number is supplied, subtract all of the later ones from the first one and return the result.
   |$(fn arguments)
   |$(type function)
   |$(derivation (lithicOp - 0))
   |#
  (lyticOp - 0) )

(def /
  #|If only one number is supplied in the ARGUMENTS, return the reciprocal of that number.
   |If more than one number is supplied, divide the first one by all of the later ones and return the result.
   |$(fn arguments)
   |$(type function)
   |$(derivation (lithicOp / 1))
   |#
  (lyticOp / 1) )


;;; Greatest Common Divisor e Lowest Common Multiple

(def\ (gcd a b . more)
  #|TODO
   |#
  (if (null? more)
    (if (0? b) a (gcd b (% a b)))
    (gcd a (apply gcd (cons b more))) ))

(def abs (let1 (abs (@getMethod Math "abs" &int)) (\ (n) (abs #null n))))

(def\ (lcm a b . more)
  #|TODO
   |#
  (if (null? more)
    (if (|| (0? a) (0? b)) 0
      (abs (* b (/ a (gcd a b)))) )
    (lcm a (apply lcm (cons b more))) ))


;;; Sequences

(defGeneric length (sequence)
  #|Return the number of elements in a sequence.
   |#
)
(defMethod length ((seq List))
  (%len seq))
(defMethod length ((seq Null))
  (%len seq))
(defMethod length ((seq String))
  (@length seq))


(defGeneric elt (sequence index)
  #|Return the sequence element at the specified index.
   |#
)
(defMethod elt ((seq List) index)
  (nth index seq))
(defMethod elt ((seq String) index)
  (%subString seq index (+ index 1)))


(defGeneric subSeq (sequence start . end)
  #|Create a sequence that is a copy of the subsequence of the SEQUENCE bounded by START and optional END.
   |If END is not supplied or #inert, the subsequence stretches until the end of the list
   |#
)
(defMethod subSeq ((seq List) start . end)
  (apply** %subList seq start end))
(defMethod subSeq ((seq Null) start . end)
  (apply** %subList seq start end))
(defMethod subSeq ((seq String) start . end)
  (apply** %subString seq start end))


;;; Coroutines

(defConstant coroutinePrompt
  #|This prompt is used for general coroutine-like use of continuations.
   |#
  'coroutine-prompt)

(defMacro coroutine forms
  #|Evaluate the FORMS as an implicit `begin' in a context in which `yield' can be used to pause execution.
   |#
  (list* 'pushPrompt 'coroutinePrompt forms))

(defMacro yield (name . forms)
  #|Pause the current coroutine.
   |In the place where the enclosing `coroutine' (or `resume') was called,
   |evaluate the FORMS as an implicit `begin' with NAME bound to the paused coroutine, and return the result.
   |`resume' can later be used to restart execution inside the coroutine.
   |#
  (list* 'takeSubcont 'coroutinePrompt name forms))

(defMacro resume (k . forms)
  #|Resume the paused coroutine K and evaluate FORMS as an implicit `begin' in the place where `yield' was called in the coroutine, and return the result.
   |#
  (list* 'pushDelimSubcont 'coroutinePrompt k forms))


;;; Fibers

#|!
 |The following implementation of fibers follows the one at URL `http://okmij.org/ftp/continuations/implementations.html#dget-wind'
 |We're calling them fibers instead of coroutines so as to not conflict with the built-in coroutine operators.
 |We use it for testing that built-in operators properly suspend and resume.
 |#

(defConstant fiberPrompt
  #|The prompt used for delimiting fibers.
   |#
  'fiber-prompt)

(defClass YieldRecord ()
  #|Instances of this class are yielded.
   |#
  (value continuation) )

(def\ makeYieldRecord (v k)
  #|Create a new yield record with the given yielded value and resume continuation.
   |#
  (new YieldRecord :value v :continuation k))

(def\ fiberYield v?
  #|Yield a value (which defaults to #inert).
   |#
  (takeSubcont fiberPrompt k
    (makeYieldRecord (optDft v? #inert) k)))

(def\ fiberResume (yieldRecord . v?)
  #|Resume a suspended fiber with a value (which defaults to #inert).
   |#
  (pushDelimSubcont fiberPrompt (yieldRecord 'continuation)
    (optDft v? #inert)))

(defMacro fiber forms
  #|Evaluate the forms expressions as a fiber.
   |#
  (list* pushPrompt 'fiberPrompt forms))

(def\ runFiber* (thunk . values)
  #|Get all values yielded by a fiber, and its final result, and collect them in a list.
   |Uses the optional list of values to sent to the fiber with `fiberResume'.
   |#
  (let run ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
      (cons (result 'value)
        (if (null? values)
          (run (fiberResume result) #null)
          (run (fiberResume result (car values)) (cdr values)) ))
      (list result) )))

(defMacro (runFiberWithValues f args) (list 'eval (list 'list* 'runFiber* f args))) 
(defMacro (runFiberWithValues f args) (list 'apply 'runFiber* (list 'cons f args))) 
(defMacro (runFiberWithValues f args) (list 'apply** 'runFiber* f args)) 

(def runFiber runFiber*)


;;; Auto Increment/Decrement and Assignement Operators

(defVau (++ plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (+ (val) 1))))
    (Obj    (let1 ((fld) args) (val :rhs fld (+ (val fld) 1))))
    (Number (let1 (() args) (eval (list 'set! plc :rhs (+ val 1)) env)))
    (else   (error ($ "not valid type: " val))) ))

(defVau (-- plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (- (val) 1))))
    (Obj    (let1 ((fld) args) (val :rhs fld (- (val fld) 1))))
    (Number (let1 (() args) (eval (list 'set! plc :rhs (- val 1)) env)))
    (else   (error ($ "not valid type: " val))) ))

(def\ (assignOp op)
  (vau (plc . args) env
    (def lval (eval plc env))
    (caseType lval
      (Box (match args
        ((rval) (lval (op (lval) (eval rval env))))
        ((key rval) (lval key (op (lval) (eval rval env)))) ))
      (Obj (match args
        ((fld rval) (lval fld (op (lval fld) (eval rval env))))
        ((key fld rval) (lval key fld (op (lval fld) (eval rval env)))) ))
      (Object (match args
        ((rval) (eval (list 'set! plc (op lval (eval rval env))) env))
        ((key rval) (eval (list 'set! plc key (op lval (eval rval env))) env)) )))))

(def $= (assignOp %$))
(def += (assignOp %+))
(def -= (assignOp %-))


;;; Java

#|!
 |Class
 |  &canonicalClassName
 |
 |  &int
 |  &java.lang.Integer
 |  &Wat.Vm$Cons
 |  &Object[]
 |
 |Costructors
 |  (@new class . arguments)
 |  (@new class containerInstance . arguments)
 |
 |  (@new &java.lang.String "abc")
 |  (@new &Wat.Vm$Cons vm 1 2)
 | 
 |Fields
 |  (.fieldName object)
 | 
 |  (.MAX_VALUE &java.lang.Integer)
 |  (.car cons)
 |
 |Method
 |  (@methodName object . arguments)
 |
 |  (@toString cons)
 |  (@doubleValue 10)
 | 
 |  (@getField &java.lang.Integer "MAX_VALUE")
 |  (@getDeclaredField &Wat.Vm$Cons "car")
 |  (@getConstructor &java.lang.Integer &java.lang.String)
 |  (@getMethod &java.lang.Integer "compare" &int &int)
 |  (@getConstructor &java.lang.Character &char)
 |
 |Utility
 |  (@getField &Wat.Utility &java.lang.Integer "MAX_VALUE")
 |  (@getField &Wat.Utility &Wat.Vm$Cons "car")
 |  (@getExecutable &Wat.Utility &java.lang.Integer "new" &java.lang.String)
 |  (@getExecutable &Wat.Utility &java.lang.Integer "compare") 
 |  (@getExecutable &Wat.Utility &java.lang.Character "new") 
 |#
   
(defMacro (close1 binding . forms)
  #|Single try/resource
   |$(fn binding . forms)
   |$(syntax binding (name . initForms)) 
   |$(type macro)
   |#
  (list 'let1 binding
    (list* 'atEnd
      (list '@close (car binding))
      forms )))

(defMacro (close bindings . forms)
  #|Multiple try/resource
   |$(fn bindings . forms)
   |$(syntax bindings ((name . initForms) . bindings)) 
   |$(type macro)
   |#
  (list 'let bindings
    (list* 'atEnd
      (list 'forEach '@close (cons 'list (map car bindings)))
      forms )))


;;; Apl/J

(def\ (iota n) (reverse ((rec\ (iota n) (if (0? n) () (cons n (iota (1- n))))) n)))
(def\ (fork f l r) [_ (f (l _) (r _))])
(def\ (hook l r) [_ (l _ (r _))])


;;; Utility

(defVau (time times . forms) env
  (let* ( (currentTime (@getMethod System "currentTimeMillis"))
          ((#! (and Integer (> 0)) times) (eval times env))
          (milli (currentTime #null))
          (result (apply repeat (cons times forms) env))
          (milli (- (currentTime #null) milli)) )
    (print "time " times " " forms ": " milli "ms" (if (== times 1) "" ($ ", on average: " (@format String "%.2f" (/ milli (@doubleValue times))) "ms" )))
    result ))
