;;;                                                     -*- mode: Scheme -*-
;;; LispX Bootstrap
;;;

;; Copyright (c) 2021, 2022 Manuel J. Simoni

;; ``72. An adequate bootstrap is a contradiction in terms.''

;; Rename %def

(%def def
  #|Match the DEFINIEND-TREE against the VALUE and place resulting
   |bindings into the current environment.
   |$(fn (definiendTree value))
   |$(type fexpr)
   |#
  %def)


;;; Built-Ins - rename bindings that will be used as provided by VM

(def ==
  #|Return true if the values A and B are pointer-identical, false otherwise.
   |$(fn (a b))
   |$(type function)
   |#
  %==)
(def != %!=)

(def $ %$)
(def + %+)
(def * %*)
(def - %-)
(def / %/)
(def % %%)
  
(def !
  #|Invert the BOOLEAN.
   |$(fn (boolean))
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  %!)
(def !! %!!)
(def < %<)
(def > %>)
(def <= %<=)
(def >= %>=)
  
(def ~ %~)
(def & %&)
(def \| %\|)
(def ^ %^)
(def << %<<)
(def >> %>>)
(def >>> %>>>)

(def append
  #|Append two lists.  The first one must be proper and is copied.  The
   |second one is not copied (and doesn't even have to be a list). It
   |becomes the `cdr' of the final cons of the first list, or is returned
   |directly if the first list is empty.
   |$(fn (list1 list2))
   |$(type function)
   |#
  %append)

(def array->list %array->list)
(def begin
  #|Sequentially evaluate FORMS, returning the value of the last one, or void if there are no forms.
   |$(fn forms)
   |$(type fexpr)
   |#
  %begin)

(def bind? %bind?)

(def bound?
  #|Return true if the SYMBOL is bound in the ENVIRONMENT, false otherwise.
   |$(fn (symbol environment))
   |$(type function)
   |#
  %bound?)

(def box
  #|Create a new box with the optional INITIAL-VALUE?.  A box is a
   |function that encapsulates a mutable value.  Calling the box without
   |arguments returns the value.  Calling the box with an argument sets
   |the value.
   |$(fn initialValue?)
   |$(type function)
   |#
  %box)

(def cons
  #|Create a cons with the given CAR and CDR.
   |$(fn (car cdr))
   |$(type function)
   |#
  %cons)

(def cons?
  #|Return true if the OBJECT is a cons, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %cons?)

(def className
  #|Return the name symbol of the CLASS.
   |$(fn (class))
   |$(type function)
   |#
  %className)

(def classOf
  #|Return the class of the OBJECT.
   |$(fn (object))
   |$(type function)
   |#
  %classOf)

(def dval %dVal)
(def dvar %dVar)
(def eq? %eq?)
(def eval
  #|Evaluate the FORM in the ENVIRONMENT, returning its result.
   |$(fn (form environment))
   |$(type function)
   |#
  %eval)

(def finally
  #|valuate the PROTECTED-FORM and return its result.  Regardless of
   |whether the protected form returns normally, or via a nonlocal exit or
   |panic, the CLEANUP-FORMS are evaluated after the protected form.
   |$(fn (protectedForm . cleanupForms))
   |#
  %finally)

(def if
  #|Evaluate the TEST which must yield a boolean.  Then evaluate either
   |the CONSEQUENT or ALTERNATIVE depending on whether the TEST yielded
   |true or false.
   |$(fn (test consequent . alternative))
   |$(type fexpr)
   |#
  %if)

(def intern
  #|Get or create the unique symbol with STRING as name.
   |$(fn (string))
   |$(type function)
   |#
  %intern)

(def instanceOf? %instanceOf?)

(def keyword %keyword)
(def keyword? %keyword?)
(def keywordName %internName)
(def len %len)
(def list*
  #|Create a list from the ARGUMENTS so that the last argument becomes
   |the `cdr' of the list.
   |$(fn arguments)
   |$(type function)
   |#
  %list*)

(def list?
  #|Return true if the OBJECT is a list, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %list?)

(def list->array %list->array)
(def loop
  #|Evaluate the FORMS in an infinite loop.
   |$(fn forms)
   |$(type fexpr)
   |#
  %loop)

(def makeEnv
  #|Create a new environment with an optional PARENT-ENVIRONMENT? in
   |which bindings are looked up if they are not found.
   |$(fn parentEnvironment?)
   |$(type function)
   |#
  %makeEnv)

(def null?
  #|Return true if the OBJECT is nil, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %null?)

(def not
  #|Invert the BOOLEAN.
   |$(fn (boolean))
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  !)

(def nth
  #|Return element number N of LIST, where the `car' is element zero.
   |$(fn (n list))
   |$(type function)
   |#
  %nth)

(def nthCdr
  #|Returns the tail of LIST that would be obtained by calling `cdr' N times in succession.
   |$(fn (n list))
   |$(type function)
   |#
  %nthCdr)

(def obj
  #|Create a new instance of CLASS (that must be a `standard-class').
   |The SLOT-INITS must be of even length, and alternately contain slot
   |names (symbols, typically keywords) and values.
   |$(fn (class . slotInits))
   |#
  %obj)

(def panic
  #|Mostly for internal use.  Signal the ERROR in such a way that it is
   |hard to handle and will usually escape the VM as a host language
   |exception.  In particular, signal handlers will not be invoked.
   |However, intervening `finally' cleanup expressions and `progv'
   |expressions are still triggered, so Lisp invariants are maintained.
   |$(fn (error))
   |$(type function)
   |#
  %panic)

(def reverse
  #|Reverse the LIST.
   |$(fn (list))
   |$(type function)
   |#
  %reverse)

(def set! %set!)
(def symbol %symbol)
(def symbol? %symbol?)

(def symbolName
  #|Return the name of the SYMBOL as a string.
   |$(fn (symbol))
   |$(type function)
   |#
  %internName)

(def subClass?
  #|Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.
   |A class is considered a subclass of itself.
   |$(fn (class superclass))
   |$(type function)
   |#
  %subClass?)

(def the %the)

(def type?
  #|Return true if the OBJECT is an instance of the CLASS, false otherwise.
   |$(fn (object class))
   |$(type function)
   |#
  %type?)

(def unwrap
  #|Return the underlying operator of a FUNCTION.
   |$(fn (function))
   |$(type function)
   |#
  %unwrap)

(def wrap
  #|Create a new function that wraps around an underlying OPERATOR, and
   |induces argument evaluation around it.
   |$(fn (operator))
   |$(type function)
   |#
  %wrap)


;;; unused in code but not in test

(def classSymbol
  #|Return the symbol with the same name as SYMBOL, but in the class namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %classSymbol)

(def functionSymbol
  #|Return the symbol with the same name as SYMBOL, but in the function namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %functionSymbol)

(def keywordSymbol
  #|Return the symbol with the same name as SYMBOL, but in the keyword namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %keywordSymbol)

(def variableSymbol
  #|Return the symbol with the same name as SYMBOL, but in the variable namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %variableSymbol)


;;; Core Forms

(def vau
  #|Construct a fexpr with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (parameterTree environmentParameter . forms))
   |$(type fexpr)
   |$(derivation (vau (pt ep . forms) env (eval (list 'vau pt ep (list* 'begin forms)) env)))
   |#
  %vau)

(def theEnv
  #|Return the current environment.
   |$(fn parent?)
   |$(type fexpr)
   |$(derivation (vau () environment environment)))
   |#
  %theEnv)

(def quote
  #|Return the unevaluated OPERAND.
   |$(fn (operand))
   |$(type fexpr)
   |$(derivation (vau (operand) #ignore operand))
   |#
  %quote)

(def list
  #|Return the list of evaluated ARGUMENTS.
   |$(fn arguments)
   |$(type function)
   |$(derivation (wrap (vau arguments #ignore arguments))
   |#
  %list)

(def \
  #|Create an anonymous function with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type function)
   |$(derivation (vau (formals . body) env (wrap (eval (list* vau formals #ignore body) env))))
   |#
  %\)

(def car
  #|Return the contents of the address part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %car)

(def cadr
  #|Return the `car' of the `cdr' of the CONS.
   |$(derivation (car (cdr cons)))
   |$(derivation (\ ((#_ . (cadr . #_))) cadr))
   |$(derivation (\ ((#_ cadr . #_)) cadr))
   |#
  %cadr)
  
(def cdr
  #|Return the contents of the decrement part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %cdr)

(def cddr
  #|Return the `cdr' of the `cdr' of the CONS.
   |$(derivation (cdr (cdr cons)))
   |$(derivation (\ ((#_ . (#_ . cddr))) cddr))
   |$(derivation (\ ((#_ #_ . cddr)) cddr))
   |#
  %cddr)

(def caar
  #|Return the `car' of the `car' of the CONS.
   |#
  (\ (x) (car (car x))))

(def cdar
  #|Return the `cdr' of the `car' of the CONS.
   |#
  (\ (x) (cdr (car x))))
 
(def compose
  #|Compose two functions, creating a new function equivalent to (G (F ...)).
   |#
  (\ (f g) (\ args (f (apply g args)))) )

(def identity
  #|Identity function.
   |#
  (\ (x) x))


;;; Macro

(def evalMacro (dvar #t))

(def makeMacro
  #|Create a macro from an EXPANDER operator.  A macro is an operator
   |that receives an operand and produces a form (by calling the expander
   |with the operand as argument) that is then evaluated in place of the
   |operand.
   |$(fn (expander))
   |$(type function)
   |#
  (wrap
    (vau (expander) #ignore
      (vau operands env
        (def !evalMacro (! (evalMacro)))
        (if !evalMacro (evalMacro #t))
        (def exp (eval (cons expander operands) (makeEnv)))
        (if !evalMacro exp (eval exp env)) ))))

(def macro
  #|Create an anonymous macro with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type macro)
   |#
  (makeMacro
    (vau (pt . forms) #ignore
      (list 'makeMacro (list* 'vau pt #ignore forms)) )))


; defMacro defVau def\ def*\ rec\ let1\ let1rec\ let\ letrec\ permettono la definizione con due sintassi
;
;    (_ name parameters . body)
;    (_ (name . parameters) . body)
;
; rec rec\ let1rec let1rec\ letrec letrec\ inizializzano a #inert le definizioni prima della valutazione

(def defMacro
  #|Define a macro with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (macro (lhs . rhs)
    (if (symbol? lhs)
      (list 'def lhs (list* 'macro (car rhs) (cdr rhs)))
      (list 'def (car lhs) (list* 'macro (cdr lhs) rhs)) )))

(defMacro (expand macro)
  (list 'begin (list 'evalMacro #f) macro) )

(defMacro (defVau lhs . rhs)
  #|Define a fexpr with the given NAME, PARAMETER-TREE,
   |ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (symbol? lhs)
    (list 'def lhs (list* 'vau (car rhs) (cadr rhs) (cddr rhs)))
    (list 'def (car lhs) (list* 'vau (cdr lhs) (car rhs) (cdr rhs))) ))

(defMacro defConstant (name value . docstring?)
  #|Define a constant with the given NAME and VALUE.  This is mostly
   |for documentation purposes, as constants are still mutable.
   |#
  (list 'def name value) )

(defMacro (wrau pt ep . body)
  (list 'wrap (list* 'vau pt ep body)))

(defMacro (def* lhs . rhs)
  (list 'def lhs (list* 'list rhs)) )

(defMacro (def\ lhs . rhs)
  #|Define a function with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (symbol? lhs)
    (list 'def lhs (list* '\ (car rhs) (cdr rhs)))
    (list 'def (car lhs) (list* '\ (cdr lhs) rhs)) ))


;;;; Basic value test

(def\ (inert? o) (== o #inert))
(def\ (zero? n) (== n 0))
(def\ (even? n) (== (% n 2) 0))
(def\ (odd? n)  (== (% n 2) 1))


;;; Wrap incomplete VM forms


(defMacro catch (tag . forms)
  #|Establish a catch tag and evaluate FORMS as an implicit `begin'
   |inside it.  The forms may use `throw' to nonlocally exit from the
   |tag.  Usually, `block' should be preferred.
   |#
  (list '%catch tag (list* '\ () forms)))

(def\ throw (tag . result?)
  #|Abort to a nesting catch tag established by `catch' and pass the
   |optional RESULT? (defaults to void) to it.
   |#
  (%throw tag (opt? result? #inert)))



;;; Delimited Control Operators

;; These operators follow the API put forth in the delimcc library
;; at URL `http://okmij.org/ftp/continuations/implementations.html'.

(defMacro (pushPrompt prompt . forms)
  #|Push the PROMPT and evaluate the FORMS inside the prompt.  This
   |delimits the continuation.
   |#
  (list '%pushPrompt prompt (list* '\ () forms)))

(def takeSubcont
  #|Abort outwards to the PROMPT.  When the prompt is reached, evaluate
   |the FORMS with NAME bound to the captured continuation (which does not
   |include the prompt).
   |$(fn (prompt name . forms))
   |#
  %takeSubcont)

(defMacro (pushDelimSubcont prompt continuation . forms)
  #|Push the PROMPT and compose the previously captured CONTINUATION
   |inside it.  The FORMS are then evaluated inside the new continuation.
   |#
  (list '%pushDelimSubcont prompt continuation (list* '\ () forms)))

(defMacro pushSubcont (k . forms)
  #|We don't have `pushSubcont' but for these tests we can emulate it
   |with a `pushDelimSubcont' that pushes an unused prompt.
   |#
  (list* pushDelimSubcont #ignore k forms))

(defMacro pushSubcontBarrier forms
  #|Push a continuation barrier that prevents the FORMS from capturing
   |any continuations to the outside.
   |#
  (list* '%pushSubcontBarrier (%makeEnv) forms))


;;; Basic macros and functions

(def\ (apply appv args . env)
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(type function)
   |#
  (def env (if (null? env) (makeEnv) ((\ ((env)) env) env))) 
  (if (%jFun? appv)
    (@combine (@new JFun vm appv) env args)
    (eval (cons (unwrap appv) args) env) ))

(defMacro (rec lhs . rhs)
  (list (list '\ () (list 'def lhs #inert) (list* 'def lhs :rhs rhs))) )

(defMacro (rec\ lhs . rhs)
  (if (symbol? lhs)
    (list 'rec lhs (list* '\ (car rhs) (cdr rhs)))
    (list 'rec (car lhs) (list* '\ (cdr lhs) rhs)) )) 

(def\ (map f lst . lst*)
  #|Create a new list by applying the FUNCTION to every element of the LIST.
   |#
  (if (null? lst*)
    ((rec\ (map lst) (if (null? lst) #null (cons (f (car lst)) (map (cdr lst))) )) lst)
    ((rec\ (map* lst*) (if (null? (car lst*)) #null (cons (apply f (map car lst*)) (map* (map cdr lst*))) )) (cons lst lst*)) ))

(defMacro (def*\ lhs* . rhs*)
  (list* 'def*
    (map (\ (lhs) (if (symbol? lhs) lhs (car lhs))) lhs*)
    (map (\ (lhs rhs) (if (symbol? lhs) (list* '\ (car rhs) (cdr rhs)) (list* '\ (cdr lhs) rhs))) lhs* rhs*) )) 


;;; Lexical Bindings

(def\ (->inert binding) #inert)
(def\ (->1expr binding) ((\ ((#_ cadr)) cadr) binding))
(def\ (->begin binding) ((\ ((#_ cadr . cddr)) (if (null? cddr) cadr (list* 'begin cadr cddr))) binding))
(def\ (->name  lhs) (if (symbol? lhs) lhs (car lhs)))
(def\ (->name\ (lhs . rhs)) (if (symbol? lhs) (list lhs (list* '\ (car rhs) (cdr rhs))) (list (car lhs) (list* '\ (cdr lhs) rhs))))


(defMacro (let1Loop . args)
  (if (symbol? (car args))
    (def (name binding . body) args)
    (def ((name . binding) . body) args))
  (list
    (list* 'rec\ name (list (car binding)) body)
    (->1expr binding) ))

(defMacro (let1 lhs . rhs)
  (if (symbol? lhs)
    (list* 'let1Loop lhs (car rhs) (cdr rhs))
    (list (list* '\ (list (car lhs)) rhs)
      (->1expr lhs) )))

(defMacro (let1\ binding . body)
  (list* 'let1 (->name\ binding) body))

#| TODO non sembra utile
(defMacro (let1rec binding . body)
  (list* 'let ()
    (list 'def (car binding) (->inert binding))
    (list 'def (car binding) (->1expr binding))
    body ))
|#

(defMacro (let1rec\ binding . body)
  (list* 'let ()
    (list 'def (->name (car binding)) #inert)
    (list* 'def\ (car binding) (cdr binding))
    body ))


(defMacro (letLoop . args)
  #|Labelled recursive loop, analogous to Scheme's named `let'.
   |Lexically bind a function named NAME with one PARAMETER for every
   |INITIALIZER and the FORMS as body.  Then immediately apply the
   |function to a list containing one VALUE for every INITIALIZER and
   |return the result.  The function is bound per `labels' so it can
   |recursively refer to itself.
   |$(fn (initializers . body))
   |$(fn (name initializers . body))
   |$(syntax initializers ((parameter value) . initializers)
   |#
  (if (symbol? (car args))
    (def (name bindings . body) args)
    (def ((name . bindings) . body) args))
  (list*
    (list* 'rec\ name (map car bindings) body)
    (map ->1expr bindings) ))

(defMacro (let lhs . rhs)
  #|Establish BINDINGS parallelly during the evaluation of FORMS, so
   |that no binding can refer to the other ones.
   |$(fn (bindings . body))
   |$(fn (name bindings . body))
   |$(syntax bindings ((parameter value) . bindings)
   |#
  (if (symbol? lhs)
    (list* 'letLoop lhs rhs)
    (list* (list* '\ (map car lhs) rhs)
      (map ->1expr lhs) )))

(defMacro (let\ bindings . body)
  #|Establish FUNCTION-BINDINGS parallelly during evaluation of FORMS,
   |so that no function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  (list* 'let (map ->name\ bindings) body))

#| TODO non sembra utile
(defMacro (letrec bindings . body)
  #|Utility to establish BINDINGS recursively during the evaluation of
   |FORMS.  Used by `labels'.
   |#
  (list* 'let ()
    (list* 'def* (map car bindings) (map ->inert bindings))
    (list* 'def* (map car bindings) (map ->1expr bindings))
    body ))
|#

(defMacro (letrec\ bindings . body)
  (list* 'let ()
    (list* 'def* (map (\ (binding) (->name (car binding))) bindings) (map ->inert bindings))
    (list* 'def*\ (map car bindings) (map cdr bindings))
    body ))

(def labels
  #|Establish FUNCTION-BINDINGS recursively during evaluation of FORMS,
   |so that every function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  letrec\)

(defMacro (let* bindings . body)
  #|Establish BINDINGS serially during the evaluation of FORMS, so that
   |every binding can refer to previous ones.
   |$(syntax bindings ((definiendTree value) . bindings))
   |#
  (if (null? bindings)
      (list* 'let () body)
      (list 'let
        (list (car bindings))
        (list* 'let* (cdr bindings) body) )))


;;;; Simple control

(defVau prog1 (form . forms) env
  #|Evaluate FORM and any additional FORMS, and return the result of FORM.
   |#
  (let1 (result (eval form env))
    (eval (list* begin forms) env)
    result))

(defMacro (when test . body)
  #|If TEST yields true, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list 'if test (list* 'begin body)))

(defMacro (unless test . body)
  #|If TEST yields false, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list* 'if test #inert body))

(defVau set (environment definiendTree value) dynamicEnvironment
  #|Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT,
   |creating or updating existing bindings.  Unlike Common Lisp (or
   |Scheme), we have no `setq' (or `set!') that allows updating arbitrary
   |bindings -- you always need to know the environment a binding is in to
   |change it.  Therefore, we usually use boxes (see below) instead of
   |mutating bindings directly.
   |#
  (eval (list 'def definiendTree (list (unwrap eval) value dynamicEnvironment))
        (eval environment dynamicEnvironment)))

(def\ assert (boolean)
  #|Signal an error if the BOOLEAN is false.  Otherwise return void.
   |#
  (unless boolean (error (makeInstance AssertionError :type 'assertion :datum boolean :expectedType #t))))


;;;; Bind? IfBind? CaseVau Case\ Match

(defVau (ifBind? (pt exp) then . else) env
  (let1 (env+ (makeEnv env))
    (if (bind? env+ pt (eval exp env))
      (eval then env+)
      (unless (null? else)
        (eval (let1 ((exp) else) exp) env) ))))

(defVau (caseVau . clauses) env 
  (vau values #ignore
    (let1 loop (clauses clauses)
      (if (null? clauses) #inert
        (let ( (env+ (makeEnv env))
               (((bindings . forms) . clauses) clauses) )
          (if (if (== bindings 'else) #t (bind? env+ bindings values)) ; or!
            (eval (list* 'begin forms) env+)
            (loop clauses) ))))))
            
(defMacro (case\ . clauses)
  (list 'wrap (list* 'caseVau clauses)) )

(defMacro (match exp . clauses)
  (list (list* 'case\ (map (\ ((a . b)) (list* (if (== a 'else) a (list a)) b)) clauses)) exp) )  



;;; Cond And Or

(defVau (cond . clauses) env
  #|Multi-armed conditional.
   |Go through the CLAUSES in order.  Evaluate the TEST.
   |If it yields true, evaluate the FORMS as an implicit `begin'.
   |If it yields false, go to the next clause,
   |or return void if there are no more clauses.
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (test->bool . forms))
   |$(syntax clause (test))
   |$(syntax clause (test => apv1))
   |$(syntax clause (test guard => apv1))
   |#
  (unless (null? clauses)
    (let1 (((test . body) . clauses) clauses)
      (if (== test 'else)
        (apply (wrap begin) body env)
        (let1 (test (eval test env))
          (if (instanceOf? test Boolean)
            (if test
              (apply (wrap begin) body env)
              (apply (wrap cond) clauses env) )
            (match body
              (() test)
              (('=> apv1) ((eval apv1 env) test))
              ((guard '=> apv1)
                 (if ((eval guard env) test)
                   ((eval apv1 env) test)
                   (apply (wrap cond) clauses env) ))
              (else (apply (wrap cond) clauses env)) )))))))

(defVau and operands env
  #|Return true if all OPERANDS evaluate to true, false otherwise.  If
   |an operand evaluates to false, later operands are not evaluated.  If
   |there are no operands, return false.
   |#
  (cond ((null? operands)          #t)
        ((null? (cdr operands))    (the Boolean (eval (car operands) env)))
        ((eval (car operands) env) (eval (cons and (cdr operands)) env))
        (else                      #f)))

(def && and)

(defVau or operands env
  #|Return true if one of the OPERANDS evaluates to true, false
   |otherwise.  If an operand evaluates to true, later operands are not
   |evaluated.  If there are no operands, return true.
   |#
  (cond ((null? operands)          #f)
        ((null? (cdr operands))    (the Boolean (eval (car operands) env)))
        ((eval (car operands) env) #t)
        (else                      (eval (cons or (cdr operands)) env))))

(def || or)


;;;; Member Assoc Get

(def\ (member key lst . keywords)
  #|Search for ITEM in the LIST according to the TEST predicate
   |(defaults to `==').  Return the tail of the list starting with
   |ITEM if found, nil otherwise.  The KEY function is applied to
   |each list element before comparison (defaults to `identity').
   |$(fn (item list &key test key))
   |#
  (let ( (test (opt? (get? :test keywords) ==))
         (fkey (opt? (get? :fkey keywords) identity)) )
    (let1 member (lst lst)
      (if (null? lst) #null
        (if (test (fkey (car lst)) key) lst
          (member (cdr lst)))))))

(def\ (assoc key lst)
  (let1 loop (lst lst)
     (if (null? lst) #null
       (let1 ((kv . lst) lst)
         (if (== (car kv) key) kv
           (loop lst) )))))

(def\ (get? key lst)
  #|Search for the KEYWORD in the property list LST (a list
   |of alternating keywords and values) and return the found value as an
   |option.
   |#
  (let1 loop (lst lst)
    (if (null? lst) #null
      (let1 ((k v . lst) lst)
        (if (eq? k key) (some v)
          (loop lst)) ))))


;;; Case CaseType

(defVau (case exp . clauses) env
  (let1 (value (eval exp env))
    (let1 loop (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((values . forms) . clauses) clauses)
          (if (or (== values 'else) (cons? (member value values)))
            (if (== (car forms) '=>)
              (let1 ((apv) (cdr forms)) ((eval apv env) value))  
              (eval (list* 'begin forms) env) )
            (loop clauses) ))))))

; vedi signalsError in vm.lispx (o test-util.lispx) per codice simile
(defVau (caseType key . clauses) env
  #|Multi-armed type test.
   |Evaluate the KEYFORM.  Go through the CLAUSES.  If the result of
   |evaluating KEYFORM is an instance of the class named by CLASS-NAME,
   |evaluate the FORMS as an implicit `begin'.  Otherwise go to the next
   |clause, or return void if there are no more clauses.
   |$(fn (key . clauses))
   |$(type fexpr)
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (className . forms))
   |$(syntax clause ((className . slotSpecs) . forms))
   |#
  (let1 (key (eval key env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((test . forms) . clauses) clauses)
          (if (|| (== test 'else)
                  (let* ( (symbol? (%symbol? test))
                          (class (eval (if symbol? test (car test)) env)) )
                    (&& (type? key class) (|| symbol? (&& (type? key Obj) (checkSlots key (map (\ (x) (eval x env)) (cdr test))) ))) ))
            (if (== (car forms) '=>)
              (let1 ((apv) (cdr forms)) ((eval apv env) key))  
              (eval (list* 'begin forms) env) )
            (next clauses) ))))))

(def\ (checkSlots obj slots)
  (let1 next (slots slots)
    (if (null? slots) #t
      (let1 ((name value . slots) slots)
        (if (or (! (@isBound obj name)) (! (eq? (obj name) value))) #f
          (next slots) )))))



;;; Options ~= if!#null or ifList

;; An option is either nil ("none"), or a one-element list ("some").
;; Variables holding options are conventionally suffixed with "?".

(def\ some (value)
  #|Create a one-element list from the VALUE.
   |#
  (list value))

(def\ (\01+ forms) 
  (if (null? forms) #null (if (null? (cdr forms)) (car forms) (list* 'begin forms))) )

(defVau (ifOpt? (pt opt?) then . else) env
  #|Destructure the OPTION?.  If it's non-nil, evaluate the THEN form
   |with the NAME bound to the contents of the option.  If it's nil,
   |evaluate the ELSE form.
   |#
   ;; (Idea from Taylor R. Campbell's blag.)
  (let1 (opt? (eval opt? env))
    (if (null? opt?)
      (if (null? else) #null
        (eval (\01+ else) env))
      (if (list? opt?)  
        (eval (list* (list 'vau (list pt) #ignore then) opt?) env)
        (error (makeTypeError opt? '(or Null List))) ))))

(defVau (ifOpt*? (pt opt?) then . else) env
  (let1 (opt? (eval opt? env))
    (if (null? opt?)
      (if (null? else) #null
        (eval (\01+ else) env))
      (if (list? opt?)  
        (eval (list* (list 'vau pt #ignore then) opt?) env)
        (error (makeTypeError opt? '(or Null List))) ))))

(defMacro whenOpt? ((pt opt?) . forms)
  #|Destructure the OPTION?.  If it's non-nil, evaluate the FORMS with
   |the NAME bound to the contents of the option.  If it's nil, return nil.
   |#
  (list 'ifOpt? (list pt opt?) (\01+ forms)) )

(defMacro unlessOpt? (opt? . forms)
  #|Destructure the OPTION?.  If it's nil, evaluate the FORMS.  If it's
   |non-nil, return nil.
   |#
  (list* 'ifOpt? (list #ignore opt?) #null (\01+ forms)) )

(defVau (caseOpt? exp . clauses) env
  (let1 (exp (eval exp env))
    (if (null? exp) #null
      (let1 loop (clauses clauses)
        (if (null? clauses) #null
          (let ((env+ (makeEnv env))
                (((bindings . forms) . clauses) clauses) )
            (if (or (== bindings 'else) (bind? env+ bindings exp))
              (eval (list* 'begin forms) env+)
              (loop clauses) )))))))

(defMacro (opt? exp . dft)
  #|Return the contents of the OPTION?, or the DEFAULT? if the option
   |is nil.  The default itself defaults to void.  The DEFAULT? is
   |evaluated lazily, only when the OPTION? is nil.
   |#
  (list* ifOpt? (list 'exp exp) 'exp dft))

(defVau opt*? (lst . dft) env
  #|Similar to `opt', but provides DEFAULTS for any number of
   |elements of LIST.  This is useful for implementing functions that take
   |multiple opt? arguments.  Each default is evaluated lazily, only when needed.
   |#
  (let loop ((lst (eval lst env)) (dft dft))
    (if (null? lst) 
      (if (null? dft) #null
         (cons (eval (car dft) env) (loop #null (cdr dft))) )
      (if (null? (car lst))
        (if (null? dft)
          (cons #null (loop (cdr lst) #null))
          (cons (eval (car dft) env) (loop (cdr lst) (cdr dft))) )
        (cons (car lst)
          (loop (cdr lst) (if (null? dft) #null (cdr dft)))) ))))

(def\ getOpt? (option?)
  #|Returns the contents of the OPTION? or signals an error if it is nil.
   |#
  (opt? option? (error (simpleError "Option is nil"))))


;;; Loop

(defVau block (blockName . forms) env
  #|Establish a block named BLOCK-NAME and evaluate the FORMS as an
   |implicit `begin' inside it.  The forms may use `returnFrom' to
   |nonlocally exit from the block.
   |Note that unlike in Common Lisp, there is no separate namespace for
   |block names; a block is named in the normal variable namespace.
   |#
  (let* ( (tag (list #inert)) ; cons up a fresh object as tag
          (escape (\ (value) (throw tag value))) )
    (catch tag
      (eval (list (list* '\ (list blockName) forms) escape) env) )))

#|
(defVau block (blockName . forms) env
  (def tag (list #inert)) ; cons up a fresh object as tag
  (def\ (escape value) (throw tag value))
  (catch tag
    (eval (list (list* '\ (list blockName) forms) escape)
          env )))
|#

(def\ returnFrom (blockName . value?)
  #|Abort evaluation and return the optional VALUE? (which lsts to
   |void) from the block named BLOCK-NAME.  It is an error to return from
   |a block whose dynamic extent has ended.
   |$(fn (blockName . value?))
   |#
  (blockName (opt? value? #inert)) )

(defVau while (testForm . forms) env
  #|Evaluate FORMS while TEST-FORM evaluates to true.
   |#
  (let ((forms (list* 'begin forms)))
    (block exit
      (loop
        (if (eval testForm env)
            (eval forms env)
            (returnFrom exit #inert))))))

(defMacro until (testForm . forms)
  #|Evaluate FORMS until TEST-FORM evaluates to true.
   |#
  (list* while (list '! testForm) forms) )

(defMacro dotimes ((var countForm . resultForm?) . bodyForms)
  #|Cf. Common Lisp's DOTIMES.
   |#
  (let\ ((_dotimes_ (n body result)
           (let ((i (box 0)))
             (while (< (i) n)
               (body (i))
               (i (+ (i) 1)))
             (result (i)))))
    (list _dotimes_
          countForm
          (list* '\ (list var) bodyForms)
          (list* '\ (list var) resultForm?))))

(def\ (withEscape fun)
  (let1 (fresh (list #null))
    (catch (fun (\ opt? (throw (list fresh (ifOpt? (val opt?) opt?) ))))
      (\ (exc)
        (if (and (cons? exc) (== (car exc) fresh))
          (let1 ((#ignore opt?) exc) (if (cons? opt?) (car opt?)))
          (throw exc))))))

(defMacro (label name . body)
  (list 'withEscape (list* '\ (list name) body)))


;;; Type Checks

;; TODO non più necessario, eliminare
(def\ assertType (object class)
  #|Signal a `type-error' if the OBJECT is not an instance of the CLASS.|#
  (if (type? object class) object
    (error (makeTypeError object (className class)))))

(def\ makeTypeError (datum expectedType)
  #|Create a `type-error' with the given DATUM and EXPECTED-TYPE.|#
  (makeInstance TypeError :datum datum :expectedType expectedType))

#| TODO sostituiti dal seguente
(defVau the (className object) env
  #|Shorthand for `assertType'.  Signal a `type-error' if the OBJECT
   |is not an instance of the class named by CLASS-NAME.
   |#
  (assertType (eval object env) (eval (%the Symbol className) env)))

(def\ the (class object)
  (assertType object class) )
|#

(def the
  #|Signal a `type-error' if the OBJECT is not an instance of the CLASS, else return object.
   |$(fn (class object)
   |$(type function)
   |#
  %the)

(defMacro (type\ params . body)
  (let1rec\ ( (typedParams->namesAndChecks ps)
              (if (cons? ps)
                  (let* ( ((p . ps) ps)
                          ((names . checks) (typedParams->namesAndChecks ps)) )
                    (if (cons? p)
                        (let* ( ((name type) p)
                                (check (list 'the type name)))
                          (cons (cons name names) (cons check checks)) )
                        (cons (cons p names) checks) ))
                  (cons ps ()) ))
    (let1 ((names . checks) (typedParams->namesAndChecks params))
      (list* '\ names (if (null? checks) body (list* (list* 'begin checks) body))) )))

(defMacro (define lhs . rhs)
  (if (symbol? lhs)
    (list 'def lhs (car rhs))
    (list 'def (car lhs) (list* 'type\ (cdr lhs) rhs)) ))

(def\ ck|| o (list->array o))
(def ck+ (.MAX_VALUE Integer))
(def\ check (op o . ck) (@check vm op o ck))


;;; Lists

(def\ (any? f lst . lst*)
  (if (null? lst*)
    ((rec\ (any? lst) (if (null? lst) #f (if (f (car lst)) #t (any? (cdr lst)))) ) lst)
    ((rec\ (any*? lst*) (if (null? (car lst*)) #f (if (apply f (map car lst*)) #t (any*? (map cdr lst*))))) (cons lst lst*)) ))

(def\ (all? f lst . lst*)
  (if (null? lst*)
    ((rec\ (all? lst) (if (null? lst) #t (if (f (car lst)) (all? (cdr lst)) #f))) lst)
    ((rec\ (all*? lst*) (if (null? (car lst*)) #t (if (apply f (map car lst*)) (all*? (map cdr lst*)) #f))) (cons lst lst*)) ))
    
(def\ (forEach f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect.  Return the #inert.
   |#
  (if (null? lst*)
    ((rec\ (forEach lst) (unless (null? lst) (f (car lst)) (forEach (cdr lst)))) lst)
    ((rec\ (forEach* lst*) (unless (null? (car lst*)) (apply f (map car lst*)) (forEach* (map cdr lst*)) )) (cons lst lst*)) ))

(def\ (forEach f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect.  Return the list.
   |#
  (if (null? lst*)
    (let1 (res lst) ((rec\ (forEach lst) (if (null? lst) res (f (car lst)) (forEach (cdr lst)))) res))
    (let1 (res* (cons lst lst*)) ((rec\ (forEach* lst*) (if (null? (car lst*)) res* (apply f (map car lst*)) (forEach* (map cdr lst*)) )) res*) )) )

(def\ maplist (f lst . lst*)
  #|Apply the FUNCTION, which must return a list, to every element of the
   |LIST, and append the results.  (Note: this currently uses `append',
   |but might be changed to use `nconc' in the future, like Common Lisp.)
   |#
  (if (null? lst*)
    ((rec\ (maplist lst) (if (null? lst) #null (append (f (car lst)) (maplist (cdr lst))))) lst)
    ((rec\ (maplist* lst*) (if (null? (car lst*)) #null (append (apply f (map car lst*)) (maplist* (map cdr lst*))))) (cons lst lst*)) ))

(def\ (filter f lst . lst*)
  (if (null? lst*)
    ((rec\ (filter lst) (if (null? lst) #null (if (f (car lst)) (cons (car lst) (filter (cdr lst))) (filter (cdr lst))))) lst)
    ((rec\ (filter* lst*) (if (null? (car lst*)) #null (let1 (cars (map car lst*)) (if (apply f cars) (cons cars (filter* (map cdr lst*))) (filter* (map cdr lst*)) )))) (cons lst lst*)) ))

(defMacro (remove f lst . lst*)
  #|Return a new list from which the elements that satisfy the TEST have been removed.
   |#
  (list* 'filter (list 'compose '! f) lst lst*) )


(def\ (reduceL f init lst . lst*)
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (reduce (f acc (car lst)) (cdr lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (reduce* (%apply* f acc (map car lst*)) (map cdr lst*)) )) init (cons lst lst*)) ))

(def reduce
  #|Use the binary FUNCTION to combine the elements of the LIST.  The
   |INITIAL-VALUE is logically placed before the list.
   |#
  reduceL)

(def\ (reduceR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (f (reduce acc (cdr lst)) (car lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (%apply* f (reduce* acc (map cdr lst*)) (map cadr lst*)) )) init (cons lst lst*)) ))

(def\ (foldL f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldl acc lst) (if (null? lst) acc (foldl (f (car lst) acc) (cdr lst)) )) init lst)
    ((rec\ (foldl* acc lst*) (if (null? (car lst*)) acc (foldl* (%apply* f (map car lst*) acc) (map cdr lst*)) )) init (cons lst lst*)) ))

(def\ (foldR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldr acc lst) (if (null? lst) acc (f (car lst) (foldr acc (cdr lst)) ) )) init lst)
    ((rec\ (foldr* acc lst*) (if (null? (car lst*)) acc (%apply* f (map car lst*) (foldr* acc (map cdr lst*)) ) )) init (cons lst lst*)) ))

(defMacro dolist ((var listForm . resultForm?) . bodyForms)
  #|Cf. Common Lisp's DOLIST.|#
  (let1rec\ (_dolist_ (list body result)
             (if (null? list)
                 (result list)
                 (begin
                   (body (car list))
                   (_dolist_ (cdr list) body result))))
    (list _dolist_
          listForm
          (list* '\ (list var) bodyForms)
          (list* '\ (list var) resultForm?))))

(def\ (make\* n f)
  (def\ (resize n lst)
    (let loop ((n n) (h ()) (t lst))
      (if (null? t) (reverse h)
        (if (<= n 1)
          (reverse (cons (if (null? (cdr t)) (car t) t) h))
          (loop (- n 1) (cons (car t) h) (cdr t)) ))))
  (\ lst (apply f (resize n lst))))


;;; Dynamic Binding

#| TODO primitiva non più necessaria, eliminare
(def %d\
  (vau (var* . body) #ignore
    (wrau val* env
        (def\ (ckdvar var)
            (def lkp (@get env var))
            (def ndv (.value lkp))
            ;(if (or (and (null? body) (null? ndv)) (instanceOf? ndv DVar)) ndv
            ;  (error ($ "not " (if (null? body) "null or " "") "a dynamic value: " var)) )
            (if (or (and (null? body) (! (.isBound lkp))) (instanceOf? ndv DVar)) ndv
              (error ($ "not " (if (null? body) "unbound or " "") "a dynamic value: " var)) ))
        (def ndv* (map ckdvar var*))
        (unless (null? body) (def old* (map (\ (ndv) (if (null? ndv) ndv (ndv))) ndv*)))
        (forEach (\ (ndv var val) (if (instanceOf? ndv DVar) (ndv val) (@def env var (dvar val)) )) ndv* var* (if (null? val*) (map (\ (var) #null) var*) val*))
        (unless (null? body)
          (finally
            (eval (list* 'begin body) env) 
            (forEach (\ (ndv old) (ndv old)) ndv* old*) )))))

;((d\ (d e) (print e)) 4 5)     
;((d\ (d e)) 6 7)
|#

(defMacro (ddef var . val?)
  #|Define a new or update an existing dynamic variable with the given
   |NAME and opt? default VALUE.
   |$(fn (name))
   |$(fn (name value))
   |#
  (list* (list '%d\ (list var)) val?) )

(defMacro (ddef* var* . val*)
  (list* (list '%d\ var*) val*) )

(def\ dget (dynamicVariable)
  #|Return the current value of the DYNAMIC-VARIABLE.|#
  (dynamicVariable))

(def\ dset (dynamicVariable value)
  #|Set the current value of the DYNAMIC-VARIABLE.|#
  (dynamicVariable value))

(defMacro (dlet bindings exp . exps)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established parallely
   |as per `let'.
   |$(syntax binding (dynamicVariable value))
   |#
  (list* (list* '%d\ (map car bindings) exp exps) (map cadr bindings)) )  

(defMacro (progv var* val* exp . exps)
  #|Evaluate the FORMS with the list of DYNAMIC-VARIABLES temporarily
   |bound to new VALUES.  The DYNAMIC-VARIABLES and VALUES lists must have
   |the same length.
   |#
  (list* (list* '%d\ var* exp exps) val*) )

(defMacro (dlet* bindings . forms)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established serially as
   |per `let*'.
   |#
  (if (null? bindings)
    (list* 'begin forms)
    (list 'dlet
      (list (car bindings))
      (list* 'dlet* (cdr bindings) forms) )))


;;;; Box

(def box %box)

(defMacro (defBox name . value?)
  (list 'def name (list* 'box value?)) )


;;; Classes

(def\ findClass (name environment)
  #|Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT.|#
  (eval (the Symbol name) environment))

(defVau defClass (name superclass? slotSpecs . properties) env
  #|Define a new `StandardClass' with the given NAME, optional
   |SUPERCLASS?, and SLOT-SPECS.  The superclass defaults to
   |`standard-object'.  The SLOT-SPECS and PROPERTIES are currently
   |ignored.
   |$(syntax slotSpec symbol)
   |$(syntax property (:documentation docstring))
   |#
   ;; Slot-specs are ignored for now, but check that they are symbols nevertheless.
  (dolist (slotSpec slotSpecs) (the Symbol slotSpec))
  (let1 (superclass (findClass (opt? superclass? 'StandardObject) env))
    (eval (list def name (%makeStandardClass name superclass)) env)) )


;;; Standard Objects

(def makeInstance
  #|Create a new instance of CLASS (that must be a `standard-class').
   |The SLOT-INITS must be of even length, and alternately contain slot
   |names (symbols, typically keywords) and values.
   |$(fn (class . slotInits))
   |#
  obj)

(def\ getSlot (object slotName)
  #|Return the value of the slot named SLOT-NAME of the OBJECT.|#
  (%getSlot object slotName))

(def\ setSlot (object slotName value)
  #|Set the value of the slot named SLOT-NAME of the OBJECT to VALUE.|#
  (%setSlot object slotName value))

(def\ slotBound? (object slotName)
  #|Return true if the slot named SLOT-NAME of the OBJECT is set, false otherwise.|#
  (%slotBound? object slotName))

(defMacro (defObj name class . attr)
  (list 'def name (list* obj class attr)) )


;;; Generic Functions

;; receiver e parameters dei defMethod dovrebbero corrispondere a quelli del corrispondente defGeneric con quel nome

(defVau (defGeneric . args) env
  #|Define a new generic function with the given NAME.  The RECEIVER,
   |PARAMETERS, and PROPERTIES are currently ignored.
   |$(syntax property (:documentation docstring))
   |#
  (if (symbol? (car args))
    (def (name (receiver . parameters) . properties) args)
    (def ((name receiver . parameters) . properties) args) )
  (let1\ (generic args (apply (%getMethod (classOf (car args)) name) args))
    (eval (list 'def name generic) env) ))

(defVau (defMethod . args) env
  #|Add a new method to the generic function named by NAME specialized
   |for the class named by CLASS-NAME.
   |#
  (if (symbol? (car args))
    (def (name ((receiver class) . parameters) . forms) args)
    (def ((name (receiver class) . parameters) . forms) args) )
  (let1 (method (eval (list* '\ (list* receiver parameters) forms) env))
    (%addMethod (findClass class env) name method)
    method ))



;;; Modules

(defVau (provide symbols . body) env
  (eval
    (list 'def symbols
      (list 'let ()
        (list* 'begin body)
        (list* 'list symbols) ))
    env ))

(defVau (module exports . body) env
  (let ((env (makeEnv env)))
    (eval (list* 'provide exports body) env)
    (makeEnv env) ))

(defMacro (defModule name exports . body)
  (list 'def name (list* 'module exports body)) )

(defVau (import module imports) env
  (let* ((module (eval module env))
         (values (map (\ (import) (eval import module)) imports)) )
    (eval (list* 'def* imports values) env) ))


;;; Relational Operators

;; Note that unlike in Common Lisp, these operators currently require
;; at least two arguments.  This will be improved in the future.

(def\ (relationalOp binop)
  #|Utility to create an n-ary relational operator from a BINARY-OPERATOR.|#
  (rec\ (op arg1 arg2 . rest)
    (if (binop arg1 arg2)
      (if (null? rest) #t
        (apply op (list* arg2 rest)))
      #f )))

(def == (relationalOp ==))

(def eq?
  #|Return true if all ARGUMENTS are equal, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp eq?) )

(def <
  #|Return true if the ARGUMENTS are in monotonically increasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp <) )

(def >
  #|Return true if the ARGUMENTS are in monotonically decreasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp >) )

(def <=
  #|Return true if the ARGUMENTS are in monotonically nondecreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp <=) )

(def >=
  #|Return true if the ARGUMENTS are in monotonically nonincreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp >=) )

(def\ /= (arg . args)
  #|Return true if no two ARGUMENTS are the same, false otherwise.
   |$(fn arguments)
   |#
  (if (null? args) #t
    (if (cons? (member arg args :test eq?)) #f
      (apply /= args) )))


;;; Numbers

;; The terms thetic (for + and *) and lytic (for - and /) are due to Hankel.

(def\ (theticOp binOp unit)
  #|Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |#
  (\ args (reduceL binOp unit args)) )

(def +
  #|Return the sum of the ARGUMENTS, or 0 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp + 0) )

(def *
  #|Return the product of the ARGUMENTS, or 1 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp * 1) )

(def $
  #|Return the join of the ARGUMENTS, or "" if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp $ "") )


(def\ (lyticOp binOp unit)
  #|Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |#
  (\ (arg1 . rest)
    (if (null? rest)
      (binOp unit arg1)
      (reduceL binOp arg1 rest) )))

(def -
  #|If only one number is supplied in the ARGUMENTS, return the
   |negation of that number. If more than one number is supplied, subtract
   |all of the later ones from the first one and return the result.
   |$(fn arguments)
   |$(type function)
   |#
  (lyticOp - 0) )

(def /
  #|If only one number is supplied in the ARGUMENTS, return the
   |reciprocal of that number.  If more than one number is supplied,
   |divide the first one by all of the later ones and return the result.
   |$(fn arguments)
   |$(type function)
   |# 
  (lyticOp / 1) )


;;;; Greatest Common Divisor e Lowest Common Multiple

(def\ (gcd a b . more)
  (if (null? more) 
    (if (zero? b) a (gcd b (% a b)))
    (gcd a (apply gcd (cons b more))) ))

(def abs (let1 (abs (@getMethod Math "abs" &int)) (\ (n) (abs #null n))))  

(def\ (lcm a b . more)
  (if (null? more)
    (if (or (zero? a) (zero? b)) 0
      (abs (* b (/ a (gcd a b)))) )
    (lcm a (apply lcm (cons b more))) ))



;;; Sequences

(defGeneric length (sequence)
  #|Return the number of elements in a sequence.|#)

(defMethod length ((seq List))
  (%len seq))

(defMethod length ((seq Null))
  (%len seq))

(defGeneric elt (sequence index)
  #|Return the sequence element at the specified index.|#)

(defMethod elt ((seq List) index)
  (nth index seq))

(defGeneric subseq (sequence start . end?)
  #|Create a sequence that is a copy of the subsequence
   |of the SEQUENCE bounded by START and optional END?.  If END?  is not
   |supplied or void, the subsequence stretches until the end of the list
   |#)

(defMethod subseq ((seq List) start . end?)
  (%listSubseq seq start (opt? end? #inert)))

(defMethod subseq ((seq Null) start . end?)
  (%listSubseq seq start (opt? end? #inert)))

(defMethod subseq ((seq String) start . end?)
  (%stringSubseq seq start (opt? end? #inert)))


;;; Coroutines

(defConstant +defaultPrompt+
  #|This prompt is used for general coroutine-like use of continuations.
   |#
  'defaultPrompt)

(defMacro coroutine forms
  #|Evaluate the FORMS in a context in which `yield' can be used to pause execution.
   |#
  (list* 'pushPrompt '+defaultPrompt+ forms))

(defMacro yield (name . forms)
  #|Pause the current coroutine.  In the place where the enclosing
   |`coroutine' (or `resume') was called, evaluate the FORMS with NAME
   |bound to the paused coroutine.  `resume' can later be used to restart
   |execution inside the coroutine.
   |#
  (list* 'takeSubcont '+defaultPrompt+ name forms))

(defMacro resume (k . forms)
  #|Resume the paused coroutine K and evaluate FORMS in the place where
   |`yield' was called in the coroutine.
   |#
  (list* 'pushDelimSubcont '+defaultPrompt+ k forms))
;;;; Auto Increment/Decrement and Assignement Operator

(defVau ($set! exp1 formals exp2) env
  (eval (list 'def formals (list '(unwrap eval) exp2 env)) (eval exp1 env)))

(defVau (++ plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (+ (val) 1))))
    (Obj (let1 ((fld) args) (val fld :rhs (+ (val fld) 1)))) 
    (Number (let1 (() args) (eval (list '%set! plc :rhs (+ val 1)) env)))
    (else   (error ($ "not valid type: " val))) )) 

(defVau (-- plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (- (val) 1))))
    (Obj (let1 ((fld) args) (val fld :rhs (- (val fld) 1)))) 
    (Number (let1 (() args) (eval (list '%set! plc :rhs (- val 1)) env)))
    (else   (error ($ "not valid type: " val))) ))

(def\ (assignOp op)
  (vau (plc . args) env
    (def lval (eval plc env))
    (caseType lval
      (Box (match args 
        ((rval) (lval (op (lval) (eval rval env)))) 
        ((key rval) (lval key (op (lval) (eval rval env)))) ))
      (Obj (match args
        ((fld rval) (lval fld (op (lval fld) (eval rval env))))
        ((fld key rval) (lval fld key (op (lval fld) (eval rval env)))) ))
      (Object (match args
        ((rval) (eval (list 'def plc (op lval (eval rval env))) env))
        ((key rval) (eval (list '%set! plc key (op lval (eval rval env))) env)) ))))) 

(def $= (assignOp %$))
(def += (assignOp %+))
(def -= (assignOp %-))



;;;; Utilities

(def\ (array . args) (list->array args))

(def Array &java.lang.Object[])

(define (arrayMap fun (arr Array))
  (list->array (map fun (array->list arr))) )

(define (arrayFilter pred (arr Array))
  (list->array (filter pred (array->list arr))) )

(defVau (time exp) env
  (let1 (currentTime (@getMethod System "currentTimeMillis"))
    (def milli (currentTime #null))
    (def result (eval exp env))
    (def milli (- (currentTime #null) milli))
    (log ($ "time " exp ": " milli "ms"))
    result ))


;;;; Error break routine, called by VM to print stacktrace and throw

(def\ invokeDebugger (condition)
  #|Invoke the debugger, which as a default just prints a stack trace
   |and panics, thereby throwing an exception to JS.  When running in the
   |REPL, this function gets replaced with a different one that runs a
   |nested debug loop.
   |#
  (takeSubcont +rootPrompt+ k
    (pushDelimSubcont +rootPrompt+ k
      (%printStacktrace k)
      (panic condition))))

