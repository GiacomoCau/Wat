;;;                                                     -*- mode: Scheme -*-
;;; LispX Bootstrap
;;;

;; Copyright (c) 2021, 2022 Manuel J. Simoni

;; ``72. An adequate bootstrap is a contradiction in terms.''

;; Rename %def

(%def def
  #|Match the DEFINIEND-TREE against the VALUE and place resulting
   |bindings into the current environment.
   |$(fn (definiendTree value))
   |$(type fexpr)
   |#
  %def)


;;; Built-Ins - rename bindings that will be used as provided by VM

(def assert %assert)

(def ==
  #|Return true if the values A and B are pointer-identical, false otherwise.
   |$(fn (a b))
   |$(type function)
   |#
  %==)
(def != %!=)

(def string? %string?)
(def $ %$)

(def number? %number?)
(def + %+)
(def * %*)
(def - %-)
(def / %/)
(def % %%)

(def !
  #|Invert the BOOLEAN.
   |$(fn (boolean))
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  %!)
(def !! %!!)
(def < %<)
(def > %>)
(def <= %<=)
(def >= %>=)

(def ~ %~)
(def & %&)
(def \| %|)
(def ^ %^)
(def << %<<)
(def >> %>>)
(def >>> %>>>)

(def append
  #|Append two lists.  The first one must be proper and is copied.  The
   |second one is not copied (and doesn't even have to be a list). It
   |becomes the `cdr' of the final cons of the first list, or is returned
   |directly if the first list is empty.
   |$(fn (list1 list2))
   |$(type function)
   |#
  %append)

(def apply
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn (fun args . env))
   |$(type function)
   |$(derivation (eval (cons (unwrap fun) args) (if (null? env) (newEnv) ((\ ((env)) env) env))))
   |#
  %apply)

(def apply*
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn (fun . args)) 
   |$(type function)
   |$(derivation (apply fun args))
   |#
  %apply*)

(def apply**
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn (fun . args)) 
   |$(type function)
   |$(derivation (apply fun (apply list* args)))
   |#
  %apply**)

(def array->list %array->list)

(def atEnd
  #|valuate the PROTECTED-FORM and return its result.  Regardless of
   |whether the protected form returns normally, or via a nonlocal exit or
   |panic, the CLEANUP-FORM are evaluated after the protected forms.
   |$(fn (cleanupForm . protectedForms))
   |$(type fexpr)
   |#
  %atEnd)

(def begin
  #|Sequentially evaluate FORMS, returning the value of the last one, or void if there are no forms.
   |$(fn forms)
   |$(type fexpr)
   |#
  %begin)

(def bind? %bind?)

(def bound?
  #|Return true if the SYMBOL is bound in the ENVIRONMENT, false otherwise.
   |$(fn (symbol environment))
   |$(type function)
   |#
  %bound?)

(def newBox
  #|Create a new box with the optional INITIAL-VALUE?.  A box is a
   |function that encapsulates a mutable value.  Calling the box without
   |arguments returns the value.  Calling the box with an argument sets
   |the value.
   |$(fn initialValue?)
   |$(type function)
   |#
  %newBox)

(def cons
  #|Create a cons with the given CAR and CDR.
   |$(fn (car cdr))
   |$(type function)
   |#
  %cons)

(def cons?
  #|Return true if the OBJECT is a cons, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %cons?)

(def className
  #|Return the name symbol of the CLASS.
   |$(fn (class))
   |$(type function)
   |#
  %className)

(def classOf
  #|Return the class of the OBJECT.
   |$(fn (object))
   |$(type function)
   |#
  %classOf)

(def dval %dVal)
(def newDVar %newDVar)
(def eq? %eq?)
(def eval
  #|Evaluate the FORM in the ENVIRONMENT, returning its result.
   |$(fn (form environment))
   |$(type function)
   |#
  %eval)

(def if
  #|Evaluate the TEST which must yield a boolean.  Then evaluate either
   |the CONSEQUENT or ALTERNATIVE depending on whether the TEST yielded
   |true or false.
   |$(fn (test consequent . alternative))
   |$(type fexpr)
   |#
  %if)

(def intern
  #|Get or create the unique symbol with STRING as name.
   |$(fn (string))
   |$(type function)
   |#
  %intern)

(def instanceOf? %instanceOf?)

(def keyword %keyword)
(def keyword? %keyword?)
(def keywordName %internName)
(def len %len)
(def list*
  #|Create a list from the ARGUMENTS so that the last argument becomes
   |the `cdr' of the list.
   |$(fn arguments)
   |$(type function)
   |#
  %list*)

(def list?
  #|Return true if the OBJECT is a list, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %list?)

(def list->array %list->array)
(def loop
  #|Evaluate the FORMS in an infinite loop.
   |$(fn forms)
   |$(type fexpr)
   |#
  %loop)

(def newEnv
  #|Create a new environment with an optional PARENT-ENVIRONMENT? in
   |which bindings are looked up if they are not found.
   |$(fn parentEnvironment?)
   |$(type function)
   |#
  %newEnv)

(def null?
  #|Return true if the OBJECT is nil, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %null?)
(def !null? %!null?)
(def not
  #|Invert the BOOLEAN.
   |$(fn (boolean))
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  !)

(def nth
  #|Return element number N of LIST, where the `car' is element zero.
   |$(fn (n list))
   |$(type function)
   |#
  %nth)

(def nthCdr
  #|Returns the tail of LIST that would be obtained by calling `cdr' N times in succession.
   |$(fn (n list))
   |$(type function)
   |#
  %nthCdr)

(def new
  #|Create a new instance of CLASS (that must be a `standard-class').
   |The SLOT-INITS must be of even length, and alternately contain slot
   |names (symbols, typically keywords) and values.
   |$(fn (class . slotInits))
   |#
  %new)

(def reverse
  #|Reverse the LIST.
   |$(fn (list))
   |$(type function)
   |#
  %reverse)
(def rootPrompt %rootPrompt)
(def set! %set!)
(def symbol %symbol)
(def symbol? %symbol?)

(def symbolName
  #|Return the name of the SYMBOL as a string.
   |$(fn (symbol))
   |$(type function)
   |#
  %internName)

(def subClass?
  #|Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.
   |A class is considered a subclass of itself.
   |$(fn (class superclass))
   |$(type function)
   |#
  %subClass?)

(def the %the)

(def type?
  #|Return true if the OBJECT is an instance of the CLASS, false otherwise.
   |$(fn (object class))
   |$(type function)
   |#
  %type?)
(def value %value)
(def unwrap
  #|Return the underlying operator of a FUNCTION.
   |$(fn (function))
   |$(type function)
   |#
  %unwrap)

(def wrap
  #|Create a new function that wraps around an underlying OPERATOR, and
   |induces argument evaluation around it.
   |$(fn (operator))
   |$(type function)
   |#
  %wrap)


;;; Core Forms

(def vau
  #|Construct a fexpr with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (parameterTree environmentParameter . forms))
   |$(type fexpr)
   |$(derivation (vau (pt ep . forms) env (eval (list 'vau pt ep (cons 'begin forms)) env)))
   |#
  %vau)

(def theEnv
  #|Return the current environment.
   |$(fn parent?)
   |$(type fexpr)
   |$(derivation (vau () environment environment)))
   |#
  %theEnv)

(def quote
  #|Return the unevaluated OPERAND.
   |$(fn (operand))
   |$(type fexpr)
   |$(derivation (vau (operand) #ignore operand))
   |#
  %')

(def list
  #|Return the list of evaluated ARGUMENTS.
   |$(fn arguments)
   |$(type function)
   |$(derivation (wrap (vau arguments #ignore arguments))
   |#
  %list)

(def \
  #|Create an anonymous function with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type function)
   |$(derivation (vau (formals . body) env (wrap (eval (list* vau formals #ignore body) env))))
   |#
  %\)

(def car
  #|Return the contents of the address part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %car)

(def cadr
  #|Return the `car' of the `cdr' of the CONS.
   |$(derivation (car (cdr cons)))
   |$(derivation (\ ((#_ . (cadr . #_))) cadr))
   |$(derivation (\ ((#_ cadr . #_)) cadr))
   |#
  %cadr)

(def cdr
  #|Return the contents of the decrement part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %cdr)

(def cddr
  #|Return the `cdr' of the `cdr' of the CONS.
   |$(derivation (cdr (cdr cons)))
   |$(derivation (\ ((#_ . (#_ . cddr))) cddr))
   |$(derivation (\ ((#_ #_ . cddr)) cddr))
   |#
  %cddr)

(def caar
  #|Return the `car' of the `car' of the CONS.
   |#
  (\ (x) (car (car x))))

(def cdar
  #|Return the `cdr' of the `car' of the CONS.
   |#
  (\ (x) (cdr (car x))))

(def compose
  #|Compose two functions, creating a new function equivalent to (G (F ...)).
   |#
  (\ (f g) (\ args (f (apply g args)))) )

(def identity
  #|Identity function.
   |#
  (\ (x) x))


;;; Macro

(def evalMacro (newDVar #t))

(def makeMacro
  #|Create a macro from an EXPANDER operator.  A macro is an operator
   |that receives an operand and produces a form (by calling the expander
   |with the operand as argument) that is then evaluated in place of the
   |operand.
   |$(fn (expander))
   |$(type function)
   |#
  (wrap
    (vau (expander) #ignore
      (vau operands env
        (def !evalMacro (! (evalMacro)))
        (if !evalMacro (evalMacro #t))
        (def exp (eval (cons expander operands) (newEnv)))
        (if !evalMacro exp (eval exp env)) ))))

(def macro
  #|Create an anonymous macro with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type macro)
   |#
  (makeMacro
    (vau (pt . forms) #ignore
      (list 'makeMacro (list* 'vau pt #ignore forms)) )))


; defMacro defVau def\ def*\ rec\ let1\ let1rec\ let\ letrec\ permettono la definizione in due forme
;
;    (_ name parameters . body)
;    (_ (name . parameters) . body)
;
; rec rec\ let1rec let1rec\ letrec letrec\ inizializzano a #inert le definizioni prima della valutazione


(def defMacro
  #|Define a macro with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (macro (lhs . rhs)
    (if (cons? lhs)
      (list 'def (car lhs) (list* 'macro (cdr lhs) rhs))
      (list 'def lhs (cons 'macro rhs)) )))

(defMacro (expand macro)
  (list 'begin (list 'evalMacro #f) macro) )

(defMacro (defVau lhs . rhs)
  #|Define a fexpr with the given NAME, PARAMETER-TREE,
   |ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (cons? lhs)
    (list 'def (car lhs) (list* 'vau (cdr lhs) rhs))
    (list 'def lhs (cons 'vau rhs)) ))

(def defConstant
  #|Define a constant with the given NAME and VALUE.  This is mostly
   |for documentation purposes, as constants are still mutable.
   |#
  def)

(defMacro (wrau pt ep . body)
  (list 'wrap (list* 'vau pt ep body)))

(defMacro (def* lhs . rhs)
  (list 'def lhs (cons 'list rhs)) )

(defMacro (def\ lhs . rhs)
  #|Define a function with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (cons? lhs)
    (list 'def (car lhs) (list* '\ (cdr lhs) rhs))
    (list 'def lhs (cons '\ rhs)) ))


;;;; Basic value test

(def\ (inert? o) (== o #inert))
(def\ (zero? n) (== n 0))
(def\ (even? n) (== (% n 2) 0))
(def\ (odd? n)  (== (% n 2) 1))


;;; Wrap incomplete VM forms

(def* (then else) begin begin)

(defMacro (finally x . cnl)
  (list 'atEnd (cons 'begin cnl) x) )  

(defMacro (throw . val) (list* '%throwTag #_ val) )
(def throwTag
  #|Abort to a nesting catch tag established by `catch' and pass the
   |optional RESULT? (defaults to void) to it.
   |$(fn (tag . val))
   |$(type macro)
   |#
  %throwTag)

;; ctApv non andrebbe mai cambiato dopo il boot, anche la riesecuzione di quanto segue potrebbe non bastare!
(if (ctApv)
  (then
    (defMacro (catch . forms)
      (list '%catchTagWth #_ #_ (list* '\ () forms)) )
    (defMacro (catchWth hdl . forms)
      (list '%catchTagWth #_ hdl (list* '\ () forms)) )
    (defMacro (catchTag tag . forms)
      #|Establish a catch tag and evaluate FORMS as an implicit `begin' inside it.
       |The forms may use `throw' to nonlocally exit from the tag.
       |Usually, `block' should be preferred.
       |#
      (list '%catchTagWth tag #_ (list* '\ () forms)) )
    (defMacro (catchTagWth tag hdl . forms)
      (list '%catchTagWth tag hdl (list* '\ () forms)) )
  )
  (defMacro (catch . forms)
    (list* '%catchTagWth #_ #_ forms))
  (defMacro (catchWth hdl . forms)
    (list* '%catchTagWth #_ hdl forms))
  (defMacro (catchTag tag . forms)
    #|Establish a catch tag and evaluate FORMS as an implicit `begin'
     |inside it.  The forms may use `throw' to nonlocally exit from the
     |tag.  Usually, `block' should be preferred.
     |#
    (list* '%catchTagWth tag #_ forms) )
  (def catchTagWth
    #|Establish a catch tag and evaluate FORMS as an implicit `begin' inside it.
     |The forms may use `throw' to nonlocally exit from the tag.
     |Usually, `block' should be preferred.
     |$(fn (tag hdl . forms))
     |$(type operatore)
     |#
    %catchTagWth)
)


;;; Delimited Control Operators

;; These operators follow the API put forth in the delimcc library
;; at URL `http://okmij.org/ftp/continuations/implementations.html'.

(defMacro (pushPrompt prompt . forms)
  #|Push the PROMPT and evaluate the FORMS inside the prompt.  This
   |delimits the continuation.
   |#
  (list '%pushPrompt prompt (list* '\ () forms)))

(defVau (pushPrompt prompt . forms) env
  (eval (list '%pushPrompt (eval prompt env) (cons 'begin forms)) env) )

(def takeSubcont
  #|Abort outwards to the PROMPT.  When the prompt is reached, evaluate
   |the FORMS with NAME bound to the captured continuation (which does not
   |include the prompt).
   |$(fn (prompt name . forms))
   |#
  %takeSubcont)

(defMacro (pushDelimSubcont prompt continuation . forms)
  #|Push the PROMPT and compose the previously captured CONTINUATION
   |inside it.  The FORMS are then evaluated inside the new continuation.
   |#
  (list '%pushDelimSubcont prompt continuation (list* '\ () forms)) )

(defMacro (pushSubcont continuation . forms)
  (list* 'pushDelimSubcont #ignore continuation forms) )

(defMacro (pushSubcont continuation . forms)
  #|We don't have `pushSubcont' but for these tests we can emulate itz
   |with a `pushDelimSubcont' that pushes an unused prompt.
   |#
  (list '%pushDelimSubcont #ignore continuation (list* '\ () forms)) )

(defMacro pushSubcontBarrier forms
  #|Push a continuation barrier that prevents the FORMS from capturing
   |any continuations to the outside.
   |#
  (list* '%pushSubcontBarrier (%newEnv) forms))


;;; Basic macros and functions

(defMacro (rec lhs . rhs)
  (list (list '\ (list lhs) (list* 'def lhs :rhs rhs)) #inert) )

(defMacro (rec\ lhs . rhs)
  (if (cons? lhs)
    (list 'rec (car lhs) (list* '\ (cdr lhs) rhs))
    (list 'rec lhs (cons '\ rhs)) ))

(def\ (map f lst . lst*)
  #|Create a new list by applying the FUNCTION to every element of the LIST.
   |#
  (if (null? lst*)
    ((rec\ (map lst) (if (null? lst) #null (cons (f (car lst)) (map (cdr lst))) )) lst)
    ((rec\ (map* lst*) (if (null? (car lst*)) #null (cons (apply f (map car lst*)) (map* (map cdr lst*))) )) (cons lst lst*)) ))

(defMacro (def*\ lhs* . rhs*)
  (list* 'def*
    (map (\ (lhs) (if (cons? lhs) (car lhs) lhs)) lhs*)
    (map (\ (lhs rhs) (cons '\ (if (cons? lhs) (cons (cdr lhs) rhs) rhs))) lhs* rhs*) ))


;;; Lexical Bindings

(def\ (->1expr binding) ((\ ((#_ cadr)) cadr) binding))
(def\ (->begin binding) ((\ ((#_ cadr . cddr)) (if (null? cddr) cadr (list* 'begin cadr cddr))) binding))
(def\ (->name+#inert (lhs . #_)) (list (if (cons? lhs) (car lhs) lhs) #inert))
(def\ (->name+lambda (lhs . rhs)) (if (cons? lhs) (list (car lhs) (list* '\ (cdr lhs) rhs)) (list lhs (cons '\ rhs)) ))
;(def\ (->name+lambda (lhs . rhs)) (list (if (cons? lhs) (car lhs) lhs) (list* '\ (if (cons? lhs) (cons (cdr lhs) rhs) rhs))))
;(def\ (->name+lambda (lhs . rhs)) (def t (cons? lhs)) (list (if t (car lhs) lhs) (list* '\ (if t (cons (cdr lhs) rhs) rhs))))
;(def\ (->name+lambda (lhs . rhs)) (list (if (def t :rhs (cons? lhs)) (car lhs) lhs) (list* '\ (if t (cons (cdr lhs) rhs) rhs))))


(defMacro (let1Loop lhs . rhs)
  (if (cons? lhs)
    (def* ((name . binding) body) lhs rhs)
    (def* (name (binding . body)) lhs rhs) )
  (list
    (list* 'rec\ name (list (car binding)) body)
    (->begin binding) ))

(defMacro (let1 lhs . rhs)
  (if (symbol? lhs)
    (list* 'let1Loop lhs rhs)
    (list (list* '\ (list (car lhs)) rhs)
      (->begin lhs) )))

(defMacro (let1\ binding . body)
  (list* 'let1 (->name+lambda binding) body))

(defMacro (let1rec binding . body)
  (def name (car binding))
  (list* 'let1 (list name #inert)
    (list 'def (car name (->begin binding))
      body )))

(defMacro (let1rec\ binding . body)
  (list* 'let1 (->name+#inert binding)
    (cons 'def\ binding)
    body ))

(defMacro (letLoop lhs . rhs)
  #|Labelled recursive loop, analogous to Scheme's named `let'.
   |Lexically bind a function named NAME with one PARAMETER for every
   |INITIALIZER and the FORMS as body.  Then immediately apply the
   |function to a list containing one VALUE for every INITIALIZER and
   |return the result.  The function is bound per `labels' so it can
   |recursively refer to itself.
   |$(fn (initializers . body))
   |$(fn (name initializers . body))
   |$(syntax initializers ((parameter value) . initializers)
   |#
  (if (cons? lhs)
    (def* ((name . bindings) body) lhs rhs)
    (def* (name (bindings . body)) lhs rhs) )
  (list*
    (list* 'rec\ name (map car bindings) body)
    (map ->begin bindings) ))

(defMacro (let lhs . rhs)
  #|Establish BINDINGS parallelly during the evaluation of FORMS, so
   |that no binding can refer to the other ones.
   |$(fn (bindings . body))
   |$(fn (name bindings . body))
   |$(syntax bindings ((parameter value) . bindings)
   |#
  (if (symbol? lhs)
    (list* 'letLoop lhs rhs)
    (list* (list* '\ (map car lhs) rhs)
      (map ->begin lhs) )))

(defMacro (let\ bindings . body)
  #|Establish FUNCTION-BINDINGS parallelly during evaluation of FORMS,
   |so that no function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  (list* 'let (map ->name+lambda bindings) body))

(defMacro (letrec bindings . body)
  #|Utility to establish BINDINGS recursively during the evaluation of
   |FORMS.  Used by `labels'.
   |#
  (def names (map car bindings))
  (list* 'let (map (\ (name) (list name #inert)) names)
    (list* 'def* names (map ->begin bindings))
    body ))

(defMacro (letrec\ bindings . body)
  (list* 'let (map ->name+#inert bindings)
    (list* 'def*\ (map car bindings) (map cdr bindings))
    body ))

(def labels
  #|Establish FUNCTION-BINDINGS recursively during evaluation of FORMS,
   |so that every function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  letrec\)

(defMacro (let* bindings . body)
  #|Establish BINDINGS serially during the evaluation of FORMS, so that
   |every binding can refer to previous ones.
   |$(syntax bindings ((definiendTree value) . bindings))
   |#
  (if (null? bindings)
      (list* 'let () body)
      (list 'let
        (list (car bindings))
        (list* 'let* (cdr bindings) body) )))


;;;; Simple Control

(defVau prog1 (form . forms) env
  #|Evaluate FORM and any additional FORMS, and return the result of FORM.
   |#
  (let1 (result (eval form env))
    (eval (cons 'begin forms) env)
    result))

(defMacro (when test . forms)
  #|If TEST yields true, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list 'if test (cons 'begin forms)))

(defMacro (unless test . forms)
  #|If TEST yields false, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list* 'if test #inert forms))

(defVau set (ep dt value) env
  #|Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT,
   |creating or updating existing bindings.  Unlike Common Lisp (or
   |Scheme), we have no `setq' (or `set!') that allows updating arbitrary
   |bindings -- you always need to know the environment a binding is in to
   |change it.  Therefore, we usually use boxes (see below) instead of
   |mutating bindings directly.
   |#
  (eval
    (list 'def dt (list (unwrap eval) value env))
    (eval ep env)))

(defVau if* clauses env
  (if (null? clauses) #inert
    (if (null? (cdr clauses)) (eval (car clauses) env)
      (let1 ((test then . else) clauses)
        (if (eval test env) (eval then env)
          (apply if* else env) )))))


;;; And Or

(defVau and ops env
  #|Return true if all OPERANDS evaluate to true, false otherwise.
   |If an operand evaluates to false, later operands are not evaluated.
   |If there are no operands, return false.
   |#
  (if (null? ops) #t
    (if (eval (car ops) env)
      (apply and (cdr ops) env)
      #f )))

(def && and)

(defVau or ops env
  #|Return true if one of the OPERANDS evaluates to true, false otherwise.
   |If an operand evaluates to true, later operands are not evaluated.
   |If there are no operands, return true.
   |#
  (if (null? ops) #f
    (if (eval (car ops) env) #t
      (apply or (cdr ops) env) )))

(def || or)


;;;; Bind? IfBind? CaseVau Case\ Match

(defVau (ifBind? (pt exp) then . else) env
  (let1 (env+ (newEnv env))
    (if (bind? env+ pt (eval exp env))
      (eval then env+)
      (unless (null? else)
        (eval (let1 ((exp) else) exp) env) ))))

(defVau (caseVau . clauses) env
  (vau values #ignore
    (let1 loop (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((bindings . forms) . clauses) clauses)
          (if (== bindings 'else)
            (if (== (car forms) '=>)
              (let1 ((apv) (cdr forms)) ((eval apv env) values))
              (eval (cons 'begin forms) env) )
            (let1 (env+ (newEnv env)) 
              (if (bind? env+ bindings values)
                (eval (cons 'begin forms) env+)
                (loop clauses) ))))))))

(defMacro (defCaseVau sym . clauses)
  (list 'def sym (cons 'caseVau clauses)) )

(defMacro (case\ . clauses)
  (list 'wrap (cons 'caseVau clauses)) )

(defMacro (defCase\ sym . clauses)
  (list 'def sym (cons 'case\ clauses)) )

(defMacro (match exp . clauses)
  (list (cons 'case\ (map (\ ((a . b)) (list* (if (== a 'else) a (list a)) b)) clauses)) exp) )


;;; Quasiquote

;; (Idea from Alf Petrofsky http://scheme-reports.org/mail/scheme-reports/msg00800.html)
(defVau %` (x) env
  (defCase\ qq
    ( ((('%,@ x) . y) #f . d) (append (map (\ (x) (list '%,@ x)) (apply** qq (list x) d)) (apply** qq y #f d)) )
    ( ((('%,@ x) . y) . d)    (append (eval x env) (apply** qq y d)) )
    ( ((('%, x) . y) #f . d)  (append (map (\ (x) (list '%, x))  (apply** qq (list x) d)) (apply** qq y #f d)) )
    ( (('%, x) #f . d)        (list '%, (apply** qq x d)) )
    ( (('%, x) . d)           (eval x env) )
    ( (('%` x) . d)           (list '%` (apply** qq x #f d)) )
    ( ((x . y) . d)           (cons (apply** qq x d) (apply** qq y d)) )
    ( (x . d)                 x) )
  (qq x))


;;; Cond

(defVau (cond . clauses) env
  #|Multi-armed conditional.
   |Go through the CLAUSES in order.  Evaluate the TEST.
   |If it yields true, evaluate the FORMS as an implicit `begin'.
   |If it yields false, go to the next clause,
   |or return void if there are no more clauses.
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (test->bool . forms))
   |$(syntax clause (test))
   |$(syntax clause (test => apv1))
   |$(syntax clause (test guard => apv1))
   |#
  (unless (null? clauses)
    (let1 (((test . body) . clauses) clauses)
      (if (== test 'else)
        (apply (wrap begin) body env)
        (let1 (test (eval test env))
          (if (instanceOf? test Boolean)
            (if test
              (apply (wrap begin) body env)
              (apply (wrap cond) clauses env) )
            (match body
              (() test)
              (('=> apv1) ((eval apv1 env) test))
              ((guard '=> apv1)
                 (if ((eval guard env) test)
                   ((eval apv1 env) test)
                   (apply (wrap cond) clauses env) ))
              (else (apply (wrap cond) clauses env)) )))))))


;;;; Member Assoc Get

(def\ (member key lst)
  (let1 loop (lst lst)
     (if (null? lst) #null
       (if (== key (car lst)) lst
         (loop (cdr lst)) ))))

(def\ (member? key lst)
  (!null? (member key lst)) )
  
(def\ (!member? key lst)
  (null? (member key lst)) )

(def\ (member key lst . keywords)
  #|Search for ITEM in the LIST according to the TEST predicate
   |(defaults to `==').  Return the tail of the list starting with
   |ITEM if found, nil otherwise.  The KEY function is applied to
   |each list element before comparison (defaults to `identity').
   |$(fn (item list &key test key))
   |#
  (let ( (test (opt? (get? :test keywords) ==))
         (fkey (opt? (get? :fkey keywords) identity)) )
    (let1 loop (lst lst)
      (if (null? lst) #null
        (if (test (fkey (car lst)) key) lst
          (loop (cdr lst)))))))

(def\ (member? key lst . keywords)
  (!null? (apply** member key lst keywords)) )
  
(def\ (!member? key lst . keywords)
  (null? (apply** member key lst keywords)) )

(def\ (assoc key lst)
  (let1 loop (lst lst)
     (if (null? lst) #null
       (let1 ((kv . lst) lst)
         (if (== (car kv) key) kv
           (loop lst) )))))

(def\ (get? key lst)
  #|Search for the KEYWORD in the property list LST
   |(a list of alternating keywords and values)
   |and return the found value as an option.
   |#
  (let1 loop (lst lst)
    (if (null? lst) #null
      (let1 ((k v . lst) lst)
        (if (eq? k key) (some v)
          (loop lst)) ))))


;;; Case CaseType

(defVau (case exp . clauses) env
  (let1 (value (eval exp env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((values . forms) . clauses) clauses)
          (if (or (== values 'else) (== value values) (and (cons? values) (cons? (member value values))))
            (if (== (car forms) '=>)
              (let1 ((apv) (cdr forms)) ((eval apv env) value))
              (eval (cons 'begin forms) env) )
            (next clauses) ))))))

; vedi signalsError? in vm.lispx (o test-util.lispx) per codice simile
(defVau (caseType key . clauses) env
  #|Multi-armed type test.
   |Evaluate the KEYFORM.  Go through the CLAUSES.  If the result of
   |evaluating KEYFORM is an instance of the class named by CLASS-NAME,
   |evaluate the FORMS as an implicit `begin'.  Otherwise go to the next
   |clause, or return void if there are no more clauses.
   |$(fn (key . clauses))
   |$(type fexpr)
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (className . forms))
   |$(syntax clause ((className . slotSpecs) . forms))
   |#
  (let1 (key (eval key env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((test . forms) . clauses) clauses)
          (if (|| (== test 'else)
                  (let* ( (symbol? (symbol? test))
                          (class (eval (if symbol? test (car test)) env)) )
                    (if symbol? (type? key class) (matchObj? key (eval (cons 'list test) env))) ))
            (if (== (car forms) '=>)
              (let1 ((apv) (cdr forms)) ((eval apv env) key))
              (eval (cons 'begin forms) env) )
            (next clauses) ))))))

(def matchObj? %matchObj?)

(def\ (matchObj*? obj . class&slots) 
  (matchObj? obj class&slots) )

;;; Options

;; An option is either nil ("none"), or a one-element list ("some").
;; Variables holding options are conventionally suffixed with "?".

(def\ some (value)
  #|Create a one-element list from the VALUE.
   |#
  (list value))

(def\ (01+ forms)
  (if (null? forms) #null (1+ forms)) )

(def\ (1+ (#! List forms))
  (if (null? (cdr forms)) (car forms) (cons 'begin forms)) )

;; (Idea from Taylor R. Campbell's blag. https://mumble.net/~campbell/blag.txt)
(defVau (ifOpt? (pt opt?) then . else) env
  #|Destructure the OPTION?.  If it's non-nil, evaluate the THEN form
   |with the NAME bound to the contents of the option.  If it's nil,
   |evaluate the ELSE form.
   |#
  (let1 (opt? (eval opt? env))
    (if (null? opt?)
      (if (null? else) #null
        (eval (1+ else) env))
      (if (list? opt?)
        (eval (list* (list 'vau (list pt) #ignore then) opt?) env)
        (typeError opt? '(or () List)) ))))

(defVau (ifOpt*? (pt opt?) then . else) env
  (let1 (opt? (eval opt? env))
    (if (null? opt?)
      (if (null? else) #null
        (eval (1+ else) env))
      (if (list? opt?)
        (eval (list* (list 'vau pt #ignore then) opt?) env)
        (typeError opt? '(or () List)) ))))

(defMacro whenOpt? ((pt opt?) . forms)
  #|Destructure the OPTION?.  If it's non-nil, evaluate the FORMS with
   |the NAME bound to the contents of the option.  If it's nil, return nil.
   |#
  (list 'ifOpt? (list pt opt?) (01+ forms)) )

(defMacro unlessOpt? (opt? . forms)
  #|Destructure the OPTION?.  If it's nil, evaluate the FORMS.  If it's
   |non-nil, return nil.
   |#
  (list* 'ifOpt? (list #ignore opt?) #null (01+ forms)) )

(defVau (caseOpt? exp . clauses) env
  (let1 (exp (eval exp env))
    (if (null? exp) #null
      (let1 loop (clauses clauses)
        (if (null? clauses) #null
          (let ((env+ (newEnv env))
                (((bindings . forms) . clauses) clauses) )
            (if (or (== bindings 'else) (bind? env+ bindings exp))
              (eval (cons 'begin forms) env+)
              (loop clauses) )))))))

(defMacro (opt? exp . dft)
  #|Return the contents of the OPTION?, or the DEFAULT? if the option
   |is nil.  The default itself defaults to void.  The DEFAULT? is
   |evaluated lazily, only when the OPTION? is nil.
   |#
  (list* ifOpt? (list 'exp exp) 'exp dft))

(defVau opt*? (lst . dft) env
  #|Similar to `opt', but provides DEFAULTS for any number of
   |elements of LIST.  This is useful for implementing functions that take
   |multiple opt? arguments.  Each default is evaluated lazily, only when needed.
   |#
  (let loop ((lst (eval lst env)) (dft dft))
    (if (null? lst)
      (if (null? dft) #null
         (cons (eval (car dft) env) (loop #null (cdr dft))) )
      (if (null? (car lst))
        (if (null? dft)
          (cons #null (loop (cdr lst) #null))
          (cons (eval (car dft) env) (loop (cdr lst) (cdr dft))) )
        (cons (car lst)
          (loop (cdr lst) (if (null? dft) #null (cdr dft)))) ))))

(def\ getOpt? (option?)
  #|Returns the contents of the OPTION? or signals an error if it is nil.
   |#
  (opt? option? (simpleError "Option is nil")))


;;; Type Checks

(def\ assert#t (boolean)
  #|Signal an error if the BOOLEAN is false. Otherwise return void.
   |#
  (unless boolean (error (new Error "invalid assetion" :type 'assert :datum boolean :expected #t))))

(def\ makeTypeError (datum expected)
  #|Create a `type-error' with the given DATUM and EXPECTED-TYPE.
   |#
  (new Error "not a {expected}: {datum}" :type 'type :datum datum :expected expected) )

(def\ typeError (datum expected)
  #|Signal a `type-error'
   |#
  (error (makeTypeError datum expected)) )

;; TODO non più necessario se non per i test, eliminare
(def\ assertType (object class)
  #|Signal a `type-error' if the OBJECT is not an instance of the CLASS.
   |#
  (if (type? object class) object
    (typeError object (className class)) ))

#| TODO sostituito dal seguente
(defVau the (className object) env
  #|Shorthand for `assertType'.  Signal a `type-error' if the OBJECT
   |is not an instance of the class named by CLASS-NAME.
   |#
  (assertType (eval object env) (eval (%the Symbol className) env)))

(def\ the (class object)
  (assertType object class) )
|#

(def the
  #|Signal a `type-error' if the OBJECT is not an instance of the CLASS, else return object.
   |$(fn (class object)
   |$(type function)
   |#
  %the)

#| TODO non più necessari, sostituiti da #!, eliminare
(defMacro (the\ parms . body)
  (let1rec\
    ( (parms->names.checks ps)
      (if (cons? ps)
        (let* ( ((p . ps) ps)
                ((names . checks) (parms->names.checks ps)) )
          (if (cons? p)
            (let* ( ((name type) p)
                    (check (list 'the type name)) )
              (cons (cons name names) (cons check checks)) )
                    (cons (cons p names) checks) ))
        (cons ps ()) ))
    (let1 ((names . checks) (parms->names.checks parms))
      (list* '\ names (if (null? checks) body (list* (cons 'begin checks) body))) )))

(defMacro (define lhs . rhs)
  (if (cons? lhs)
    (list 'def (car lhs) (list* 'the\ (cdr lhs) rhs))
    (list 'def lhs (car rhs)) ))

(defMacro (the\ pt . body)
  (let1rec\
    ( (pt->pt.cks pt)
      (if (cons? pt)
        (let* ( ((lhs . rhs) pt)
                ((ptRhs . cksRhs) (pt->pt.cks rhs)) )
          (if (cons? lhs)
            (if (== (car lhs) #!)  
              (let* ( ((#_ type name) lhs)
                      (check (list 'the type name)) )
                (cons (cons name ptRhs) (cons check cksRhs)) )
              (let1 ((ptLhs . cksLhs) (pt->pt.cks lhs))
                (cons (cons ptLhs ptRhs) (append cksLhs cksRhs)) ) )
            (let1 ((ptRhs . cksRhs) (pt->pt.cks rhs))
              (cons (cons lhs ptRhs) cksRhs)) ))
        (cons pt ()) ) )
    (let1 ((pt . cks) (pt->pt.cks pt))
      (list* '\ pt (if (null? cks) body (list* (cons 'begin cks) body))) )))
|#

; evlis: (map (\ (x) (eval x env)) xs) <=> (eval (cons 'list xs) env)

#| TODO sostituiti dal seguente, eliminare
(def %check
  (let1 (%check %check)
    (vau (o ck) env
      (let1rec\
        (ev (ck)
          (if (== ck '+) (.MAX_VALUE Integer)
            (if (! (cons? ck)) (eval ck env)
              (if (== (car ck) 'or) (list->array (ev (cdr ck)))
                (if (or (== (car ck) '%') (== (car ck) 'quote)) (cadr ck)
                  (map (\ (ck) (ev ck)) ck) )))))
        (%check o (ev ck)) ))))

(def %check
  (let1 (%check %check)
    (vau (o ck) env  
      (let1rec\
        (ev (ck)
          (cond
            ((== ck '+) (.MAX_VALUE Integer))
            ((! (cons? ck)) (eval ck env))
            ((== (car ck) 'or) (list->array (ev (cdr ck))))
            ((or (== (car ck) '%') (== (car ck) 'quote)) (cadr ck))
            (else (map (\ (ck) (ev ck)) ck)) ))
        (%check o (ev ck)) ))))
|#

(def %check
  (let1 (%check %check)
    (vau (o ck) env
      (let1rec\
        (ev (ck)
          (if*
            (== ck '+) (.MAX_VALUE Integer)
            (! (cons? ck)) (eval ck env)
            (== (car ck) 'or) (list->array (ev (cdr ck)))
            (or (== (car ck) '%') (== (car ck) 'quote)) (cadr ck)
            (map (\ (ck) (ev ck)) ck) ))
        (%check o (ev ck)) ))))

(defVau (check o ck) env
  ((wrap %check) (eval o env) ck) )

(defMacro (check* o . cks)
    (list 'check o cks) )

(defVau check? args env (catchWth #f (apply check args env) #t))

(defMacro (the+ ck obj) (list 'let1 (list 'obj obj) (list 'check 'obj ck) 'obj))

; TODO non è più così costosa la conversione, si può fare
; (def the the+)


;;; Block Loop For While Until

(defVau block (blockName . forms) env
  #|Establish a block named BLOCK-NAME and evaluate the FORMS as an
   |implicit `begin' inside it.  The forms may use `returnFrom' to
   |nonlocally exit from the block.
   |Note that unlike in Common Lisp, there is no separate namespace for
   |block names; a block is named in the normal variable namespace.
   |#
  (let* ( (tag (list #inert)) ; cons up a fresh object as tag
          (escape (\ (value) (throwTag tag value))) )
    (catchTag tag
      (eval (list (list* '\ (list blockName) forms) escape) env) )))

#|
(defVau block (blockName . forms) env
  (def tag (list #inert)) ; cons up a fresh object as tag
  (def\ (escape value) (throwTag tag value))
  (catchTag tag
    (eval (list (list* '\ (list blockName) forms) escape) env) ))
|#

(def\ returnFrom (blockName . value?)
  #|Abort evaluation and return the optional VALUE? (which lsts to
   |void) from the block named BLOCK-NAME.  It is an error to return from
   |a block whose dynamic extent has ended.
   |$(fn (blockName . value?))
   |#
  (blockName (opt? value? #inert)) )

(defVau while (testForm . forms) env
  #|Evaluate FORMS while TEST-FORM evaluates to true.
   |#
  (let ((forms (cons 'begin forms)))
    (block exit
      (loop
        (if (eval testForm env)
            (eval forms env)
            (returnFrom exit #inert))))))

#| TODO da rivedere crea problemi con il debugger in lispx
(defVau while (testForm . forms) env
  (let ((forms (list* 'begin forms))
        (break (list #null))
        (continue (list #null)) )
    (def env (newEnv (newEnv env    
      :break/v (\ v (throwTag break (if (! (null? v)) (if (null? (cdr v)) (car v) v))))
      :continue (\ () (throwTag continue)) )))
    (catchTag break
      (loop
        (catchTag continue
          (if (eval testForm env)
            (eval forms env)
            (throwTag break) ))))))

(def %loop
  (let ( (%loop %loop)
         (makeTag
           (\ (i name %deep)
             (if (&& (>= i (- 0 %deep)) (<= i 0))
               (symbol ($ name (+ i %deep)))
               (@typeError vm ($ "invalid " name " index, not {expected}: {datum}") i `(and (>= ,(- 0 %deep)) (=< 0))) ))) )
    (let\ ( ((makeThrowTag\ name %deep)
               (\ (#! (or () (1 Integer)) i)
                 (throwTag (makeTag (opt? i 0) name %deep)) ))
            ((makeThrowTagValue\ name %deep)
               (\ o
                 (if (== (check o (or (1) (2 Integer))) 1)
                   (throwTag (makeTag 0 name %deep) (car o))
                   (throwTag (makeTag (car o) name %deep) (cadr o)) ))) )
      (vau forms env
        (let1 (%deep (let1 (%deep (value :%deep env)) (if (null? %deep) 0 (+ %deep 1))))
          (let ( (break (symbol ($ "break" %deep)))
                 (continue (symbol ($ "continue" %deep))) )
            (let1 (env (newEnv (newEnv env
                    :%deep %deep
                    :break (makeThrowTag\ "break" %deep)
                    :continue (makeThrowTag\ "continue" %deep)
                    :break/v (makeThrowTagValue\ "break" %deep)
                    :until (\ (b) (if b (throwTag break)))
                    :while (\ (b) (if (! b) (throwTag break))) ))) 
              (if (check? forms (2 + 'for ((2 3)) )) ;loop for
                (let ( (for (cadr forms))
                       (forms (01+ (cddr forms))) )
                  (def increments (list* 'def* (map car for) (map (\((#_ init . incr)) (opt? incr init)) for)))
                  (catchTag break
                    (eval (list* 'def* (map car for) (map cadr for)) env)   
                    (%loop
                      (catchTag continue (eval forms env) )
                      (eval increments env) )))
                (if (check? forms (2 + 'for1 (2 3))) ;loop for1
                  (let ( ((pt init . incr) (cadr forms))
                         (forms (01+ (cddr forms))) )
                    (def increment (list 'def pt (opt? incr init)))
                    (catchTag break
                      (eval (list 'def pt init) env)
                      (%loop
                        (catchTag continue (eval forms env) )
                        (eval increment env) )))
                  (let1 (forms (01+ forms)) ;loop
                    (catchTag break
                      (%loop
                        (catchTag continue
                          (eval forms env) )))) )))))) )))

(def loop %loop)

(defMacro (for ((#! Symbol var) init cond . incr) . body)
  (list* 'loop 'for1 (list* var init incr)
    (if (%ignore? cond) body
      (cons (list 'while cond) body) )))

(defMacro (while cond . body)
  (list* 'loop (list 'while cond)
    body ))
|#

(defMacro until (cond . forms)
  #|Evaluate FORMS until TEST-FORM evaluates to true.
   |#
  (list* 'while (list '! cond) forms) )

(defMacro dotimes ((var countForm . resultForm?) . bodyForms)
  #|Cf. Common Lisp's DOTIMES.
   |#
  (let\ ((dotimes (n body result)
           (let ((i (newBox 0)))
             (while (< (i) n)
               (body (i))
               (i (+ (i) 1)))
             (result (i)))))
    (list dotimes
          countForm
          (list* '\ (list var) bodyForms)
          (list* '\ (list var) resultForm?))))

(def\ (withEscape fun)
  (let1 (fresh (list #null))
    (catchWth
      (\ (exc)
        (if (and (cons? exc) (== (car exc) fresh))
          (let1 ((#ignore opt?) exc) (if (cons? opt?) (car opt?)))
          (throw exc)))
      (fun (\ opt? (throw (list fresh (ifOpt? (val opt?) opt?) )))) )))

(defMacro (label name . body)
  (list 'withEscape (list* '\ (list name) body)))


;;; Lists

(def\ (any? f lst . lst*)
  (if (null? lst*)
    ((rec\ (any? lst) (if (null? lst) #f (if (f (car lst)) #t (any? (cdr lst)))) ) lst)
    ((rec\ (any*? lst*) (if (null? (car lst*)) #f (if (apply f (map car lst*)) #t (any*? (map cdr lst*))))) (cons lst lst*)) ))

(defMacro (any?* f . lst) (list 'any? f lst))

(def\ (all? f lst . lst*)
  (if (null? lst*)
    ((rec\ (all? lst) (if (null? lst) #t (if (f (car lst)) (all? (cdr lst)) #f))) lst)
    ((rec\ (all*? lst*) (if (null? (car lst*)) #t (if (apply f (map car lst*)) (all*? (map cdr lst*)) #f))) (cons lst lst*)) ))

(defMacro (all?* f . lst) (list 'all? f lst))

(def\ (forEach# f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect. Return the #inert.
   |#
  (if (null? lst*)
    ((rec\ (forEach lst) (unless (null? lst) (f (car lst)) (forEach (cdr lst)))) lst)
    ((rec\ (forEach* lst*) (unless (null? (car lst*)) (apply f (map car lst*)) (forEach* (map cdr lst*)) )) (cons lst lst*)) ))

(def\ (forEach f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect. Return the list.
   |#
  (if (null? lst*)
    (let1 (res lst) ((rec\ (forEach lst) (if (null? lst) res (f (car lst)) (forEach (cdr lst)))) res))
    (let1 (res* (cons lst lst*)) ((rec\ (forEach* lst*) (if (null? (car lst*)) res* (apply f (map car lst*)) (forEach* (map cdr lst*)) )) res*) )) )

(def\ maplist (f lst . lst*)
  #|Apply the FUNCTION, which must return a list, to every element of the
   |LIST, and append the results.  (Note: this currently uses `append',
   |but might be changed to use `nconc' in the future, like Common Lisp.)
   |#
  (if (null? lst*)
    ((rec\ (maplist lst) (if (null? lst) #null (append (f (car lst)) (maplist (cdr lst))))) lst)
    ((rec\ (maplist* lst*) (if (null? (car lst*)) #null (append (apply f (map car lst*)) (maplist* (map cdr lst*))))) (cons lst lst*)) ))

(def\ (filter f lst . lst*)
  (if (null? lst*)
    ((rec\ (filter lst) (if (null? lst) #null (if (f (car lst)) (cons (car lst) (filter (cdr lst))) (filter (cdr lst))))) lst)
    ((rec\ (filter* lst*) (if (null? (car lst*)) #null (let1 (cars (map car lst*)) (if (apply f cars) (cons cars (filter* (map cdr lst*))) (filter* (map cdr lst*)) )))) (cons lst lst*)) ))

(defMacro (remove f lst . lst*)
  #|Return a new list from which the elements that satisfy the TEST have been removed.
   |#
  (list* 'filter (list 'compose '! f) lst lst*) )

(def\ (reduceL f init lst . lst*)
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (reduce (f acc (car lst)) (cdr lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (reduce* (apply* f acc (map car lst*)) (map cdr lst*)) )) init (cons lst lst*)) ))

(def reduce
  #|Use the binary FUNCTION to combine the elements of the LIST.  The
   |INITIAL-VALUE is logically placed before the list.
   |#
  reduceL)

(def\ (reduceR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (f (reduce acc (cdr lst)) (car lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (apply* f (reduce* acc (map cdr lst*)) (map cadr lst*)) )) init (cons lst lst*)) ))

(def\ (foldL f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldl acc lst) (if (null? lst) acc (foldl (f (car lst) acc) (cdr lst)) )) init lst)
    ((rec\ (foldl* acc lst*) (if (null? (car lst*)) acc (foldl* (apply* f (map car lst*) acc) (map cdr lst*)) )) init (cons lst lst*)) ))

(def\ (foldR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldr acc lst) (if (null? lst) acc (f (car lst) (foldr acc (cdr lst)) ) )) init lst)
    ((rec\ (foldr* acc lst*) (if (null? (car lst*)) acc (apply* f (map car lst*) (foldr* acc (map cdr lst*)) ) )) init (cons lst lst*)) ))

(defMacro dolist ((var listForm . resultForm?) . bodyForms)
  #|Cf. Common Lisp's DOLIST.
   |#
  (let1rec\
    (dolist (list body result)
      (if (null? list) (result list)
        (body (car list))
        (dolist (cdr list) body result)))
    (list dolist
          listForm
          (list* '\ (list var) bodyForms)
          (list* '\ (list var) resultForm?))))

(def\ (make\* n f)
  (def\ (resize n lst)
    (let loop ((n n) (h ()) (t lst))
      (if (null? t) (reverse h)
        (if (<= n 1)
          (reverse (cons (if (null? (cdr t)) (car t) t) h))
          (loop (- n 1) (cons (car t) h) (cdr t)) ))))
  (\ lst (apply f (resize n lst))))


;;; Dynamic Binding

#| TODO primitiva non più necessaria, eliminare
(def %d\
  (vau (var* . body) #ignore
    (wrau val* env
        (def\ (ckdvar var)
            (def lkp (@get env var))
            (def ndv (.value lkp))
            ;(if (or (and (null? body) (null? ndv)) (instanceOf? ndv DVar)) ndv
            ;  (error ($ "not " (if (null? body) "null or " "") "a dynamic value: " var)) )
            (if (or (and (null? body) (! (.isBound lkp))) (instanceOf? ndv DVar)) ndv
              (error ($ "not " (if (null? body) "unbound or " "") "a dynamic value: " var)) ))
        (def ndv* (map ckdvar var*))
        (unless (null? body) (def old* (map (\ (ndv) (if (null? ndv) ndv (ndv))) ndv*)))
        (forEach (\ (ndv var val) (if (instanceOf? ndv DVar) (ndv val) (@def env var (newDVar val)) )) ndv* var* (if (null? val*) (map (\ (var) #null) var*) val*))
        (unless (null? body)
          (finally
            (eval (cons 'begin body) env)
            (forEach (\ (ndv old) (ndv old)) ndv* old*) )))))

;((d\ (d e) (print e)) 4 5)
;((d\ (d e)) 6 7)
|#

(defMacro (ddef var . val?)
  #|Define a new or update an existing dynamic variable with the given
   |NAME and opt? default VALUE.
   |$(fn (name))
   |$(fn (name value))
   |#
  (list* (list '%d\ (list var)) val?) )

(defMacro (ddef* var* . val*)
  (list* (list '%d\ var*) val*) )

(def\ (dget dvar)
  #|Return the current value of the DYNAMIC-VARIABLE.
   |#
  (dvar))

(def\ (dset dvar value)
  #|Set the current value of the DYNAMIC-VARIABLE.
   |#
  (dvar value))

(defMacro (dlet bindings exp . exps)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established parallely
   |as per `let'.
   |$(syntax binding (dynamicVariable value))
   |#
  (list* (list* '%d\ (map car bindings) exp exps) (map cadr bindings)) )

(defMacro (progv var* val* exp . exps)
  #|Evaluate the FORMS with the list of DYNAMIC-VARIABLES temporarily
   |bound to new VALUES.  The DYNAMIC-VARIABLES and VALUES lists must have
   |the same length.
   |#
  (list* (list* '%d\ var* exp exps) val*) )

(defMacro (dlet* bindings . forms)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established serially as
   |per `let*'.
   |#
  (if (null? bindings)
    (cons 'begin forms)
    (list 'dlet
      (list (car bindings))
      (list* 'dlet* (cdr bindings) forms) )))


;;;; Box

(def newBox %newBox)

(defMacro (defBox name . value?)
  (list 'def name (cons 'newBox value?)) )


;;; Classes

(def\ findClass (name env)
  #|Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT.
   |#
  (eval (the Symbol name) env))

(defVau defClass (name superclass? slotSpecs . properties) env
  #|Define a new `StandardClass' with the given NAME, optional
   |SUPERCLASS?, and SLOT-SPECS.  The superclass defaults to
   |`standard-object'.  The SLOT-SPECS and PROPERTIES are currently
   |ignored.
   |$(syntax slotSpec symbol)
   |$(syntax property (:documentation docstring))
   |#
   ;; Slot-specs are ignored for now, but check that they are symbols nevertheless.
  (dolist (slotSpec slotSpecs) (the Symbol slotSpec))
  (let1 (superclass (findClass (opt? superclass? 'Obj) env))
    (eval (list def name (%newClass name superclass)) env)) )


;;; Objects

(def new
  #|Create a new instance of CLASS (that must be a `standard-class').
   |The SLOT-INITS must be of even length, and alternately contain slot
   |names (symbols, typically keywords) and values.
   |$(fn (class . slotInits))
   |#
  %new)

(def\ getSlot (object slotName)
  #|Return the value of the slot named SLOT-NAME of the OBJECT.
   |#
  (%getSlot object slotName))

(def\ setSlot (object slotName value)
  #|Set the value of the slot named SLOT-NAME of the OBJECT to VALUE.
   |#
  (%setSlot object slotName value))

(def\ slotBound? (object slotName)
  #|Return true if the slot named SLOT-NAME of the OBJECT is set, false otherwise.
   |#
  (%slotBound? object slotName))

(defMacro (defObj name class . attr)
  (list 'def name (list* 'new class attr)) )


;;; Generic Functions

;; receiver e parameters dei defMethod dovrebbero corrispondere a quelli del corrispondente defGeneric con quel nome

(defVau (defGeneric . args) env
  #|Define a new generic function with the given NAME.
   |The RECEIVER, PARAMETERS, and PROPERTIES are currently ignored.
   |$(syntax property (:documentation docstring))
   |#
  (if (cons? (car args))
    (def ((name receiver . parameters) . properties) args)
    (def (name (receiver . parameters) . properties) args) )
  (let1\ (generic args (apply (%getMethod (classOf (car args)) name) args))
    (eval (list 'def name generic) env) ))

(defVau (defMethod . args) env
  #|Add a new method to the generic function named by NAME
   |specialized for the class named by CLASS-NAME.
   |#
  (if (cons? (car args))
    (def ((name (receiver class) . parameters) . forms) args)
    (def (name ((receiver class) . parameters) . forms) args) )
  (let1 (method (eval (list* '\ (cons receiver parameters) forms) env))
    (def prv (%addMethod (findClass class env) name method))
    (case (bndRes) ((#inert) #inert) ((:rhs) method) ((:prv) prv)) ))


;;; Modules

(defVau (provide symbols . body) env
  (eval
    (list 'def symbols
      (list 'let ()
        (cons 'begin body)
        (cons 'list symbols) ))
    env ))

(defVau (module exports . body) env
  (let1 (env (newEnv env))
    (eval (list* 'provide exports body) env)
    (newEnv env) ))

(defMacro (defModule name exports . body)
  (list 'def name (list* 'module exports body)) )

(defVau (import module imports) env
  (let* ((module (eval module env))
         (values (eval (cons 'list imports) module)) )
    (eval (list* 'def* imports values) env) ))


;;; Relational Operators

;; Note that unlike in Common Lisp, these operators currently require
;; at least two arguments.  This will be improved in the future.

(def\ (relationalOp binop)
  #|Utility to create an n-ary relational operator from a BINARY-OPERATOR.
   |#
  (rec\ (op arg1 arg2 . rest)
    (if (binop arg1 arg2)
      (if (null? rest) #t
        (apply op (cons arg2 rest)))
      #f )))

(def == (relationalOp ==))

(def eq?
  #|Return true if all ARGUMENTS are equal, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp eq?) )

(def <
  #|Return true if the ARGUMENTS are in monotonically increasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp <) )

(def >
  #|Return true if the ARGUMENTS are in monotonically decreasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp >) )

(def <=
  #|Return true if the ARGUMENTS are in monotonically nondecreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp <=) )

(def >=
  #|Return true if the ARGUMENTS are in monotonically nonincreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp >=) )

(def\ (!= . args)
  (! (apply == args)))

(def\ /= (arg . args)
  #|Return true if no two ARGUMENTS are the same, false otherwise.
   |$(fn arguments)
   |#
  (if (null? args) #t
    (if (cons? (member arg args :test eq?)) #f
      (apply /= args) )))


;;; Thetic & Lytic

;; The terms thetic (for + and *) and lytic (for - and /) are due to Hankel.

(def\ (theticOp binOp unit)
  #|Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |#
  (\ args (reduceL binOp unit args)) )

(def +
  #|Return the sum of the ARGUMENTS, or 0 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp + 0) )

(def *
  #|Return the product of the ARGUMENTS, or 1 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp * 1) )

(def $
  #|Return the join of the ARGUMENTS, or "" if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp $ "") )

(def\ (lyticOp binOp unit)
  #|Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |#
  (\ (arg1 . rest)
    (if (null? rest)
      (binOp unit arg1)
      (reduceL binOp arg1 rest) )))

(def -
  #|If only one number is supplied in the ARGUMENTS, return the
   |negation of that number. If more than one number is supplied, subtract
   |all of the later ones from the first one and return the result.
   |$(fn arguments)
   |$(type function)
   |#
  (lyticOp - 0) )

(def /
  #|If only one number is supplied in the ARGUMENTS, return the
   |reciprocal of that number.  If more than one number is supplied,
   |divide the first one by all of the later ones and return the result.
   |$(fn arguments)
   |$(type function)
   |#
  (lyticOp / 1) )


;;;; Greatest Common Divisor e Lowest Common Multiple

(def\ (gcd a b . more)
  (if (null? more)
    (if (zero? b) a (gcd b (% a b)))
    (gcd a (apply gcd (cons b more))) ))

(def abs (let1 (abs (@getMethod Math "abs" &int)) (\ (n) (abs #null n))))

(def\ (lcm a b . more)
  (if (null? more)
    (if (or (zero? a) (zero? b)) 0
      (abs (* b (/ a (gcd a b)))) )
    (lcm a (apply lcm (cons b more))) ))


;;; Sequences

(defGeneric length (sequence)
  #|Return the number of elements in a sequence.|#)

(defMethod length ((seq List))
  (%len seq))

(defMethod length ((seq Null))
  (%len seq))

(defGeneric elt (sequence index)
  #|Return the sequence element at the specified index.|#)

(defMethod elt ((seq List) index)
  (nth index seq))

(defGeneric subSeq (sequence start . end?)
  #|Create a sequence that is a copy of the subsequence
   |of the SEQUENCE bounded by START and optional END?.  If END?  is not
   |supplied or void, the subsequence stretches until the end of the list
   |#)

(defMethod subSeq ((seq List) start . end?)
  (%subList seq start (opt? end? #inert)))

(defMethod subSeq ((seq Null) start . end?)
  (%subList seq start (opt? end? #inert)))

(defMethod subSeq ((seq String) start . end?)
  (%subString seq start (opt? end? #inert)))


;;; Coroutines

(defConstant coroutinePrompt
  #|This prompt is used for general coroutine-like use of continuations.
   |#
  'coroutine-prompt)

(defMacro coroutine forms
  #|Evaluate the FORMS in a context in which `yield' can be used to pause execution.
   |#
  (list* 'pushPrompt 'coroutinePrompt forms))

(defMacro yield (name . forms)
  #|Pause the current coroutine.  In the place where the enclosing
   |`coroutine' (or `resume') was called, evaluate the FORMS with NAME
   |bound to the paused coroutine.  `resume' can later be used to restart
   |execution inside the coroutine.
   |#
  (list* 'takeSubcont 'coroutinePrompt name forms))

(defMacro resume (k . forms)
  #|Resume the paused coroutine K and evaluate FORMS in the place where
   |`yield' was called in the coroutine.
   |#
  (list* 'pushDelimSubcont 'coroutinePrompt k forms))


;;; Fibers

;; The following implementation of fibers follows the one at URL
;; `http://okmij.org/ftp/continuations/implementations.html#dget-wind'
;;
;; We're calling them fibers instead of coroutines so as to not
;; conflict with the built-in coroutine operators.
;;
;; We use it for testing that built-in operators properly suspend and
;; resume.

(defConstant fiberPrompt
  #|The prompt used for delimiting fibers.
   |#
  'fiber-prompt)

(defClass YieldRecord ()
  #|Instances of this class are yielded.
   |#
  (value continuation) )

(def\ makeYieldRecord (v k)
  #|Create a new yield record with the given yielded value and resume continuation.
   |#
  (new YieldRecord :value v :continuation k))

(def\ fiberYield v?
  #|Yield a value (which defaults to void).
   |#
  (takeSubcont fiberPrompt k
    (makeYieldRecord (opt? v? #inert) k)))

(def\ fiberResume (yieldRecord . v?)
  #|Resume a suspended fiber with a value (which defaults to void).
   |#
  (pushDelimSubcont fiberPrompt (yieldRecord 'continuation)
    (opt? v? #inert)))

(defMacro fiber body
  #|Evaluate the body expressions as a fiber.
   |#
  (list* pushPrompt 'fiberPrompt body))

#| TODO non più necessarie, eliminare
(def\ runFiber (thunk)
  #|Get all values yielded by a fiber, and its final result, and
   |collect them in a list.
   |#
  (let1 run (result (fiber (thunk)))
    (if (type? result YieldRecord)
        (cons (result 'value) (run (fiberResume result)))
        (list result))))

(def\ runFiberWithValues (thunk values)
  #|Like `runFiber' but uses a list of values that are sent to the
   |fiber with `fiberResume'.
   |#
  (let run ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
        (cons (result 'value)
              (run (fiberResume result (car values)) (cdr values)))
        (list result))))
|#

(def\ runFiber* (thunk . values)
  (let run ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
      (cons (result 'value)
        (if (null? values)
          (run (fiberResume result) #null)
          (run (fiberResume result (car values)) (cdr values)) ))
      (list result) )))

(assert (runFiber* (\ () (fiberYield 1) (fiberYield 2) 3)) '(1 2 3))

(assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #t) '(1 2 #inert))
(assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #t #_) '(1 2 #ignore))
(assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #t 4) '(1 2 4))
(assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #f) '(1 3))

(assert (runFiber* (\ () ((\ (a b) (+ a b)) (fiberYield 1) (fiberYield 2)) ) 3 4) '(1 2 7))

(defMacro (runFiberWithValues f args) (list 'eval (list 'list* 'runFiber* f args))) 
(defMacro (runFiberWithValues f args) (list 'apply 'runFiber* (list 'list* f args))) 
(defMacro (runFiberWithValues f args) (list 'apply** 'runFiber* f args)) 

(assert (runFiberWithValues (\ () (fiberYield 1) (fiberYield 2)) '(#inert 3)) (1 2 3))
(assert (runFiberWithValues (\ () (fiberYield 1) (fiberYield 2)) (#inert 3)) (1 2 3))

(def runFiber runFiber*) 


;;;; Auto Increment/Decrement and Assignement Operator

(defVau (++ plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (+ (val) 1))))
    (Obj    (let1 ((fld) args) (val :rhs fld (+ (val fld) 1))))
    (Number (let1 (() args) (eval (list 'set! plc :rhs (+ val 1)) env)))
    (else   (error ($ "not valid type: " val))) ))

(defVau (-- plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (- (val) 1))))
    (Obj    (let1 ((fld) args) (val :rhs fld (- (val fld) 1))))
    (Number (let1 (() args) (eval (list 'set! plc :rhs (- val 1)) env)))
    (else   (error ($ "not valid type: " val))) ))

(def\ (assignOp op)
  (vau (plc . args) env
    (def lval (eval plc env))
    (caseType lval
      (Box (match args
        ((rval) (lval (op (lval) (eval rval env))))
        ((key rval) (lval key (op (lval) (eval rval env)))) ))
      (Obj (match args
        ((fld rval) (lval fld (op (lval fld) (eval rval env))))
        ((key fld rval) (lval key fld (op (lval fld) (eval rval env)))) ))
      (Object (match args
        ((rval) (eval (list 'def plc (op lval (eval rval env))) env))
        ((key rval) (eval (list 'set! plc key (op lval (eval rval env))) env)) )))))

(def $= (assignOp %$))
(def += (assignOp %+))
(def -= (assignOp %-))


;;;; Utilities

(def\ (array . args) (list->array args))

(def Array &java.lang.Object[])

(def\ (arrayMap fun (#! Array arr))
  (list->array (map fun (array->list arr))) )

(def\ (arrayFilter pred (#! Array arr))
  (list->array (filter pred (array->list arr))) )

(defVau (time exp) env
  (let1 (currentTime (@getMethod System "currentTimeMillis"))
    (def milli (currentTime #null))
    (def result (eval exp env))
    (def milli (- (currentTime #null) milli))
    (log ($ "time " exp ": " milli "ms"))
    result ))


;;;; Java Try/Resource

(defMacro (close1 binding . body)
  (list 'let1 binding
    (list* 'atEnd
      (list '@close (car binding))
      body )))

(defMacro (close bindings . body)
  (list 'let bindings
    (list* 'atEnd
      (list 'forEach '@close (cons 'list (map car bindings)))
      body )))


;;;; Error break routine, called by VM to print stacktrace and throw

(def\ (printFrames k)
  (let1 (k (.nxt k))
    (unless (null? k) (printFrames k)) )
  (log "v" k) )

(def\ invokeDebugger (condition)
  #|Invoke the debugger, which as a default just prints a stack trace
   |and panics, thereby throwing an exception to JS.  When running in the
   |REPL, this function gets replaced with a different one that runs a
   |nested debug loop.
   |#
  (takeSubcont rootPrompt k
    (pushDelimSubcont rootPrompt k
      (if (prStk) (printFrames k))
      (panic condition))))

(def\ panic (e)
  #|Mostly for internal use.  Signal the ERROR in such a way that it is
   |hard to handle and will usually escape the VM as a host language
   |exception.  In particular, signal handlers will not be invoked.
   |However, intervening `finally' cleanup expressions and `progv'
   |expressions are still triggered, so Lisp invariants are maintained.
   |$(fn (error))
   |$(type function)
   |#
  (throw e) )
