;;;                                                     -*- mode: Scheme -*-
;;; LispX Bootstrap
;;;

;; Copyright (c) 2021, 2022 Manuel J. Simoni

;; ``72. An adequate bootstrap is a contradiction in terms.''

;; Rename %def

(%def def
  #|Match the DEFINIEND-TREE against the VALUE and place resulting
   |bindings into the current environment.
   |$(fn (definiendTree value))
   |$(type fexpr)
   |#
  %def)


;;; Built-Ins - rename bindings that will be used as provided by VM

(def assert %assert)

(def ==
  #|Return true if the values A and B are pointer-identical, false otherwise.
   |$(fn (a b))
   |$(type function)
   |#
  %==)
(def != %!=)

(def string? %string?)
(def $ %$)

(def number? %number?)
(def + %+)
(def * %*)
(def - %-)
(def / %/)
(def % %%)

(def !
  #|Invert the BOOLEAN.
   |$(fn (boolean))
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  %!)
(def !! %!!)
(def < %<)
(def > %>)
(def <= %<=)
(def >= %>=)

(def ~ %~)
(def & %&)
(def \| %|)
(def ^ %^)
(def << %<<)
(def >> %>>)
(def >>> %>>>)

(def append
  #|Append two lists.  The first one must be proper and is copied.  The
   |second one is not copied (and doesn't even have to be a list). It
   |becomes the `cdr' of the final cons of the first list, or is returned
   |directly if the first list is empty.
   |$(fn (list1 list2))
   |$(type function)
   |#
  %append)

(def apply
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn (fun args . env))
   |$(type function)
   |$(derivation (eval (cons (unwrap fun) args) (if (null? env) (newEnv) (car! env)) ))
   |#
  %apply)

(def apply*
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn (fun . args)) 
   |$(type function)
   |$(derivation (apply fun args (newEnv)))
   |#
  %apply*)

(def apply**
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(fn (fun . args)) 
   |$(type function)
   |$(derivation (apply fun (apply list* args) (newEnv)))
   |#
  %apply**)

(def array->list %array->list)

(def atEnd
  #|valuate the PROTECTED-FORM and return its result.  Regardless of
   |whether the protected form returns normally, or via a nonlocal exit or
   |panic, the CLEANUP-FORM are evaluated after the protected forms.
   |$(fn (cleanupForm . protectedForms))
   |$(type fexpr)
   |#
  %atEnd)

(def begin
  #|Sequentially evaluate FORMS, returning the value of the last one, or void if there are no forms.
   |$(fn forms)
   |$(type fexpr)
   |#
  %begin)

(def bind? %bind?)

(def bound?
  #|Return true if the SYMBOL or KEYWORD is bound in the ENVIRONMENT or OBJ, false otherwise.
   |$(fn (symbol environment))
   |$(type function)
   |#
  %bound?)

(def newBox
  #|Create a new box with the optional INITIAL-VALUE?.  A box is a
   |function that encapsulates a mutable value.  Calling the box without
   |arguments returns the value.  Calling the box with an argument sets
   |the value.
   |$(fn initialValue?)
   |$(type function)
   |#
  %newBox)

(def cons
  #|Create a cons with the given CAR and CDR.
   |$(fn (car cdr))
   |$(type function)
   |#
  %cons)

(def cons?
  #|Return true if the OBJECT is a cons, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %cons?)

(def className
  #|Return the name symbol of the CLASS.
   |$(fn (class))
   |$(type function)
   |#
  %className)

(def classOf
  #|Return the class of the OBJECT.
   |$(fn (object))
   |$(type function)
   |#
  %classOf)

(def dval %dVal)
(def newDVar %newDVar)
(def eq? %eq?)
(def eval
  #|Evaluate the FORM in the ENVIRONMENT, returning its result.
   |$(fn (form environment))
   |$(type function)
   |#
  %eval)

(def if
  #|Evaluate the TEST which must yield a boolean.  Then evaluate either
   |the CONSEQUENT or ALTERNATIVE depending on whether the TEST yielded
   |true or false.
   |$(fn (test consequent . alternative))
   |$(fn (test1 consequent1 test2 consequent2 ... . alternative))
   |$(type fexpr)
   |$(derivation (vau (test then . else) env (if (eval then env) (eval then env) (null? else) #inert (null? (cdr else)) (eval (car else)) (apply if else env))))
   |#
  %if)

(def intern
  #|Get or create the unique symbol with STRING as name.
   |$(fn (string))
   |$(type function)
   |#
  %intern)

(def instanceOf? %instanceOf?)

(def keyword %keyword)
(def keyword? %keyword?)
(def keywordName %name)
(def len %len)
(def list*
  #|Create a list from the ARGUMENTS so that the last argument becomes
   |the `cdr' of the list.
   |$(fn arguments)
   |$(type function)
   |#
  %list*)

(def list?
  #|Return true if the OBJECT is a list, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %list?)

(def list->array %list->array)
(def loop
  #|Evaluate the FORMS in an infinite loop.
   |$(fn forms)
   |$(type fexpr)
   |#
  %loop)

(def newEnv
  #|Create a new environment with an optional PARENT-ENVIRONMENT? in
   |which bindings are looked up if they are not found.
   |$(fn parentEnvironment?)
   |$(type function)
   |#
  %newEnv)

(def null?
  #|Return true if the OBJECT is nil, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %null?)
(def !null? %!null?)
(def not
  #|Invert the BOOLEAN.
   |$(fn (boolean))
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  !)

(def nth
  #|Return element number N of LIST, where the `car' is element zero.
   |$(fn (n list))
   |$(type function)
   |#
  %nth)

(def nthCdr
  #|Returns the tail of LIST that would be obtained by calling `cdr' N times in succession.
   |$(fn (n list))
   |$(type function)
   |#
  %nthCdr)

(def new
  #|Create a new instance of CLASS (that must be a `standard-class').
   |The SLOT-INITS must be of even length, and alternately contain slot
   |names (symbols, typically keywords) and values.
   |$(fn (class . slotInits))
   |#
  %new)

(def reverse
  #|Reverse the LIST.
   |$(fn (list))
   |$(type function)
   |#
  %reverse)
(def rootPrompt %rootPrompt)
(def set! %set!)
(def symbol %symbol)
(def symbol? %symbol?)

(def symbolName
  #|Return the name of the SYMBOL as a string.
   |$(fn (symbol))
   |$(type function)
   |#
  %name)

(def subClass?
  #|Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.
   |A class is considered a subclass of itself.
   |$(fn (class superclass))
   |$(type function)
   |#
  %subClass?)

(def the %the)

(def type?
  #|Return true if the OBJECT is an instance of the CLASS, false otherwise.
   |$(fn (object class))
   |$(type function)
   |#
  %type?)
(def value %value)
(def unwrap
  #|Return the underlying operator of a FUNCTION.
   |$(fn (function))
   |$(type function)
   |#
  %unwrap)

(def wrap
  #|Create a new function that wraps around an underlying OPERATOR, and
   |induces argument evaluation around it.
   |$(fn (operator))
   |$(type function)
   |#
  %wrap)


;;; Core Forms

(def vau
  #|Construct a fexpr with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (parameterTree environmentParameter . forms))
   |$(type fexpr)
   |$(derivation (vau (pt ep . forms) env (eval (list 'vau pt ep (cons 'begin forms)) env)))
   |#
  %vau)

(def theEnv
  #|Return the current environment.
   |$(fn parent?)
   |$(type fexpr)
   |$(derivation (vau () environment environment)))
   |#
  %theEnv)

(def quote
  #|Return the unevaluated OPERAND.
   |$(fn (operand))
   |$(type fexpr)
   |$(derivation (vau (operand) #ignore operand))
   |#
  %')

(def list
  #|Return the list of evaluated ARGUMENTS.
   |$(fn arguments)
   |$(type function)
   |$(derivation (wrap (vau arguments #ignore arguments))
   |#
  %list)

(def \
  #|Create an anonymous function with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type function)
   |$(derivation (vau (parameterTree . forms) env (wrap (eval (list* 'vau parameterTree #ignore forms) env))))
   |#
  %\)

(def car
  #|Return the contents of the address part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %car)

(def car!
  #|Return the contents of the address part of the register if decrement part of the register is null, else error.
   |#
  (\ ((car)) car))

(def cadr
  #|Return the `car' of the `cdr' of the CONS.
   |$(derivation (car (cdr cons)))
   |$(derivation (\ ((#_ . (cadr . #_))) cadr))
   |$(derivation (\ ((#_ cadr . #_)) cadr))
   |#
  %cadr)

(def cadr!
  #|Return the `car' of the `cdr' of the CONS if 'cddr' is null, else error.
   |#
  (\ ((#_ cadr)) cadr))

(def cdr
  #|Return the contents of the decrement part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %cdr)

(def cddr
  #|Return the `cdr' of the `cdr' of the CONS.
   |$(derivation (cdr (cdr cons)))
   |$(derivation (\ ((#_ . (#_ . cddr))) cddr))
   |$(derivation (\ ((#_ #_ . cddr)) cddr))
   |#
  %cddr)

(def caar
  #|Return the `car' of the `car' of the CONS.
   |#
  (\ (x) (car (car x))))

(def cdar
  #|Return the `cdr' of the `car' of the CONS.
   |#
  (\ (x) (cdr (car x))))

(def compose
  #|Compose two functions, creating a new function equivalent to (G (F ...)).
   |#
  (\ (f g) (\ args (f (apply g args)))) )

(def compose* 
  (\ f* (\ args ((rec\ (loop (f . f*)) (if (null? f*) (apply f args) (f (loop f*)))) f*))) )

(def curry
  (\ (f v) (\ args (apply f (cons v args)))) )

(def curry*
  (\ (f . v*) (\ args (apply f (append v* args)))) )

(def idx
  #|Identity function.
   |#
  (\ (x) x))

(def 1+
  (\ (n) (+ n 1)))

(def 1-
  (\ (n) (- n 1)))


;;; Macro

(def evalMacro (newBox #t))

(def makeMacro
  #|Create a macro from an EXPANDER operator.
   |A macro is an operator that receives an operand and produces a form
   |(by calling the expander with the operand as argument)
   |that is then evaluated in place of the operand.
   |$(fn (expander))
   |$(type function)
   |#
  (wrap
    (vau (expander) #ignore
      (vau operands env
        (def !evalMacro (! (evalMacro :prv #t)))
        (def exp (apply expander operands (newEnv)))
        (if !evalMacro exp (eval exp env)) ))))

(def macro
  #|Create an anonymous macro with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type macro)
   |#
  (makeMacro
    (vau (pt . forms) #ignore
      (list 'makeMacro (list* 'vau pt #ignore forms)) )))


; defMacro defVau def\ def*\ rec\ let1\ let1rec\ let\ letrec\ permettono la definizione in due forme
;
;    (_ name parameters . body)
;    (_ (name . parameters) . body)
;
; rec rec\ let1rec let1rec\ letrec letrec\ inizializzano a #inert le definizioni prima della valutazione


(def defMacro
  #|Define a macro with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (macro (lhs . rhs)
    (if (cons? lhs)
      (list 'def (car lhs) (list* 'macro (cdr lhs) rhs))
      (list 'def lhs (cons 'macro rhs)) )))

(defMacro (expand macro)
  (list 'begin (list 'evalMacro #f) macro) )

(defMacro (defVau lhs . rhs)
  #|Define a fexpr with the given NAME, PARAMETER-TREE,
   |ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (cons? lhs)
    (list 'def (car lhs) (list* 'vau (cdr lhs) rhs))
    (list 'def lhs (cons 'vau rhs)) ))

(def defConstant
  #|Define a constant with the given NAME and VALUE.  This is mostly
   |for documentation purposes, as constants are still mutable.
   |#
  def)

(defMacro (wrau pt ep . body)
  (list 'wrap (list* 'vau pt ep body)))

(defMacro (def* lhs . rhs)
  (list 'def lhs (cons 'list rhs)) )

(defMacro (def\ lhs . rhs)
  #|Define a function with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (cons? lhs)
    (list 'def (car lhs) (list* '\ (cdr lhs) rhs))
    (list 'def lhs (cons '\ rhs)) ))


;;;; Basic value test

(def\ (inert? o) (== o #inert))
(def\ (zero? n) (== n 0))
(def\ (uno? n) (== n 1))
(def\ (even? n) (== (% n 2) 0))
(def\ (odd? n)  (== (% n 2) 1))


;;; Wrap incomplete VM forms

(def* (then else) begin begin)

(defMacro (finally x . cnl)
  (list 'atEnd (cons 'begin cnl) x) )  

(defMacro (throw . val) (list* '%throwTag #_ val) )
(def throwTag
  #|Abort to a nesting catch tag established by `catch' and pass the
   |optional RESULT? (defaults to void) to it.
   |$(fn (tag . val))
   |$(type macro)
   |#
  %throwTag)

;; ctApv non andrebbe mai cambiato dopo il boot, anche la riesecuzione di quanto segue potrebbe non bastare!
(if (ctApv)
  (then
    (defMacro (catch . forms)
      (list '%catchTagWth #_ #_ (list* '\ () forms)) )
    (defMacro (catchWth hdl . forms)
      (list '%catchTagWth #_ hdl (list* '\ () forms)) )
    (defMacro (catchTag tag . forms)
      #|Establish a catch tag and evaluate FORMS as an implicit `begin' inside it.
       |The forms may use `throw' to nonlocally exit from the tag.
       |Usually, `block' should be preferred.
       |#
      (list '%catchTagWth tag #_ (list* '\ () forms)) )
    (defMacro (catchTagWth tag hdl . forms)
      (list '%catchTagWth tag hdl (list* '\ () forms)) )
  )
  (else
    (defMacro (catch . forms)
      (list* '%catchTagWth #_ #_ forms))
    (defMacro (catchWth hdl . forms)
      (list* '%catchTagWth #_ hdl forms))
    (defMacro (catchTag tag . forms)
      #|Establish a catch tag and evaluate FORMS as an implicit `begin'
       |inside it.  The forms may use `throw' to nonlocally exit from the
       |tag.  Usually, `block' should be preferred.
       |#
      (list* '%catchTagWth tag #_ forms) )
    (def catchTagWth
      #|Establish a catch tag and evaluate FORMS as an implicit `begin' inside it.
       |The forms may use `throw' to nonlocally exit from the tag.
       |Usually, `block' should be preferred.
       |$(fn (tag hdl . forms))
       |$(type operatore)
       |#
      %catchTagWth)
  )
)


;;; Delimited Control Operators

;; These operators follow the API put forth in the delimcc library
;; at URL `http://okmij.org/ftp/continuations/implementations.html'.

(def takeSubcont
  #|Abort outwards to the PROMPT.  When the prompt is reached, evaluate
   |the FORMS with NAME bound to the captured continuation (which does not
   |include the prompt).
   |$(fn (prompt symbol . forms))
   |$(type operatore)
   |#
  %takeSubcont)

(def pushPrompt
  #|Push the PROMPT and evaluate the FORMS inside the prompt.  This
   |delimits the continuation.
   |$(fn (prompt . forms))
   |$(type operatore)
   |#
  %pushPrompt)

(def pushDelimSubcont
  #|Push the PROMPT and compose the previously captured CONTINUATION
   |inside it.  The FORMS are then evaluated inside the new continuation.
   |$(fn (prompt continuation . forms))
   |$(type operatore)
   |#
  %pushDelimSubcont)

(defMacro pushSubcont (continuation . forms)
  #|We don't have `pushSubcont' but for these tests we can emulate it
   |with a `pushDelimSubcont' that pushes an unused prompt.
   |$(fn (continuation . forms))
   |$(type macro)
   |#
  (list* '%pushDelimSubcont #ignore continuation forms) )

(def pushSubcontBarrier
  #|Push a continuation barrier that prevents the FORMS from capturing
   |any continuations to the outside.
   |$(fn forms)
   |$(type operatore)
   |#
  %pushSubcontBarrier)


;;; Basic macros and functions

(defMacro (rec lhs . rhs)
  (list (list '\ (list lhs) (list* 'def lhs :rhs rhs)) #inert) )

(def label rec)

(defMacro (rec\ lhs . rhs)
  (if (cons? lhs)
    (list 'rec (car lhs) (list* '\ (cdr lhs) rhs))
    (list 'rec lhs (cons '\ rhs)) ))

(def label\ rec\)

(def\ (map f lst . lst*)
  #|Create a new list by applying the FUNCTION to every element of the LIST.
   |#
  (if (null? lst*)
    ((rec\ (map lst) (if (null? lst) #null (cons (f (car lst)) (map (cdr lst))) )) lst)
    ((rec\ (map* lst*) (if (null? (car lst*)) #null (cons (apply f (map car lst*)) (map* (map cdr lst*))) )) (cons lst lst*)) ))

; apply: (eval (cons opv args) env) <=> (apply opv args env)
; apply: (eval (cons apv args) env) <=> (apply apv (evlis env args) env)
; evlis: (map (\ (x) (eval x env)) x*) <=> (eval (cons 'list x*) env)

(defMacro (def*\ lhs* . rhs*)
  (list* 'def*
    (map (\ (lhs) (if (cons? lhs) (car lhs) lhs)) lhs*)
    (map (\ (lhs rhs) (cons '\ (if (cons? lhs) (cons (cdr lhs) rhs) rhs))) lhs* rhs*) ))


;;; Lexical Bindings

(def\ (->begin binding) ((\ ((#_ cadr . cddr)) (if (null? cddr) cadr (list* 'begin cadr cddr))) binding))
(def\ (->name+#inert (lhs . #_)) (list (if (cons? lhs) (car lhs) lhs) #inert))
(def\ (->name+lambda (lhs . rhs)) (if (cons? lhs) (list (car lhs) (list* '\ (cdr lhs) rhs)) (list lhs (cons '\ rhs)) ))
;(def\ (->name+lambda (lhs . rhs)) (list (if (cons? lhs) (car lhs) lhs) (cons '\ (if (cons? lhs) (cons (cdr lhs) rhs) rhs))))
;(def\ (->name+lambda (lhs . rhs)) (def t (cons? lhs)) (list (if t (car lhs) lhs) (cons '\ (if t (cons (cdr lhs) rhs) rhs))))
;(def\ (->name+lambda (lhs . rhs)) (list (if (def t :rhs (cons? lhs)) (car lhs) lhs) (cons '\ (if t (cons (cdr lhs) rhs) rhs))))


(defMacro (wth1 dt value . forms)
  (list (list* '\ (cons dt) forms) value))

(defMacro (wth* bindings . forms)
  ( (rec\ (loop bindings)
      (if (null? bindings)
        (cons (list* '\ () forms))
        (wth1 (dt value . bindings) bindings
          (list* 'wth1 dt value (cons (loop bindings))) ))) 
    bindings ))

(defMacro (wth b* . forms)
  (def dt* ((rec\ (loop b*) (if (null? b*) #null (wth1 (dt #_ . b*) b* (cons dt (loop b*))))) b*))
  (def vl* ((rec\ (loop b*) (if (null? b*) #null (wth1 (#_ vl . b*) b* (cons vl (loop b*))))) b*))
  (cons (list* '\ dt* forms) vl*) )


(defMacro (let1Loop lhs . rhs)
  (if (cons? lhs)
    (def* ((name . binding) body) lhs rhs)
    (def* (name (binding . body)) lhs rhs) )
  (list
    (list* 'rec\ name (cons (car binding)) body)
    (->begin binding) ))

#| TODO da valutare
(defMacro (let1 lhs . rhs)
  (if (symbol? lhs)
    (list* 'let1Loop lhs rhs)
    (list* 'wth1 (car lhs) (->begin lhs) rhs)))
|#

(defMacro (let1 lhs . rhs)
  (if (symbol? lhs)
    (list* 'let1Loop lhs rhs)
    (list (list* '\ (list (car lhs)) rhs)
      (->begin lhs) )))

(defMacro (let1\ binding . body)
  (list* 'let1 (->name+lambda binding) body))

(defMacro (let1rec binding . body)
  (def name (car binding))
  (list* 'let1 (list name #inert)
    (list 'def (car name (->begin binding))
      body )))

(defMacro (let1rec\ binding . body)
  (list* 'let1 (->name+#inert binding)
    (cons 'def\ binding)
    body ))


(defMacro (let* bindings . body)
  #|Establish BINDINGS serially during the evaluation of FORMS, so that
   |every binding can refer to previous ones.
   |$(syntax bindings ((definiendTree value) . bindings))
   |#
  ( (rec\ loop (bindings)
      (if (null? bindings)
        (cons (list* '\ () body))
        (list* 'let1 (car bindings) (cons (loop (cdr bindings)))) ))
    bindings ))


(defMacro (letLoop lhs . rhs)
  #|Labelled recursive loop, analogous to Scheme's named `let'.
   |Lexically bind a function named NAME with one PARAMETER for every
   |INITIALIZER and the FORMS as body.  Then immediately apply the
   |function to a list containing one VALUE for every INITIALIZER and
   |return the result.  The function is bound per `labels' so it can
   |recursively refer to itself.
   |$(fn (initializers . body))
   |$(fn (name initializers . body))
   |$(syntax initializers ((parameter value) . initializers)
   |#
  (if (cons? lhs)
    (def* ((name . bindings) body) lhs rhs)
    (def* (name (bindings . body)) lhs rhs) )
  (cons
    (list* 'rec\ name (map car bindings) body)
    (map ->begin bindings) ))


(defMacro (let lhs . rhs)
  #|Establish BINDINGS parallelly during the evaluation of FORMS, so
   |that no binding can refer to the other ones.
   |$(fn (bindings . body))
   |$(fn (name bindings . body))
   |$(syntax bindings ((parameter value) . bindings)
   |#
  (if (symbol? lhs)
    (list* 'letLoop lhs rhs)
    (cons (list* '\ (map car lhs) rhs)
      (map ->begin lhs) )))

(defMacro (let\ bindings . body)
  #|Establish FUNCTION-BINDINGS parallelly during evaluation of FORMS,
   |so that no function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  (list* 'let (map ->name+lambda bindings) body))

(defMacro (letrec bindings . body)
  #|Utility to establish BINDINGS recursively during the evaluation of
   |FORMS.  Used by `labels'.
   |#
  (def names (map car bindings))
  (list* 'let (map (\ (name) (list name #inert)) names)
    (list* 'def* names (map ->begin bindings))
    body ))

(defMacro (letrec\ bindings . body)
  (list* 'let (map ->name+#inert bindings)
    (list* 'def*\ (map car bindings) (map cdr bindings))
    body ))

(def labels
  #|Establish FUNCTION-BINDINGS recursively during evaluation of FORMS,
   |so that every function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  letrec\)


;;;; Simple Control

(defVau prog1 (form . forms) env
  #|Evaluate FORM and any additional FORMS, and return the result of FORM.
   |#
  (let1 (result (eval form env))
    (apply begin forms env)
    result))

(defMacro (when test . forms)
  #|If TEST yields true, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list 'if test (cons 'then forms)))

(defMacro (unless test . forms)
  #|If TEST yields false, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list 'if test #inert (cons 'else forms)))

(defVau set (ep dt value) env
  #|Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT,
   |creating or updating existing bindings.  Unlike Common Lisp (or
   |Scheme), we have no `setq' (or `set!') that allows updating arbitrary
   |bindings -- you always need to know the environment a binding is in to
   |change it.  Therefore, we usually use boxes (see below) instead of
   |mutating bindings directly.
   |#
  (eval
    (list 'def dt (list (unwrap eval) value env))
    (eval ep env)))


;;; And Or

(defVau && ops env
  #|Return true if all OPERANDS evaluate to true, false otherwise.
   |If an operand evaluates to false, later operands are not evaluated.
   |If there are no operands, return false.
   |#
  (if
    (null? ops) #t
    (eval (car ops) env) (apply && (cdr ops) env)
    #f ))

(def and &&)

(defVau || ops env
  #|Return true if one of the OPERANDS evaluates to true, false otherwise.
   |If an operand evaluates to true, later operands are not evaluated.
   |If there are no operands, return true.
   |#
  (if
    (null? ops) #f
    (eval (car ops) env) #t
    (apply || (cdr ops) env) ))

(def or ||)


;;;; Bind? IfBind? CaseVau Case\ Match

(defVau (ifBind? (pt exp) then . else) env
  (let1 (env+ (newEnv env))
    (if (bind? env+ pt (eval exp env))
      (eval then env+)
      (unless (null? else)
        (eval (car! else) env) ))))

(defVau (caseVau . clauses) env
  (vau values #ignore
    (let1 loop (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((bindings . forms) . clauses) clauses)
          (if (== bindings 'else)
            (if (== (car forms) '=>)
              ((eval (cadr! forms) env) values)
              (apply begin forms env) )
            (let1 (env+ (newEnv env)) 
              (if (bind? env+ bindings values)
                (apply begin forms env+)
                (loop clauses) ))))))))

(defMacro (defCaseVau sym . clauses)
  (list 'def sym (cons 'caseVau clauses)) )

(defMacro (case\ . clauses)
  (list 'wrap (cons 'caseVau clauses)) )

(defMacro (defCase\ sym . clauses)
  (list 'def sym (cons 'case\ clauses)) )

(defMacro (match exp . clauses)
  (list (cons 'case\ (map (\ ((a . b)) (list* (if (== a 'else) a (list a)) b)) clauses)) exp) )


;;; Quasiquote

;; (Idea from Alf Petrofsky http://scheme-reports.org/mail/scheme-reports/msg00800.html)
(defVau %` (x) env
  (defCase\ qq
    ( ((('%,@ x) . y) #f . d) (append (map (\ (x) (list '%,@ x)) (apply** qq (list x) d)) (apply** qq y #f d)) )
    ( ((('%,@ x) . y) . d)    (append (eval x env) (apply** qq y d)) )
    ( ((('%, x) . y) #f . d)  (append (map (\ (x) (list '%, x))  (apply** qq (list x) d)) (apply** qq y #f d)) )
    ( (('%, x) #f . d)        (list '%, (apply** qq x d)) )
    ( (('%, x) . d)           (eval x env) )
    ( (('%` x) . d)           (list '%` (apply** qq x #f d)) )
    ( ((x . y) . d)           (cons (apply** qq x d) (apply** qq y d)) )
    ( (x . d)                 x) )
  (qq x))


;;; Cond

(defVau (cond . clauses) env
  #|Multi-armed conditional.
   |Go through the CLAUSES in order.  Evaluate the TEST.
   |If it yields true, evaluate the FORMS as an implicit `begin'.
   |If it yields false, go to the next clause,
   |or return void if there are no more clauses.
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (else . forms))
   |$(syntax clause (test->bool . forms))
   |$(syntax clause (test))
   |$(syntax clause (test => apv1))
   |$(syntax clause (test guard => apv1))
   |#
  (unless (null? clauses)
    (let1 (((test . body) . clauses) clauses)
      (if (== test 'else)
        (apply begin body env)
        (let1 (test (eval test env))
          (if (instanceOf? test Boolean)
            (if test
              (apply begin body env)
              (apply cond clauses env) )
            (match body
              (() test)
              (('=> apv1) ((eval apv1 env) test))
              ((guard '=> apv1)
                 (if ((eval guard env) test)
                   ((eval apv1 env) test)
                   (apply cond clauses env) ))
              (else (apply cond clauses env)) )))))))


;;; Options

;; An option is either nil ("none"), or a one-element list ("some").

(def\ some (value)
  #|Create a one-element list from the VALUE.
   |#
  (cons value))

(def\ (01->+ forms)
  (if (null? forms) #null (1->+ forms)) )

(def\ (1->+ (#! List forms))
  (if (null? (cdr forms)) (car forms) (cons 'begin forms)) )

;; (Idea from Taylor R. Campbell's blag. https://mumble.net/~campbell/blag.txt)
(defVau (ifOpt (pt opt) then . else) env
  #|Destructure the OPTION?.  If it's non-nil, evaluate the THEN form
   |with the NAME bound to the contents of the option.  If it's nil,
   |evaluate the ELSE form.
   |#
  (let1 (opt (eval opt env))
    (if (null? opt)
      (if (null? else) #null
        (eval (1->+ else) env))
      (if (list? opt)
        (eval (list* (list 'vau (list pt) #ignore then) opt) env)
        (typeError opt '(or () List)) ))))

(defVau (ifOpt* (pt opt) then . else) env
  (let1 (opt (eval opt env))
    (if (null? opt)
      (if (null? else) #null
        (eval (1->+ else) env))
      (if (list? opt)
        (eval (list* (list 'vau pt #ignore then) opt) env)
        (typeError opt '(or () List)) ))))

(defMacro whenOpt ((pt opt) . forms)
  #|Destructure the OPTION?.  If it's non-nil, evaluate the FORMS with
   |the NAME bound to the contents of the option.  If it's nil, return nil.
   |#
  (list 'ifOpt (list pt opt) (01->+ forms)) )

(defMacro unlessOpt (opt . forms)
  #|Destructure the OPTION?.  If it's nil, evaluate the FORMS.  If it's
   |non-nil, return nil.
   |#
  (list* 'ifOpt (list #ignore opt) #null (01->+ forms)) )

(defVau (caseOpt opt . clauses) env
  (let1 (opt (eval opt env))
    (if (null? opt) #null
      (let1 loop (clauses clauses)
        (if (null? clauses) #null
          (let ( (env+ (newEnv env))
                 (((bindings . forms) . clauses) clauses) )
            (if (|| (== bindings 'else) (bind? env+ bindings opt))
              (apply begin forms env+)
              (loop clauses) )))))))

(defVau (optDft opt . dft) env
  #|Return the contents of the OPTION?, or the DEFAULT? if the option
   |is nil.  The default itself defaults to void.  The DEFAULT? is
   |evaluated lazily, only when the OPTION? is nil.
   |#
  (ifOpt (opt (eval opt env)) opt
    (ifOpt (dft (eval (cons 'list dft) env)) dft) ))

(defVau optDft* (lst . dft) env
  #|Similar to `opt', but provides DEFAULTS for any number of
   |elements of LIST.  This is useful for implementing functions that take
   |multiple optDft arguments.  Each default is evaluated lazily, only when needed.
   |#
  (let loop ((lst (eval lst env)) (dft dft))
    (if (null? lst)
      (if (null? dft) #null
         (cons (eval (car dft) env) (loop #null (cdr dft))) )
      (if (null? (car lst))
        (if (null? dft)
          (cons #null (loop (cdr lst) #null))
          (cons (eval (car dft) env) (loop (cdr lst) (cdr dft))) )
        (cons (car lst)
          (loop (cdr lst) (if (null? dft) #null (cdr dft)))) ))))

(def\ optDft! (opt)
  #|Returns the contents of the OPTION? or signals an error if it is nil.
   |#
  (optDft opt (simpleError "Option is nil")))


;;;; OptValue Member Member? !Member? OptKey Assoc

(def\ (optValue key lst)
  #|Search for the KEYWORD in the property list LST
   |(a list of alternating keywords and values)
   |and return the found value as an option.
   |#
  (let1 loop (lst lst)
    (if (cons? lst)
      (let1 ((k v . lst) lst)
        (if (== k key) (cons v) (loop lst)) )
      #null )))

(def\ (member k lst . keywords)
  #|Search for ITEM in the LIST according to the TEST predicate
   |(defaults to `==').  Return the tail of the list starting with
   |ITEM if found, nil otherwise.  The KEY function is applied to
   |each list element before comparison (defaults to `idx').
   |$(fn (item list &key test key))
   |#
  (let ( (cmp (optDft (optValue :cmp keywords) ==))
         (key (optDft (optValue :key keywords) idx))
         (ret (optDft (optValue :ret keywords) idx)) )
    (let1 loop (lst lst)
      (if (cons? lst)
        (if (cmp (key (car lst)) k) (ret lst)
          (loop (cdr lst)) )
        #null ))))

(def\ (member? key lst . keywords)
  (cons? (apply** member key lst keywords)) )
  
(def\ (!member? key lst . keywords)
  (null? (apply** member key lst keywords)) )

(def\ (optKey key lst)
  (if (cons? key) ((rec\ (loop lst) (if (cons? lst) (let1 (k (car lst)) (if (member? k key) k (loop (cdr lst)))) #null)) lst)
    (member? key lst) key
    #null ))

(def\ (assoc k lst) 
  (member k lst :key car :ret car) )


;;; Case MatchObj? CaseType CaseType\

(defVau (case exp . clauses) env
  (let1 (value (eval exp env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((values . forms) . clauses) clauses)
          (if (|| (== values 'else) (== value values) (member? value values))
            (if (null? forms) #inert
              (if (== (car forms) '=>)
                ((eval (cadr! forms) env) value)
                (apply begin forms env) ))
            (next clauses) ))))))

(def matchObj? %matchObj?)

(def\ (matchObj*? obj class . slots) 
  (matchObj? obj (cons class slots)) )

; vedi signalsError? in vm.lispx (o test-util.lispx) per codice simile
(defVau (caseType key . clauses) env
  #|Multi-armed type test.
   |Evaluate the KEYFORM.  Go through the CLAUSES.  If the result of
   |evaluating KEYFORM is an instance of the class named by CLASS-NAME,
   |evaluate the FORMS as an implicit `begin'.  Otherwise go to the next
   |clause, or return void if there are no more clauses.
   |$(fn (key . clauses))
   |$(type fexpr)
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (className . forms))
   |$(syntax clause ((className . slotSpecs) . forms))
   |#
  (let1 (key (eval key env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((test . forms) . clauses) clauses)
          (if (|| (== test 'else)
                  (let* ( (symbol? (symbol? test))
                          (class (eval (if symbol? test (car test)) env)) )
                    (if symbol? (type? key class) (matchObj? key (eval (cons 'list test) env))) ))
            (if (== (car forms) '=>)
              ((eval (cadr! forms) env) key)
              (apply begin forms env) )
            (next clauses) ))))))

(defMacro (caseType\ (#! Symbol key) . clauses)
  (list '\ (cons key) (list* 'caseType key clauses) ))   

(defMacro (caseType\ (#! (1 Symbol) key) . clauses)
  (list '\ key (list* 'caseType (car key) clauses) ))   


;;; Sort

(def\ (sort lst . opt)
  (def cmp (case (optKey (:up :dn) opt) ((#null :up) <) (:dn >=)))
  (def key (optDft (optValue :key opt) idx))
  (def\ (sort lst)  
    (if (<= (len lst) 1) lst
      (let loop ( (left ()) (right ()) (pivot (car lst)) (rest (cdr lst)) )
        (if (null? rest)
            (append (append (sort left) (list pivot)) (sort right))
          (cmp (key (car rest)) (key pivot))
            (loop (append left (list (car rest))) right pivot (cdr rest))
            (loop left (append right (list (car rest))) pivot (cdr rest)) ))))
  (sort lst) )


;;; Type Checks

(def\ assert#t (boolean)
  #|Signal an error if the BOOLEAN is false. Otherwise return void.
   |#
  (unless boolean (error (new Error "invalid assetion" :type 'assert :datum boolean :expected #t))))

(def\ makeTypeError (datum expected)
  #|Create a `type-error' with the given DATUM and EXPECTED-TYPE.
   |#
  (new Error "not a {expected}: {datum}" :type 'type :datum datum :expected expected) )

(def\ typeError (datum expected)
  #|Signal a `type-error'
   |#
  (error (makeTypeError datum expected)) )

(def the
  #|Signal a `type-error' if the OBJECT is not an instance of the CLASS, else return object.
   |$(fn (class object)
   |$(type function)
   |#
  %the)

(defVau (check o ck) env
  ((wrap %check) (eval o env) ck) )

(defVau (check o ck) env
  (apply %check (list (eval o env) ck) env) )

(defMacro (check* o . cks)
    (list 'check o cks) )

(defVau check? args env
  (catchTagWth 'check? #f
    (handlerBind ((Error (\ (#_) (throwTag 'check?))))
      (apply check args env)
      #t )))

(defMacro (the+ ck obj) (list 'let1 (list 'obj obj) (list 'check 'obj ck) 'obj))

; TODO non è più così costosa la conversione, si può fare
; (def the the+)


;;; Block Loop For While Until DoTimes Repeat

(defVau block (blockName . forms) env
  #|Establish a block named BLOCK-NAME and evaluate the FORMS as an
   |implicit `begin' inside it.  The forms may use `returnFrom' to
   |nonlocally exit from the block.
   |Note that unlike in Common Lisp, there is no separate namespace for
   |block names; a block is named in the normal variable namespace.
   |#
  (let* ( (tag (list #inert)) ; cons up a fresh object as tag
          (escape (\ value (throwTag tag (if (cons? value) (car! value))))) )
    (catchTag tag
      (eval (list (list* '\ (list blockName) forms) escape) env) )))

(def\ returnFrom (blockName . value?)
  #|Abort evaluation and return the optional VALUE? (which lsts to
   |void) from the block named BLOCK-NAME.  It is an error to return from
   |a block whose dynamic extent has ended.
   |$(fn (blockName . value?))
   |#
  (blockName (optDft value? #inert)) )

(defVau while (testForm . forms) env
  #|Evaluate FORMS while TEST-FORM evaluates to true.
   |#
  (let ((forms (cons 'begin forms)))
    (block exit
      (loop
        (if (eval testForm env)
            (eval forms env)
            (returnFrom exit #inert))))))

(def %loop
  (let ( (%loop %loop)
         (makeTag
           (\ (i name %deep)
             (if (&& (>= i (- 0 %deep)) (<= i 0))
               (symbol ($ name (+ %deep i)))
               (@typeError vm ($ "invalid " name " index, not {expected}: {datum}") i `(and (>= ,(- 0 %deep)) (=< 0))) ))) )
    (let\ ( ((makeThrowTag\ name %deep)
               (\ (#! (0 1 Integer) i)
                 (throwTag (makeTag (optDft i 0) name %deep)) ))
            ((makeThrowTagValue\ name %deep)
               (\ o
                 (if (== (check o (or (1) (2 Integer))) 1)
                   (throwTag (makeTag 0 name %deep) (car o))
                   (throwTag (makeTag (car o) name %deep) (cadr o)) ))) )
      (vau forms env
        (let1 (%deep (let1 (%deep (value :%deep env)) (if (null? %deep) 0 (+ %deep 1))))
          (let ( (break (symbol ($ "break" %deep)))
                 (continue (symbol ($ "continue" %deep))) )
            (let1 (env (newEnv (newEnv env
                    :%deep %deep
                    :break (makeThrowTag\ "break" %deep)
                    :continue (makeThrowTag\ "continue" %deep)
                    :break/v (makeThrowTagValue\ "break" %deep)
                    :until! (\ (b) (if b (throwTag break)))
                    :while! (\ (b) (if (! b) (throwTag break)))
                    :until* (macro (b . forms) `(if ,b (throwTag ',break (begin ,@forms)))) 
                    :while* (macro (b . forms) `(if (! ,b) (throwTag ',break (begin ,@forms)))) ))) 
              (if (check? forms (2 oo 'for ((2 3)) )) ;loop for
                (let ( (for (cadr forms))
                       (forms (01->+ (cddr forms))) )
                  (def increments (list* 'def* (map car for) (map (\((#_ init . incr)) (optDft incr init)) for)))
                  (catchTag break
                    (eval (list* 'def* (map car for) (map cadr for)) env)   
                    (%loop
                      (catchTag continue (eval forms env) )
                      (eval increments env) )))
                (if (check? forms (2 oo 'for1 (2 3))) ;loop for1
                  (let ( ((pt init . incr) (cadr forms))
                         (forms (01->+ (cddr forms))) )
                    (def increment (list 'def pt (optDft incr init)))
                    (catchTag break
                      (eval (list 'def pt init) env)
                      (%loop
                        (catchTag continue (eval forms env) )
                        (eval increment env) )))
                  (let1 (forms (01->+ forms)) ;loop
                    (catchTag break
                      (%loop
                        (catchTag continue
                          (eval forms env) )))) )))))) )))

(def loop %loop)

(defMacro (for ((#! Symbol var) init cond . incr) . body)
  (list* 'loop 'for1 (list* var init incr)
    (if (%ignore? cond) body
      (cons (list 'while! cond) body) )))

(defMacro (for ((#! Symbol var) init . incr) cond . body)
  (list* 'loop 'for1 (list* var init incr)
    (if (%ignore? cond) body
      (cons (list 'while! cond) body) )))

(defMacro (while cond . forms)
  #|Evaluate FORMS while TEST-FORM evaluates to true.
   |#
  (list* 'loop (list 'while! cond) forms ))

(defMacro until (cond . forms)
  #|Evaluate FORMS until TEST-FORM evaluates to true.
   |#
  (list* 'loop (list 'until! cond) forms) )

(defMacro doTimes ((var times . result) . body)
  #|Cf. Common Lisp's DOTIMES.
   |#
  (let1\
    (doTimes (times body result)
      (let1 (i (newBox 0))
        (while (< (i) times) (body (i)) (++ i) )
        (result (i)) ))
    (list doTimes
      times
      (list* '\ (list var) body)
      (list* '\ (list var) result) )))

(defVau (repeat times . forms) env
  (if (cons? times) 
    (let* ( (((#! Symbol var) times . ending) times)
            ((#! (and Integer (> 0)) times) (eval times env))
            (env (newEnv env var 0)) )
      (loop (def result (apply begin forms env))
        (if (>= (eval (list '++ var) env) times)
          (break/v (if (null? ending) result (apply begin ending env))) )))
    (let1 ((#! (and Integer (> 0)) times) (eval times env))
      (loop (def result (apply begin forms env))
        (if (zero? (-- times)) (break/v result)) ))))

(defMacro doTimes ((var times . result) . body)
  (list* 'repeat (list* var times result) body) )

#| TODO in alternativa del precedente, da verificare
(defVau (repeat times . forms) env
  (if (cons? times) 
    (let* ( (((#! Symbol var) times . ending) times)
            ((#! (and Integer (>= 0)) times) (eval times env))
            (env (newEnv env var 0)) )
      (loop (if (>= (env var) times)
              (break/v (if (!null? ending) (apply begin ending env) (zero? times) #inert result)) )
            (def result (apply begin forms env))
            (eval (list '++ var) env) ))
    (let1 ((#! (and Integer (> 0)) times) (eval times env))
      (loop (def result (apply begin forms env))
        (if (zero? (-- times)) (break/v result)) ))))

(defMacro doTimes ((var times . result) . body)
  (list* 'repeat (list* var times (if (null? result) (cons #inert) result)) body) )
|#


;;; Lists

(def\ (any? f lst . lst*)
  (if (null? lst*)
    ((rec\ (any? lst) (if (null? lst) #f (f (car lst)) #t (any? (cdr lst))) ) lst)
    ((rec\ (any*? lst*) (if (null? (car lst*)) #f (apply f (map car lst*)) #t (any*? (map cdr lst*))) ) (cons lst lst*)) ))

(defMacro (any?* f . lst) (list 'any? f lst))

(def\ (all? f lst . lst*)
  (if (null? lst*)
    ((rec\ (all? lst) (if (null? lst) #t (f (car lst)) (all? (cdr lst)) #f) ) lst)
    ((rec\ (all*? lst*) (if (null? (car lst*)) #t (apply f (map car lst*)) (all*? (map cdr lst*)) #f) ) (cons lst lst*)) ))

(defMacro (all?* f . lst) (list 'all? f lst))

(def\ (forEach# f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect. Return the #inert.
   |#
  (if (null? lst*)
    ((rec\ (forEach lst) (unless (null? lst) (f (car lst)) (forEach (cdr lst)))) lst)
    ((rec\ (forEach* lst*) (unless (null? (car lst*)) (apply f (map car lst*)) (forEach* (map cdr lst*)) )) (cons lst lst*)) ))

(def\ (forEach f lst . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect. Return the list.
   |#
  (if (null? lst*)
    (let1 (res lst) ((rec\ (forEach lst) (if (null? lst) res (else (f (car lst)) (forEach (cdr lst)) ))) res))
    (let1 (res* (cons lst lst*)) ((rec\ (forEach* lst*) (if (null? (car lst*)) res* (else (apply f (map car lst*)) (forEach* (map cdr lst*)) ))) res*) )) )

(def\ maplist (f lst . lst*)
  #|Apply the FUNCTION, which must return a list, to every element of the
   |LIST, and append the results.  (Note: this currently uses `append',
   |but might be changed to use `nconc' in the future, like Common Lisp.)
   |#
  (if (null? lst*)
    ((rec\ (maplist lst) (if (null? lst) #null (append (f (car lst)) (maplist (cdr lst))))) lst)
    ((rec\ (maplist* lst*) (if (null? (car lst*)) #null (append (apply f (map car lst*)) (maplist* (map cdr lst*))))) (cons lst lst*)) ))

(def\ (filter f lst . lst*)
  (if (null? lst*)
    ((rec\ (filter lst) (if (null? lst) #null (if (f (car lst)) (cons (car lst) (filter (cdr lst))) (filter (cdr lst))))) lst)
    ((rec\ (filter* lst*) (if (null? (car lst*)) #null (let1 (cars (map car lst*)) (if (apply f cars) (cons cars (filter* (map cdr lst*))) (filter* (map cdr lst*)) )))) (cons lst lst*)) ))

(defMacro (remove f lst . lst*)
  #|Return a new list from which the elements that satisfy the TEST have been removed.
   |#
  (list* 'filter (list 'compose '! f) lst lst*) )

(def\ (reduceL f init lst . lst*)
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (reduce (f acc (car lst)) (cdr lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (reduce* (apply* f acc (map car lst*)) (map cdr lst*)) )) init (cons lst lst*)) ))

(def reduce
  #|Use the binary FUNCTION to combine the elements of the LIST.  The
   |INITIAL-VALUE is logically placed before the list.
   |#
  reduceL)

(def\ (reduceR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (reduce acc lst) (if (null? lst) acc (f (reduce acc (cdr lst)) (car lst)) )) init lst)
    ((rec\ (reduce* acc lst*) (if (null? (car lst*)) acc (apply* f (reduce* acc (map cdr lst*)) (map cadr lst*)) )) init (cons lst lst*)) ))

(def\ (foldL f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldl acc lst) (if (null? lst) acc (foldl (f (car lst) acc) (cdr lst)) )) init lst)
    ((rec\ (foldl* acc lst*) (if (null? (car lst*)) acc (foldl* (apply* f (map car lst*) acc) (map cdr lst*)) )) init (cons lst lst*)) ))

(def\ (foldR f init lst . lst*)
  (if (null? lst*)
    ((rec\ (foldr acc lst) (if (null? lst) acc (f (car lst) (foldr acc (cdr lst)) ) )) init lst)
    ((rec\ (foldr* acc lst*) (if (null? (car lst*)) acc (apply* f (map car lst*) (foldr* acc (map cdr lst*)) ) )) init (cons lst lst*)) ))

(defMacro dolist ((var listForm . resultForm) . bodyForms)
  #|Cf. Common Lisp's DOLIST.
   |#
  (let1rec\
    (dolist (list body result)
      (if (null? list) (result list)
        (else
          (body (car list))
          (dolist (cdr list) body result) )))
    (list dolist
          listForm
          (list* '\ (list var) bodyForms)
          (list* '\ (list var) resultForm))))

(def\ (make\* n f)
  (def\ (resize n lst)
    (let loop ((n n) (h ()) (t lst))
      (if (null? t) (reverse h)
        (if (<= n 1)
          (reverse (cons (if (null? (cdr t)) (car t) t) h))
          (loop (- n 1) (cons (car t) h) (cdr t)) ))))
  (\ lst (apply f (resize n lst))))


;;; Dynamic Binding

(defMacro (ddef var . val?)
  #|Define a new or update an existing dynamic variable with the given
   |NAME and optDft default VALUE.
   |$(fn (name))
   |$(fn (name value))
   |#
  (list* (list '%d\ (list var)) val?) )

(defMacro (ddef* var* . val*)
  (list* (list '%d\ var*) val*) )

(def\ (dget dvar)
  #|Return the current value of the DYNAMIC-VARIABLE.
   |#
  (dvar))

(def\ (dset dvar value)
  #|Set the current value of the DYNAMIC-VARIABLE.
   |#
  (dvar value))

(defMacro (dlet bindings exp . exps)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established parallely
   |as per `let'.
   |$(syntax binding (dynamicVariable value))
   |#
  (cons (list* '%d\ (map car bindings) exp exps) (map cadr bindings)) )

(defMacro (progv var* val* exp . exps)
  #|Evaluate the FORMS with the list of DYNAMIC-VARIABLES temporarily
   |bound to new VALUES.  The DYNAMIC-VARIABLES and VALUES lists must have
   |the same length.
   |#
  (cons (list* '%d\ var* exp exps) val*) )

(defMacro (dlet* bindings . forms)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established serially as
   |per `let*'.
   |#
  (if (null? bindings)
    (cons 'begin forms)
    (list 'dlet
      (list (car bindings))
      (list* 'dlet* (cdr bindings) forms) )))


;;;; Box

(def newBox %newBox)

(defMacro (defBox name . value?)
  (list 'def name (cons 'newBox value?)) )


;;; Classes

(def\ findClass (name env)
  #|Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT.
   |#
  (eval (the Symbol name) env))

(defVau defClass (name (#! (0 1 Symbol) superClass?) (#! (Symbol) slotSpecs) . properties) env
  #|Define a new `StandardClass' with the given NAME, optional SUPERCLASS?, and SLOT-SPECS.
   |The superclass defaults to `standard-object'.
   |The SLOT-SPECS and PROPERTIES are currently ignored.
   |$(syntax slotSpec symbol)
   |$(syntax property (:documentation docstring))
   |#
  ;; Slot-specs are ignored for now, but check that they are symbols nevertheless.
  (let1 (superClass (findClass (optDft superClass? 'Obj) env))
    (eval (list 'def name (%newClass name superClass)) env)) )


;;; Objects

(def new
  #|Create a new instance of CLASS (that must be a `standard-class').
   |The SLOT-INITS must be of even length, and alternately contain slot
   |names (symbols, typically keywords) and values.
   |$(fn (class . slotInits))
   |#
  %new)

(def\ getSlot (object slotName)
  #|Return the value of the slot named SLOT-NAME of the OBJECT.
   |#
  (%getSlot object slotName))

(def\ setSlot (object slotName value)
  #|Set the value of the slot named SLOT-NAME of the OBJECT to VALUE.
   |#
  (%setSlot object slotName value))

(def\ slotBound? (object slotName)
  #|Return true if the slot named SLOT-NAME of the OBJECT is set, false otherwise.
   |#
  (%slotBound? object slotName))

(defMacro (defObj name class . attr)
  (list 'def name (list* 'new class attr)) )


;;; Generic Functions

;; receiver e parameters dei defMethod dovrebbero corrispondere a quelli del corrispondente defGeneric con quel nome

(defVau (defGeneric . args) env
  #|Define a new generic function with the given NAME.
   |The RECEIVER, PARAMETERS, and PROPERTIES are currently ignored.
   |$(syntax property (:documentation docstring))
   |#
  (if (cons? (car args))
    (def ((name receiver . parameters) . properties) args)
    (def (name (receiver . parameters) . properties) args) )
  (let1\ (generic args ((%getMethod (classOf (car args)) name) args))
    (eval (list 'def name generic) env) ))

(defVau (defMethod . args) env
  #|Add a new method to the generic function named by NAME
   |specialized for the class named by CLASS-NAME.
   |#
  (if (cons? (car args))
    (def ((name (receiver class) . parameters) . forms) args)
    (def (name ((receiver class) . parameters) . forms) args) )
  (def method (\ (args) (apply (eval (list* '\ (cons receiver parameters) forms) (let1 (receiver (car args)) (if (type? receiver Obj) (newEnv env receiver) env)) ) args)))  
  (def prv (%addMethod (eval class env) name method))
  (case (bndRes) ((#inert) #inert) ((:rhs) method) ((:prv) prv)) )


;;; Modules

(defVau (provide symbols . body) env
  (eval
    (list 'def symbols
      (list 'let ()
        (cons 'begin body)
        (cons 'list symbols) ))
    env ))

(defVau (module exports . body) env
  (let1 (env (newEnv env))
    (eval (list* 'provide exports body) env)
    (newEnv env) ))

(defMacro (defModule name exports . body)
  (list 'def name (list* 'module exports body)) )

(defVau (import module imports) env
  (let* ((module (eval module env))
         (values (eval (cons 'list imports) module)) )
    (eval (list* 'def* imports values) env) ))


;;; Relational Operators

;; Note that unlike in Common Lisp, these operators currently require
;; at least two arguments.  This will be improved in the future.

(def\ (relationalOp binop)
  #|Utility to create an n-ary relational operator from a BINARY-OPERATOR.
   |#
  (rec\ (op arg1 arg2 . rest)
    (if (binop arg1 arg2)
      (if (null? rest) #t
        (apply op (cons arg2 rest)))
      #f )))

(def <
  #|Return true if the ARGUMENTS are in monotonically increasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp <) )

(def >
  #|Return true if the ARGUMENTS are in monotonically decreasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp >) )

(def <=
  #|Return true if the ARGUMENTS are in monotonically nondecreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp <=) )

(def >=
  #|Return true if the ARGUMENTS are in monotonically nonincreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp >=) )

(def eq?
  #|Return true if all ARGUMENTS are equal, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp eq?) )

(def ==
  #|Return true if all ARGUMENTS are ==, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp ==))

(def !=
  #|Return true if all ARGUMENTS are ==, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (relationalOp !=))

(def\ /= (arg . args)
  #|Return true if all ARGUMENTS are distinct, false otherwise.
   |$(fn arguments)
   |#
  (if (null? args) #t
    (if (member? arg args :cmp eq?) #f
      (apply /= args) )))

#| TODO in sostituzione del prededente, utile?
(def\ /= args
  (if (null? args) #t
    (let1 ((arg . args) args)
      (if (member? arg args :cmp eq?) #f
        (apply /= args) ))))
|#


;;; Thetic & Lytic

;; The terms thetic (for + and *) and lytic (for - and /) are due to Hankel.

(def\ (theticOp binOp unit)
  #|Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |#
  (\ args (reduce binOp unit args)) )

(def +
  #|Return the sum of the ARGUMENTS, or 0 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp + 0) )

(def *
  #|Return the product of the ARGUMENTS, or 1 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp * 1) )

(def $
  #|Return the join of the ARGUMENTS, or "" if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (theticOp $ "") )

(def\ (lyticOp binOp unit)
  #|Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |#
  (\ (arg1 . rest)
    (if (null? rest)
      (binOp unit arg1)
      (reduce binOp arg1 rest) )))

(def -
  #|If only one number is supplied in the ARGUMENTS, return the
   |negation of that number. If more than one number is supplied, subtract
   |all of the later ones from the first one and return the result.
   |$(fn arguments)
   |$(type function)
   |#
  (lyticOp - 0) )

(def /
  #|If only one number is supplied in the ARGUMENTS, return the
   |reciprocal of that number.  If more than one number is supplied,
   |divide the first one by all of the later ones and return the result.
   |$(fn arguments)
   |$(type function)
   |#
  (lyticOp / 1) )


;;;; Greatest Common Divisor e Lowest Common Multiple

(def\ (gcd a b . more)
  (if (null? more)
    (if (zero? b) a (gcd b (% a b)))
    (gcd a (apply gcd (cons b more))) ))

(def abs (let1 (abs (@getMethod Math "abs" &int)) (\ (n) (abs #null n))))

(def\ (lcm a b . more)
  (if (null? more)
    (if (|| (zero? a) (zero? b)) 0
      (abs (* b (/ a (gcd a b)))) )
    (lcm a (apply lcm (cons b more))) ))


;;; Sequences

(defGeneric length (sequence)
  #|Return the number of elements in a sequence.
   |#
)
(defMethod length ((seq List))
  (%len seq))
(defMethod length ((seq Null))
  (%len seq))


(defGeneric elt (sequence index)
  #|Return the sequence element at the specified index.
   |#
)
(defMethod elt ((seq List) index)
  (nth index seq))
(defMethod elt ((seq String) index)
  (%subString seq index (+ index 1)))


(defGeneric subSeq (sequence start . end)
  #|Create a sequence that is a copy of the subsequence
   |of the SEQUENCE bounded by START and optional END?.  If END?  is not
   |supplied or void, the subsequence stretches until the end of the list
   |#
)
(defMethod subSeq ((seq List) start . end)
  (apply** %subList seq start end))
(defMethod subSeq ((seq Null) start . end)
  (apply** %subList seq start end))
(defMethod subSeq ((seq String) start . end)
  (apply** %subString seq start end))


;;; Coroutines

(defConstant coroutinePrompt
  #|This prompt is used for general coroutine-like use of continuations.
   |#
  'coroutine-prompt)

(defMacro coroutine forms
  #|Evaluate the FORMS in a context in which `yield' can be used to pause execution.
   |#
  (list* 'pushPrompt 'coroutinePrompt forms))

(defMacro yield (name . forms)
  #|Pause the current coroutine.  In the place where the enclosing
   |`coroutine' (or `resume') was called, evaluate the FORMS with NAME
   |bound to the paused coroutine.  `resume' can later be used to restart
   |execution inside the coroutine.
   |#
  (list* 'takeSubcont 'coroutinePrompt name forms))

(defMacro resume (k . forms)
  #|Resume the paused coroutine K and evaluate FORMS in the place where
   |`yield' was called in the coroutine.
   |#
  (list* 'pushDelimSubcont 'coroutinePrompt k forms))


;;; Fibers

;; The following implementation of fibers follows the one at URL
;; `http://okmij.org/ftp/continuations/implementations.html#dget-wind'
;;
;; We're calling them fibers instead of coroutines so as to not
;; conflict with the built-in coroutine operators.
;;
;; We use it for testing that built-in operators properly suspend and
;; resume.

(defConstant fiberPrompt
  #|The prompt used for delimiting fibers.
   |#
  'fiber-prompt)

(defClass YieldRecord ()
  #|Instances of this class are yielded.
   |#
  (value continuation) )

(def\ makeYieldRecord (v k)
  #|Create a new yield record with the given yielded value and resume continuation.
   |#
  (new YieldRecord :value v :continuation k))

(def\ fiberYield v?
  #|Yield a value (which defaults to void).
   |#
  (takeSubcont fiberPrompt k
    (makeYieldRecord (optDft v? #inert) k)))

(def\ fiberResume (yieldRecord . v?)
  #|Resume a suspended fiber with a value (which defaults to void).
   |#
  (pushDelimSubcont fiberPrompt (yieldRecord 'continuation)
    (optDft v? #inert)))

(defMacro fiber body
  #|Evaluate the body expressions as a fiber.
   |#
  (list* pushPrompt 'fiberPrompt body))

(def\ runFiber* (thunk . values)
  #|Get all values yielded by a fiber, and its final result, and collect them in a list.
   |Uses the optional list of values to sent to the fiber with `fiberResume'.
   |#
  (let run ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
      (cons (result 'value)
        (if (null? values)
          (run (fiberResume result) #null)
          (run (fiberResume result (car values)) (cdr values)) ))
      (list result) )))

(defMacro (runFiberWithValues f args) (list 'eval (list 'list* 'runFiber* f args))) 
(defMacro (runFiberWithValues f args) (list 'apply 'runFiber* (list 'cons f args))) 
(defMacro (runFiberWithValues f args) (list 'apply** 'runFiber* f args)) 

(def runFiber runFiber*)


;;;; Auto Increment/Decrement and Assignement Operator

(defVau (++ plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (+ (val) 1))))
    (Obj    (let1 ((fld) args) (val :rhs fld (+ (val fld) 1))))
    (Number (let1 (() args) (eval (list 'set! plc :rhs (+ val 1)) env)))
    (else   (error ($ "not valid type: " val))) ))

(defVau (-- plc . args) env
  (def val (eval plc env))
  (caseType val
    (Box    (let1 (() args) (val :rhs (- (val) 1))))
    (Obj    (let1 ((fld) args) (val :rhs fld (- (val fld) 1))))
    (Number (let1 (() args) (eval (list 'set! plc :rhs (- val 1)) env)))
    (else   (error ($ "not valid type: " val))) ))

(def\ (assignOp op)
  (vau (plc . args) env
    (def lval (eval plc env))
    (caseType lval
      (Box (match args
        ((rval) (lval (op (lval) (eval rval env))))
        ((key rval) (lval key (op (lval) (eval rval env)))) ))
      (Obj (match args
        ((fld rval) (lval fld (op (lval fld) (eval rval env))))
        ((key fld rval) (lval key fld (op (lval fld) (eval rval env)))) ))
      (Object (match args
        ((rval) (eval (list 'def plc (op lval (eval rval env))) env))
        ((key rval) (eval (list 'set! plc key (op lval (eval rval env))) env)) )))))

(def $= (assignOp %$))
(def += (assignOp %+))
(def -= (assignOp %-))


;;;; Arrays

(def\ (array . args) (list->array args))

(def Object[] &java.lang.Object[])

(def\ (arrayMap fun (#! Object[] arr))
  (list->array (map fun (array->list #t arr))) )

(def\ (arrayFilter pred (#! Object[] arr))
  (list->array (filter pred (array->list #t arr))) )

(def\ (newInstance class dim . dims)
  (apply** @newInstance &java.lang.reflect.Array class dim dims))

(def\ (arrayGet array index)
  (if (cons? index)
    (apply** arrayGet* array index)
    (@get &java.lang.reflect.Array array index) ))

(def\ (arrayGet* array . indexes)
  (let loop ((array array) (indexes indexes))
    (if (null? indexes) array
      (loop (arrayGet array (car indexes)) (cdr indexes)) )))  

(def\ (arraySet array index value)
  (if (cons? index)
    (apply** arraySet* array value index)
    (else
      (@set &java.lang.reflect.Array array index value)
      array )))

(def\ (arraySet* array0 value . indexes)
  (if (null? indexes) array
    (let loop ((array array0) (indexes indexes))
       (if (null? (cdr indexes))
         (then (arraySet array (car indexes) value) array0)
         (loop (arrayGet array (car indexes)) (cdr indexes)) ))))  


;;;; Simple Set

;(def set? /=) ; TODO solo se (/=) -> #t

(def\ (set? lst) (if (null? lst) #t (apply /= lst)))

(def\ (set+ v lst)
  (if (member? v lst) lst (cons v lst)))
  
(defVau (defSet+ (#! Symbol plc) v) env
  (let ( (v (eval v env)) (lst (env plc)) )
    (if (member? v lst) lst (env :def :rhs plc (cons v lst))) ))

(def\ ->set (lst)
  (let loop ( (res ()) (lst lst) )
    (if (null? lst) (reverse res)
      (let1 ((v . lst) lst)
        (loop (if (member? v res) res (cons v res)) lst) ))))

#| TODO da valutare
(def\ ->set (lst)
  (let1 loop (res ())
    (if (null? lst) (reverse res)
      (let1 (v (car lst))
        (set! lst (cdr lst)) 
        (loop (if (member? v res) res (cons v res))) ))))
|#


;;;; Java Try/Resource

(defMacro (close1 binding . body)
  (list 'let1 binding
    (list* 'atEnd
      (list '@close (car binding))
      body )))

(defMacro (close bindings . body)
  (list 'let bindings
    (list* 'atEnd
      (list 'forEach '@close (cons 'list (map car bindings)))
      body )))


;;;; Utility

(defVau (time times . forms) env
  (let* ( (currentTime (@getMethod System "currentTimeMillis"))
          ((#! (and Integer (> 0)) times) (eval times env))
          (milli (currentTime #null))
          (result (apply repeat (cons times forms) env))
          (milli (- (currentTime #null) milli)) )
    (print "time " times " " forms ": " milli "ms" (if (== times 1) "" ($ ", on average: " (@format String "%.2f" (/ milli (@doubleValue times))) "ms" )))
    result ))
