;;;                                                     -*- Lisp -*-
;;; LispX Bootstrap
;;;

;; Copyright (c) 2021, 2022 Manuel J. Simoni


;;; Built-Ins

(%def def
  #|Match the DEFINIEND-TREE against the VALUE and place resulting
   |bindings into the current environment.  The optional DOCSTRING? is
   |currently ignored.
   |$(fn (definiendTree value))
   |$(type fexpr)
   |#
  %def)

(def begin
  #|Sequentially evaluate FORMS, returning the value of the last one, or void if there are no forms.
   |$(fn forms)
   |$(type fexpr)
   |#
  %begin)

(def if
  #|Evaluate the TEST which must yield a boolean.  Then evaluate either
   |the CONSEQUENT or ALTERNATIVE depending on whether the TEST yielded
   |true or false.
   |$(fn (test consequent . alternative))
   |$(type fexpr)
   |#
  %if)

(def !
  #|Invert the BOOLEAN.
   |$(fn (boolean))
   |$(type function)
   |$(derivation (if boolean #f #t))
   |#
  %!)
  
(def not !)

(def loop
  #|Evaluate the FORMS in an infinite loop.
   |$(fn forms)
   |$(type fexpr)
   |#
  %loop)

(def ==
  #|Return true if the values A and B are pointer-identical, false otherwise.
   |$(fn (a b))
   |$(type function)
   |#
  %==)

(def classOf
  #|Return the class of the OBJECT.
   |$(fn (object))
   |$(type function)
   |#
  %classOf)

(def type?
  #|Return true if the OBJECT is an instance of the CLASS, false otherwise.
   |$(fn (object class))
   |$(type function)
   |#
  %type?)

(def instanceOf? %instanceOf?)

(def intern
  #|Get or create the unique symbol with STRING as name.
   |$(fn (string))
   |$(type function)
   |#
  %intern)

(def symbol? %symbol?)

(def symbolName
  #|Return the name of the SYMBOL as a string.
   |$(fn (symbol))
   |$(type function)
   |#
  %symbolName)

(def variableSymbol
  #|Return the symbol with the same name as SYMBOL, but in the variable namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %variableSymbol)

(def functionSymbol
  #|Return the symbol with the same name as SYMBOL, but in the function namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %functionSymbol)

(def classSymbol
  #|Return the symbol with the same name as SYMBOL, but in the class namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %classSymbol)

(def keywordSymbol
  #|Return the symbol with the same name as SYMBOL, but in the keyword namespace.
   |$(fn (symbol))
   |$(type function)
   |#
  %keywordSymbol)

(def cons
  #|Create a cons with the given CAR and CDR.
   |$(fn (car cdr))
   |$(type function)
   |#
  %cons)

(def car
  #|Return the contents of the address part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %car)

(def cdr
  #|Return the contents of the decrement part of the register.
   |$(fn (cons))
   |$(type function)
   |#
  %cdr)

(def cadr %cadr)
(def cddr %cddr)

(def list*
  #|Create a list from the ARGUMENTS so that the last argument becomes
   |the `cdr' of the list.
   |$(fn arguments)
   |$(type function)
   |#
  %list*)

(def reverse
  #|Reverse the LIST.
   |$(fn (list))
   |$(type function)
   |#
  %reverse)

(def wrap
  #|Create a new function that wraps around an underlying OPERATOR, and
   |induces argument evaluation around it.
   |$(fn (operator))
   |$(type function)
   |#
  %wrap)

(def unwrap
  #|Return the underlying operator of a FUNCTION.
   |$(fn (function))
   |$(type function)
   |#
  %unwrap)

(def eval
  #|Evaluate the FORM in the ENVIRONMENT, returning its result.
   |$(fn (form environment))
   |$(type function)
   |#
  %eval)

(def makeEnv
  #|Create a new environment with an optional PARENT-ENVIRONMENT? in
   |which bindings are looked up if they are not found.
   |$(fn parentEnvironment?)
   |$(type function)
   |#
  %makeEnv)

(def bound?
  #|Return true if the SYMBOL is bound in the ENVIRONMENT, false otherwise.
   |$(fn (symbol environment))
   |$(type function)
   |#
  %bound?)

(def panic
  #|Mostly for internal use.  Signal the ERROR in such a way that it is
   |hard to handle and will usually escape the VM as a host language
   |exception.  In particular, signal handlers will not be invoked.
   |However, intervening `finally' cleanup expressions and `progv'
   |expressions are still triggered, so Lisp invariants are maintained.
   |$(fn (error))
   |$(type function)
   |#
  %panic)


;;; Core Forms

(def vau
  #|Construct a fexpr with the given PARAMETER-TREE, ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (parameterTree environmentParameter . forms))
   |$(type fexpr)
   |$(derivation (vau (pt ep . forms) env (eval (list 'vau pt ep (list* 'begin forms)) env)))
   |#
  %vau)

(def list
  #|Return the list of evaluated ARGUMENTS.
   |$(fn arguments)
   |$(type function)
   |$(derivation (wrap (vau arguments #ignore arguments))
   |#
  %list) 

(def quote
  #|Return the unevaluated OPERAND.
   |$(fn (operand))
   |$(type fexpr)
   |$(derivation (vau (operand) #ignore operand))
   |#
  %quote)

(def theEnv
  #|Return the current environment.
   |$(fn parent?)
   |$(type fexpr)
   |$(derivation (vau () environment environment)))
   |#
  %theEnv)

(def evalMacro (%dVar #t))

(def lispx::makeMacro
  #|Create a macro from an EXPANDER operator.  A macro is an operator
   |that receives an operand and produces a form (by calling the expander
   |with the operand as argument) that is then evaluated in place of the
   |operand.
   |$(fn (expander))
   |$(type function)
   |#
  (wrap
    (vau (expander) #ignore
      (vau operands env
        (def !evalMacro (%! (evalMacro)))
        (if !evalMacro (evalMacro #t))
        (def exp (eval (cons expander operands) (makeEnv)))
        (if !evalMacro exp (eval exp env)) ))))

(def macro
  #|Create an anonymous macro with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type macro)
   |#
  (lispx::makeMacro
   (vau (parameterTree . forms) #ignore
     (list 'lispx::makeMacro (list* 'vau parameterTree #ignore forms)) )))


; defMacro defVau def\ def*\ rec\ let1\ let1rec\ let\ letrec\ permettono la definizione con due sintassi
;
;    (_ name parameters . body)
;    (_ (name . parameters) . body)
;
; rec rec\ let1rec let1rec\ letrec letrec\ inizializzano a #inert le definizioni prima della valutazione

(def defMacro
  #|Define a macro with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (macro (lhs . rhs)
    (if (symbol? lhs)
      (list 'def lhs (list* 'macro (car rhs) (cdr rhs)))
      (list 'def (car lhs) (list* 'macro (cdr lhs) rhs)) )))

(defMacro expand (macro)
  (list 'begin (list 'evalMacro #f) macro) )

(defMacro defVau (lhs . rhs)
  #|Define a fexpr with the given NAME, PARAMETER-TREE,
   |ENVIRONMENT-PARAMETER, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (symbol? lhs)
    (list 'def lhs (list* 'vau (car rhs) (cadr rhs) (cddr rhs)))
    (list 'def (car lhs) (list* 'vau (cdr lhs) (car rhs) (cdr rhs))) ))

(defMacro defConstant (name value . docstring?)
  #|Define a constant with the given NAME and VALUE.  This is mostly
   |for documentation purposes, as constants are still mutable.
   |#
  (list 'def name value) )

(defMacro (wrau pt ep . body)
  (list 'wrap (list* 'vau pt ep body)))

(defMacro (def* lhs . rhs)
  (list 'def lhs (list* 'list rhs)) )

(def \
  #|Create an anonymous function with the given PARAMETER-TREE and FORMS.
   |$(fn (parameterTree . forms))
   |$(type function)
   |$(derivation (wrap (vau parameterTree #ignore forms)))
   |#
  %\ )

(defMacro def\ (name parameterTree . forms)
  #|Define a function with the given NAME, PARAMETER-TREE, and FORMS.
   |#
  (list 'def name (list* '\ parameterTree forms)) )

(defMacro (def\ lhs . rhs)
  #|Define a function with the given NAME, PARAMETER-TREE, and FORMS.
   |$(fn (name parameterTree . forms))
   |$(fn ((name parameterTree) . forms))
   |$(type macro)
   |#
  (if (symbol? lhs)
    (list 'def lhs (list* '\ (car rhs) (cdr rhs)))
    (list 'def (car lhs) (list* '\ (cdr lhs) rhs)) ))


;;; Others Built-in 

(defMacro catch (tag . forms)
  #|Establish a catch tag and evaluate FORMS as an implicit `begin'
   |inside it.  The forms may use `throw' to nonlocally exit from the
   |tag.  Usually, `block' should be preferred.
   |#
  (list '%catch tag (list* '\ () forms)))

(def\ throw (tag . result?)
  #|Abort to a nesting catch tag established by `catch' and pass the
   |optional RESULT? (defaults to void) to it.
   |#
  (%throw tag (opt? result?)))

(def\ invokeDebugger (condition)
  #|Invoke the debugger, which as a default just prints a stack trace
   |and panics, thereby throwing an exception to JS.  When running in the
   |REPL, this function gets replaced with a different one that runs a
   |nested debug loop.
   |#
  (takeSubcont +rootPrompt+ k
    (pushDelimSubcont +rootPrompt+ k
      (%printStacktrace k)
      (panic condition))))


;;; Basic macros and functions

(def\ (apply appv args . env)
  #|Call the FUNCTION with a dynamically-supplied list of ARGUMENTS.
   |$(type function)
   |#
  (def env (if (null? env) (makeEnv) ((\ ((env)) env) env))) 
  (if (%jFun? appv)
    (@combine (@new JFun vm appv) env args)
    (eval (cons (unwrap appv) args) env) ))

(defMacro (rec lhs . rhs)
  (list (list '\ () (list 'def lhs #inert) (list* 'def lhs :rhs rhs))) )

(defMacro (rec\ lhs . rhs)
  (if (symbol? lhs)
    (list 'rec lhs (list* '\ (car rhs) (cdr rhs)))
    (list 'rec (car lhs) (list* '\ (cdr lhs) rhs)) )) 

(def\ (map f . lst*)
  #|Create a new list by applying the FUNCTION to every element of the LIST.
   |#
  (if (null? lst*) (sympleError "none lists"))
  (if (null? (cdr lst*))
    ((rec\ (map lst) (if (null? lst) #null (cons (f (car lst)) (map (cdr lst))) )) (car lst*))
    ((rec\ (map* lst*) (if (null? (car lst*)) #null (cons (apply f (map car lst*)) (map* (map cdr lst*))) )) lst*) ))

(defMacro (def*\ lhs* . rhs*)
  (list* 'def*
    (map (\ (lhs) (if (symbol? lhs) lhs (car lhs))) lhs*)
    (map (\ (lhs rhs) (if (symbol? lhs) (list* '\ (car rhs) (cdr rhs)) (list* '\ (cdr lhs) rhs))) lhs* rhs*) )) 


;;; Lexical Bindings

(def\ (->inert binding) #inert)
(def\ (->1expr binding) ((\ ((#_ cadr)) cadr) binding))
(def\ (->begin binding) ((\ ((#_ cadr . exps)) (if (null? exps) cadr (list* 'begin cadr exps))) binding))
(def\ (->name\ (lhs . rhs)) (if (symbol? lhs) (list lhs (list* '\ (car rhs) (cdr rhs))) (list (car lhs) (list* '\ (cdr lhs) rhs))))
(def\ (->name binding) (if (symbol? binding) binding (car binding)))


(defMacro (let1Loop . args)
  (if (symbol? (car args))
    (def (name binding . body) args)
    (def ((name . binding) . body) args))
  (list
    (list* 'rec\ name (list (car binding)) body)
    (->1expr binding) ))

(defMacro (let1 lhs . rhs)
  (if (symbol? lhs)
    (list* 'let1Loop lhs (car rhs) (cdr rhs))
    (list (list* '\ (list (car lhs)) rhs)
      (->1expr lhs) )))

(defMacro (let1\ binding . body)
  (list* 'let1 (->name\ binding) body))

(defMacro (let1rec binding . body)
  (list* 'let ()
    (list 'def (car binding) (->inert binding))
    (list 'def (car binding) (->1expr binding))
    body ))

(defMacro (let1rec\ binding . body)
  (list* 'let ()
    (list 'def (->name (car binding)) #inert)
    (list* 'def\ (car binding) (cdr binding))
    body ))


(defMacro (letLoop . args)
  #|Labelled recursive loop, analogous to Scheme's named `let'.
   |Lexically bind a function named NAME with one PARAMETER for every
   |INITIALIZER and the FORMS as body.  Then immediately apply the
   |function to a list containing one VALUE for every INITIALIZER and
   |return the result.  The function is bound per `labels' so it can
   |recursively refer to itself.
   |$(fn (initializers . body))
   |$(fn (name initializers . body))
   |$(syntax initializers ((parameter value) . initializers)
   |#
  (if (symbol? (car args))
    (def (name bindings . body) args)
    (def ((name . bindings) . body) args))
  (list*
    (list* 'rec\ name (map car bindings) body)
    (map ->1expr bindings) ))

(defMacro (let lhs . rhs)
  #|Establish BINDINGS parallelly during the evaluation of FORMS, so
   |that no binding can refer to the other ones.
   |$(fn (bindings . body))
   |$(fn (name bindings . body))
   |$(syntax bindings ((parameter value) . bindings)
   |#
  (if (symbol? lhs)
    (list* 'letLoop lhs rhs)
    (list* (list* '\ (map car lhs) rhs)
      (map ->1expr lhs) )))

(defMacro (let\ bindings . body)
  #|Establish FUNCTION-BINDINGS parallelly during evaluation of FORMS,
   |so that no function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  (list* 'let (map ->name\ bindings) body))

(defMacro (letrec bindings . body)
  #|Utility to establish BINDINGS recursively during the evaluation of
   |FORMS.  Used by `labels'.
   |#
  (list* 'let ()
    (list* 'def* (map car bindings) (map ->inert bindings))
    (list* 'def* (map car bindings) (map ->1expr bindings))
    body ))

(defMacro (letrec\ bindings . body)
  (list* 'let ()
    (list* 'def* (map (\ (binding) (->name (car binding))) bindings) (map ->inert bindings))
    (list* 'def*\ (map car bindings) (map cdr bindings))
    body ))

(def labels
  #|Establish FUNCTION-BINDINGS recursively during evaluation of FORMS,
   |so that every function can refer to the other ones.
   |$(syntax functionBinding (name parameterTree . forms))
   |#
  letrec\)


(defMacro (let* bindings . body)
  #|Establish BINDINGS serially during the evaluation of FORMS, so that
   |every binding can refer to previous ones.
   |$(syntax bindings ((definiendTree value) . bindings))
   |#
  (if (null? bindings)
      (list* 'let () body)
      (list 'let
        (list (car bindings))
        (list* 'let* (cdr bindings) body) )))


;;;; Simple control

(defMacro (when test . body)
  #|If TEST yields true, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list 'if test (list* 'begin body)))

(defMacro (unless test . body)
  #|If TEST yields false, evaluate the FORMS as an implicit `begin'. Otherwise, return inert.
   |#
  (list* 'if test #inert body))


;;;; Bind? IfBind? CaseVau Case\ Match

(def bind? %bind?)

(defVau (ifBind? (pt exp) then . else) env
  (let1 (env+ (makeEnv env))
    (if (bind? env+ pt (eval exp env))
      (eval then env+)
      (unless (null? else)
        (eval (let1 ((exp) else) exp) env) ))))

(defVau (caseVau . clauses) env 
  (vau values #ignore
    (let1 loop (clauses clauses)
      (if (null? clauses) #inert
        (let ( (env+ (makeEnv env))
               (((bindings . forms) . clauses) clauses) )
          (if (if (== bindings 'else) #t (bind? env+ bindings values)) ; or!
            (eval (list* 'begin forms) env+)
            (loop clauses) ))))))
            
(defMacro (case\ . clauses)
  (list 'wrap (list* 'caseVau clauses)) )

(defMacro (match exp . clauses)
  (list (list* 'case\ (map (\ ((a . b)) (list* (if (== a 'else) a (list a)) b)) clauses)) exp) )  


;;; Data and Control Flow

(defVau cond clauses env
  #|Multi-armed conditional.
   |Go through the CLAUSES in order.  Evaluate the TEST.  If it yields
   |true, evaluate the FORMS as an implicit `begin'.  If it yields false,
   |go to the next clause, or return void if there are no more clauses.
   |$(syntax clause (test . forms))
   |#
  (unless (null? clauses)
    (let ((((test . forms) . restClauses) clauses))
      (if (eval test env)
          (eval (cons begin forms) env)
          (eval (cons cond restClauses) env)))))

(defVau (cond . clauses) env
  #|Multi-armed conditional.
   |Go through the CLAUSES in order.  Evaluate the TEST.
   |If it yields true, evaluate the FORMS as an implicit `begin'.
   |If it yields false, go to the next clause,
   |or return void if there are no more clauses.
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (test->bool . forms))
   |$(syntax clause (test))
   |$(syntax clause (test => apv1))
   |$(syntax clause (test guard => apv1))
   |#
  (unless (null? clauses)
    (let1 (((test . body) . clauses) clauses)
      (if (== test 'else)
        (apply (wrap begin) body env)
        (let1 (test (eval test env))
          (if (instanceOf? test Boolean)
            (if test
              (apply (wrap begin) body env)
              (apply (wrap cond) clauses env) )
            (match body
              (() test)
              (('=> apv1) ((eval apv1 env) test))
              ((guard '=> apv1)
                 (if ((eval guard env) test)
                   ((eval apv1 env) test)
                   (apply (wrap cond) clauses env) ))
              (else (apply (wrap cond) clauses env)) )))))))

(defVau and operands env
  #|Return true if all OPERANDS evaluate to true, false otherwise.  If
   |an operand evaluates to false, later operands are not evaluated.  If
   |there are no operands, return false.
   |#
  (cond ((null? operands)           #t)
        ((null? (cdr operands))     (the Boolean (eval (car operands) env)))
        ((eval (car operands) env) (eval (cons and (cdr operands)) env))
        (#t                        #f)))

(def && and)

(defVau or operands env
  #|Return true if one of the OPERANDS evaluates to true, false
   |otherwise.  If an operand evaluates to true, later operands are not
   |evaluated.  If there are no operands, return true.
   |#
  (cond ((null? operands)           #f)
        ((null? (cdr operands))     (the Boolean (eval (car operands) env)))
        ((eval (car operands) env) #t)
        (#t                        (eval (cons or (cdr operands)) env))))

(def || or)

(defVau while (testForm . forms) env
  #|Evaluate FORMS while TEST-FORM evaluates to true.
   |#
  (let ((forms (list* 'begin forms)))
    (block exit
      (loop
        (if (eval testForm env)
            (eval forms env)
            (returnFrom exit))))))

(defMacro until (testForm . forms)
  #|Evaluate FORMS until TEST-FORM evaluates to true.
   |#
  (list* while (list 'not testForm) forms))

(defMacro dotimes ((var countForm . resultForm?) . bodyForms)
  #|Cf. Common Lisp's DOTIMES.
   |#
  (let\ ((_dotimes_ (n body result)
           (let ((i (box 0)))
             (while (< (i) n)
               (body (i))
               (i (+ (i) 1)))
             (result (i)))))
    (list _dotimes_
          countForm
          (list* '\ (list var) bodyForms)
          (list* '\ (list var) resultForm?))))

(defVau block (blockName . forms) env
  #|Establish a block named BLOCK-NAME and evaluate the FORMS as an
   |implicit `begin' inside it.  The forms may use `returnFrom' to
   |nonlocally exit from the block.
   |Note that unlike in Common Lisp, there is no separate namespace for
   |block names; a block is named in the normal variable namespace.
   |#
  (let1 (tag (list #inert)) ; cons up a fresh object as tag
    (let1\ (escape (value) (throw tag value))
      (catch tag
        (eval (list (list* '\ (list blockName) forms) escape)
              env)))))
#|
(defVau block (blockName . forms) env
  (def tag (list #inert)) ; cons up a fresh object as tag
  (def\ (escape value) (throw tag value))
  (catch tag
    (eval (list (list* '\ (list blockName) forms) escape)
          env )))
|#

(def\ returnFrom (blockName . value?)
  #|Abort evaluation and return the optional VALUE? (which defaults to
   |void) from the block named BLOCK-NAME.  It is an error to return from
   |a block whose dynamic extent has ended.
   |$(fn (blockName . value?))
   |#
  (blockName (opt? value?)))

(def finally
  #|valuate the PROTECTED-FORM and return its result.  Regardless of
   |whether the protected form returns normally, or via a nonlocal exit or
   |panic, the CLEANUP-FORMS are evaluated after the protected form.
   |$(fn (protectedForm . cleanupForms))
   |#
  %finally)

(defVau prog1 (form . forms) env
  #|Evaluate FORM and any additional FORMS, and return the result of FORM.
   |#
  (let1 (result (eval form env))
    (eval (list* begin forms) env)
    result))

; vedi signalsError in vm.lispx o test-util per codice simile
(def\ (checkSlots obj slots)
  (let1 next (slots slots)
    (if (null? slots) #t
      (let1 ((name value . slots) slots)
        (if (or (! (@isBound obj name)) (! (eq? (obj name) value))) #f
          (next slots) )))))

(defVau (caseType key . clauses) env
  #|Multi-armed type test.
   |Evaluate the KEYFORM.  Go through the CLAUSES.  If the result of
   |evaluating KEYFORM is an instance of the class named by CLASS-NAME,
   |evaluate the FORMS as an implicit `begin'.  Otherwise go to the next
   |clause, or return void if there are no more clauses.
   |$(fn (key . clauses))
   |$(type fexpr)
   |$(syntax clauses (clause . clauses))
   |$(syntax clause (className . forms))
   |$(syntax clause ((className . slotSpecs) . forms))
   |#
  (let1 (key (eval key env))
    (let1 next (clauses clauses)
      (if (null? clauses) #inert
        (let1 (((test . forms) . clauses) clauses)
          (if (|| (== test 'else)
                  (let* ( (symbol? (%symbol? test))
                          (class (eval (if symbol? test (car test)) env)) )
                    (&& (type? key class) (|| symbol? (&& (type? key Obj) (checkSlots key (map (\ (x) (eval x env)) (cdr test))) ))) ))
            (if (== (car forms) '=>)
              (let1 ((apv) (cdr forms)) ((eval apv env) key))  
              (eval (list* 'begin forms) env) )
            (next clauses) ))))))

(defVau set (environment definiendTree value) dynamicEnvironment
  #|Match the DEFINIEND-TREE against the VALUE in the ENVIRONMENT,
   |creating or updating existing bindings.  Unlike Common Lisp (or
   |Scheme), we have no `setq' (or `set!') that allows updating arbitrary
   |bindings -- you always need to know the environment a binding is in to
   |change it.  Therefore, we usually use boxes (see below) instead of
   |mutating bindings directly.
   |#
  (eval (list 'def definiendTree (list (unwrap eval) value dynamicEnvironment))
        (eval environment dynamicEnvironment)))

(def box
  #|Create a new box with the optional INITIAL-VALUE?.  A box is a
   |function that encapsulates a mutable value.  Calling the box without
   |arguments returns the value.  Calling the box with an argument sets
   |the value.
   |$(fn initialValue?)
   |$(type function)
   |#
  %box)

(def\ assert (boolean)
  #|Signal an error if the BOOLEAN is false.  Otherwise return void.
   |#
  (unless boolean (error (makeInstance AssertionError :type 'assertion :datum boolean :expectedType #t))))

(def\ compose (f g)
  #|Compose two functions, creating a new function equivalent to (G (F ...)).
   |#
  (\ args (g (apply f args))))

(def\ identity (x)
  #|Identity function.
   |#
  x)


;;; Lists

(def null?
  #|Return true if the OBJECT is nil, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
 %null?)

(def cons?
  #|Return true if the OBJECT is a cons, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %cons?)

(def list?
  #|Return true if the OBJECT is a list, false otherwise.
   |$(fn (object))
   |$(type function)
   |#
  %list?)

(def\ caar (cons)
  #|Return the `car' of the `car' of the CONS.|#
  (car (car cons)))

(def\ cadr (cons)
  #|Return the `car' of the `cdr' of the CONS.|#
  (car (cdr cons)))

(def\ cdar (cons)
  #|Return the `cdr' of the `car' of the CONS.|#
  (cdr (car cons)))

(def\ cddr (cons)
  #|Return the `cdr' of the `cdr' of the CONS.|#
  (cdr (cdr cons)))

(def append
  #|Append two lists.  The first one must be proper and is copied.  The
   |second one is not copied (and doesn't even have to be a list). It
   |becomes the `cdr' of the final cons of the first list, or is returned
   |directly if the first list is empty.
   |$(fn (list1 list2))
   |$(type function)
   |#
  %append)

(def nth
  #|Return element number N of LIST, where the `car' is element zero.
   |$(fn (n list))
   |$(type function)
   |#
  %nth)

(def nthCdr
  #|Returns the tail of LIST that would be obtained by calling `cdr' N times in succession.
   |$(fn (n list))
   |$(type function)
   |#
  %nthCdr)

(def\ (forEach f . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect.  Return the #inert.|#
  (if (null? lst*) (%error "none lists"))
  (if (null? (cdr lst*))
    ((rec\ (forEach lst) (unless (null? lst) (f (car lst)) (forEach (cdr lst)))) (car lst*))
    ((rec\ (forEach* lst*) (unless (null? (car lst*)) (apply f (map car lst*)) (forEach* (map cdr lst*)) )) lst*) ))

(def\ (forEach f . lst*)
  #|Apply the FUNCTION to every element of the LIST for effect.  Return the list.|#
  (if (null? lst*) (error (makeSimpleError "none lists")))
  (if (null? (cdr lst*))
    ((rec\ (forEach lst) (if (null? lst) (car lst*) (f (car lst)) (forEach (cdr lst)))) (car lst*))
    ((rec\ (forEach* lst*) (if (null? (car lst*)) lst* (apply f (map car lst*)) (forEach* (map cdr lst*)) )) lst*) ))

(def\ mapcan (function list)
  #|Apply the FUNCTION, which must return a list, to every element of the
   |LIST, and append the results.  (Note: this currently uses `append',
   |but might be changed to use `nconc' in the future, like Common Lisp.)
   |#
  (if (null? list) #null
      (append (function (car list)) (mapcan function (cdr list))) ))

(defMacro dolist ((var listForm . resultForm?) . bodyForms)
  #|Cf. Common Lisp's DOLIST.|#
  (let1rec\ (_dolist_ (list body result)
             (if (null? list)
                 (result list)
                 (begin
                   (body (car list))
                   (_dolist_ (cdr list) body result))))
    (list _dolist_
          listForm
          (list* '\ (list var) bodyForms)
          (list* '\ (list var) resultForm?))))

(def\ reduce (function list :initialValue initialValue)
  #|Use the binary FUNCTION to combine the elements of the LIST.  The
   |INITIAL-VALUE is logically placed before the list.
   |#
  (if (null? list) initialValue
      (reduce function (cdr list) :initialValue (function initialValue (car list)))))

(def\ member (item list . keywords)
  #|Search for ITEM in the LIST according to the TEST predicate
   |(defaults to `==').  Return the tail of the list starting with
   |ITEM if found, nil otherwise.  The KEY function is applied to
   |each list element before comparison (defaults to `identity').
   |$(fn (item list &key test key))
   |#
  (let ( (test (opt? (get? keywords :test) ==))
         (key  (opt? (get? keywords :key) identity)) )
    (letLoop -member- ((items list))
      (if (null? items) #null
        (if (test item (key (car items))) items
          (-member- (cdr items)))))))

(def\ removeIf (test list)
  #|Return a new list from which the elements that satisfy the TEST have been removed.|#
  (if (null? list) #null
    (if (test (car list))
      (removeIf test (cdr list))
      (cons (car list) (removeIf test (cdr list))))))

(def\ get? (plist indicator)
  #|Search for the INDICATOR keyword in the property list PLIST (a list
   |of alternating keywords and values) and return the found value as an
   |option.
   |#
  (if (null? plist) #null
    (let1 ((i v . plist) plist)
      (if (eq? i indicator)
        (some v)
        (get? plist indicator) ))))


;;; Relational Operators

;; Note that unlike in Common Lisp, these operators currently require
;; at least two arguments.  This will be improved in the future.

(def\ (lispx::makeRelationalOperator binop)
  #|Utility to create an n-ary relational operator from a BINARY-OPERATOR.|#
  (rec\ (op arg1 arg2 . rest)
    (if (binop arg1 arg2)
      (if (null? rest) #t
        (apply op (list* arg2 rest)))
      #f )))

(def eq?
  #|Return true if all ARGUMENTS are equal, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeRelationalOperator %eq?) )

(def <
  #|Return true if the ARGUMENTS are in monotonically increasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeRelationalOperator %<) )

(def >
  #|Return true if the ARGUMENTS are in monotonically decreasing order,
   |false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeRelationalOperator %>) )

(def <=
  #|Return true if the ARGUMENTS are in monotonically nondecreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeRelationalOperator %<=) )

(def >=
  #|Return true if the ARGUMENTS are in monotonically nonincreasing
   |order, false otherwise.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeRelationalOperator %>=) )

(def\ /= (arg . args)
  #|Return true if no two ARGUMENTS are the same, false otherwise.
   |$(fn arguments)
   |#
  (if (null? args) #t
    (if (cons? (member arg args :test eq?)) #f
      (apply /= args) )))


;;; Numbers

;; The terms thetic (for + and *) and lytic (for - and /) are due to Hankel.

(def\ lispx::makeTheticOperator (binaryOperator initialValue)
  #|Utility to create an n-ary thetic operator from a BINARY-OPERATOR and INITIAL-VALUE.|#
  (\ args (reduce binaryOperator args :initialValue initialValue)))

(def +
  #|Return the sum of the ARGUMENTS, or 0 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeTheticOperator %+ 0) )

(def *
  #|Return the product of the ARGUMENTS, or 1 if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeTheticOperator %* 1) )

(def $
  #|Return the join of the ARGUMENTS, or "" if no arguments are supplied.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeTheticOperator %$ "") )

(def\ lispx::makeLyticOperator (binaryOperator initialValue)
  #|Utility to create an n-ary lytic operator from a BINARY-OPERATOR and INITIAL-VALUE.
   |#
  (\ (arg1 . rest)
    (if (null? rest)
      (binaryOperator initialValue arg1)
      (reduce binaryOperator rest :initialValue arg1) )))

(def -
  #|If only one number is supplied in the ARGUMENTS, return the
   |negation of that number. If more than one number is supplied, subtract
   |all of the later ones from the first one and return the result.
   |$(fn arguments)
   |$(type function)
   |#
  (lispx::makeLyticOperator %- 0) )

(def /
  #|If only one number is supplied in the ARGUMENTS, return the
   |reciprocal of that number.  If more than one number is supplied,
   |divide the first one by all of the later ones and return the result.
   |$(fn arguments)
   |$(type function)
   |# 
  (lispx::makeLyticOperator %/ 1) )


;;; Classes

(def\ findClass (name environment)
  #|Look up a class based on its NAME symbol (evaluated) in the given ENVIRONMENT.|#
  (eval (the Symbol name) environment))

(def\ className (class)
  #|Return the name symbol of the CLASS.|#
  (%className class))

(def\ subClass? (class superclass)
  #|Return true if the CLASS is a subclass of the SUPERCLASS, false otherwise.
   |A class is considered a subclass of itself.|#
  (%subClass? class superclass))

(defVau defClass (name superclass? slotSpecs . properties) env
  #|Define a new `StandardClass' with the given NAME, optional
   |SUPERCLASS?, and SLOT-SPECS.  The superclass defaults to
   |`standard-object'.  The SLOT-SPECS and PROPERTIES are currently
   |ignored.
   |$(syntax slotSpec symbol)
   |$(syntax property (:documentation docstring))
   |#
   ;; Slot-specs are ignored for now, but check that they are symbols nevertheless.
  (dolist (slotSpec slotSpecs) (the Symbol slotSpec))
  (let1 (superclass (findClass (opt? superclass? 'StandardObject) env))
    (eval (list def name (%makeStandardClass name superclass)) env)) )


;;; Generic Functions

(defVau defGeneric (name (receiver . parameters) . properties) env
  #|Define a new generic function with the given NAME.  The RECEIVER,
   |PARAMETERS, and PROPERTIES are currently ignored.
   |$(syntax property (:documentation docstring))
   |#
  (let1\ (generic args (apply (%getMethod (classOf (car args)) name) args))
    (eval (list def name generic) env)))

(defVau defMethod (name ((receiver className) . parameters) . forms) env
  #|Add a new method to the generic function named by NAME specialized
   |for the class named by CLASS-NAME.
   |#
  (let1 (method (eval (list* \ (list* receiver parameters) forms) env))
    (%addMethod (findClass className env) name method)))


;;; Standard Objects

(def\ makeInstance (class . slotInits)
  #|Create a new instance of CLASS (that must be a `standard-class').
   |The SLOT-INITS must be of even length, and alternately contain slot
   |names (symbols, typically keywords) and values.
   |#
  (apply %makeInstance (cons class slotInits)))

(def\ getSlot (object slotName)
  #|Return the value of the slot named SLOT-NAME of the OBJECT.|#
  (%getSlot object slotName))

(def\ setSlot (object slotName value)
  #|Set the value of the slot named SLOT-NAME of the OBJECT to VALUE.|#
  (%setSlot object slotName value))

(def\ slotBound? (object slotName)
  #|Return true if the slot named SLOT-NAME of the OBJECT is set, false otherwise.|#
  (%slotBound? object slotName))


;;; Type Checks

(def\ makeTypeError (datum expectedType)
  #|Create a `type-error' with the given DATUM and EXPECTED-TYPE.|#
  (makeInstance TypeError :datum datum :expectedType expectedType))

(def\ assertType (object class)
  #|Signal a `type-error' if the OBJECT is not an instance of the CLASS.|#
  (if (type? object class) object
    (error (makeTypeError object (className class)))))

(defVau the (className object) env
  #|Shorthand for `assertType'.  Signal a `type-error' if the OBJECT
   |is not an instance of the class named by CLASS-NAME.
   |#
  (assertType (eval object env) (eval (%the Symbol className) env)))

;;; Sequences

(defGeneric length (sequence)
  #|Return the number of elements in a sequence.|#)

(defMethod length ((seq List))
  (%len seq))

(defMethod length ((seq Null))
  (%len seq))

(defGeneric elt (sequence index)
  #|Return the sequence element at the specified index.|#)

(defMethod elt ((seq List) index)
  (nth index seq))

(defGeneric subseq (sequence start . end?)
  #|Create a sequence that is a copy of the subsequence
   |of the SEQUENCE bounded by START and optional END?.  If END?  is not
   |supplied or void, the subsequence stretches until the end of the list
   |#)

(defMethod subseq ((seq List) start . end?)
  (%listSubseq seq start (opt? end?)))

(defMethod subseq ((seq Null) start . end?)
  (%listSubseq seq start (opt? end?)))

(defMethod subseq ((seq String) start . end?)
  (%stringSubseq seq start (opt? end?)))


;;; Options

;; An option is either nil ("none"), or a one-element list ("some").
;; Variables holding options are conventionally suffixed with "?".

(def\ some (value)
  #|Create a one-element list from the VALUE.|#
  (list value))

(defVau ifOpt? ((name option?) then else) env
  #|Destructure the OPTION?.  If it's non-nil, evaluate the THEN form
   |with the NAME bound to the contents of the option.  If it's nil,
   |evaluate the ELSE form.
   |#
   ;; (Idea from Taylor R. Campbell's blag.)
  (let ((o? (eval option? env)))
    (if (null? o?)
        (eval else env)
        (eval (list (list vau (list name) #ignore then)
                    (car o?))
              env))))

(def\ (\01+ forms) 
  (if (null? forms) #null (if (null? (cdr forms)) (car forms) (list* 'begin forms))) )

(defVau ifOpt? ((pt opt?) then . else) env
  (let ((opt? (eval opt? env)))
    (if (null? opt?)
        (if (null? else) #null (eval (\01+ else) env))
        (eval (list (list 'vau (list pt) #ignore then) (car opt?)) env))))

(defMacro whenOpt? ((name option?) . forms)
  #|Destructure the OPTION?.  If it's non-nil, evaluate the FORMS with
   |the NAME bound to the contents of the option.  If it's nil, return nil.
   |#
  (list ifOpt? (list name option?) (list* begin forms) #null))

(defMacro whenOpt? ((pt opt?) . forms)
  (list 'ifOpt? (list pt opt?) (\01+ forms)))

(defMacro unlessOpt? (option? . forms)
  #|Destructure the OPTION?.  If it's nil, evaluate the FORMS.  If it's
   |non-nil, return nil.
   |#
  (list ifOpt? (list #ignore option?) #null (list* begin forms)))

(defMacro unlessOpt? (opt? . forms)
  (list* 'ifOpt? (list #ignore opt?) #null (\01+ forms)) )

(defVau opt? (option? . default?) env
  #|Return the contents of the OPTION?, or the DEFAULT? if the option
   |is nil.  The default itself defaults to void.  The DEFAULT? is
   |evaluated lazily, only when the OPTION? is nil.
   |#
  (ifOpt? (value (eval option? env))
    value
    (ifOpt? (default default?)
      (eval default env)
      #inert)))

(defVau opt* (list . defaults) env
  #|Similar to `opt', but provides DEFAULTS for any number of
   |elements of LIST.  This is useful for implementing functions that take
   |multiple opt? arguments.  Each default is evaluated lazily, only when needed.
   |#
  (letLoop -opt*- ((list (eval list env)) (defaults defaults))
    (if (null? list)
        (if (null? defaults)
            #null
            (cons (eval (car defaults) env) (-opt*- #null (cdr defaults))))
        (if (null? defaults)
            (cons (car list)                (-opt*- (cdr list) #null))
            (cons (car list)                (-opt*- (cdr list) (cdr defaults)))))))

(def\ getOpt? (option?)
  #|Returns the contents of the OPTION? or signals an error if it is nil.|#
  (opt? option? (simpleError "Option is nil")))


;;; Dynamic Binding

(defMacro ddef (var . val?)
  #|Define a new or update an existing dynamic variable with the given
   |NAME and opt? default VALUE.
   |$(fn (name))
   |$(fn (name value))
   |#
  (list* (list '%d\ (list var)) val?) )

(def\ dget (dynamicVariable)
  #|Return the current value of the DYNAMIC-VARIABLE.|#
  (dynamicVariable))

(def\ dset (dynamicVariable value)
  #|Set the current value of the DYNAMIC-VARIABLE.|#
  (dynamicVariable value))

(defMacro dlet (bindings exp . exps)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established parallely
   |as per `let'.
   |$(syntax binding (dynamicVariable value))
   |#
  (list* (list* '%d\ (map car bindings) exp exps) (map cadr bindings)) )  

(defMacro progv (var* val* exp . exps)
  #|Evaluate the FORMS with the list of DYNAMIC-VARIABLES temporarily
   |bound to new VALUES.  The DYNAMIC-VARIABLES and VALUES lists must have
   |the same length.
   |#
  (list* (list* '%d\ var* exp exps) val*) )

(defMacro dlet* (bindings . forms)
  #|Evaluate the FORMS with the dynamic variables specified by BINDINGS
   |temporarily bound to new values.  Bindings are established serially as
   |per `let*'.
   |#
  (if (null? bindings)
    (list* 'begin forms)
      (list 'dlet (list (car bindings))
        (list* 'dlet* (cdr bindings) forms))))


;;; Delimited Control Operators

;; These operators follow the API put forth in the delimcc library
;; at URL `http://okmij.org/ftp/continuations/implementations.html'.

(defMacro pushPrompt (prompt . forms)
  #|Push the PROMPT and evaluate the FORMS inside the prompt.  This
   |delimits the continuation.
   |#
  (list '%pushPrompt prompt (list* '\ () forms)))

(defMacro takeSubcont (prompt name . forms)
  #|Abort outwards to the PROMPT.  When the prompt is reached, evaluate
   |the FORMS with NAME bound to the captured continuation (which does not
   |include the prompt).
   |#
  (list '%takeSubcont prompt (list* '\ (list name) forms)))

(defMacro pushDelimSubcont (prompt continuation . forms)
  #|Push the PROMPT and compose the previously captured CONTINUATION
   |inside it.  The FORMS are then evaluated inside the new continuation.
   |#
  (list '%pushDelimSubcont prompt continuation (list* '\ () forms)))

(defMacro pushSubcontBarrier forms
  #|Push a continuation barrier that prevents the FORMS from capturing
   |any continuations to the outside.
   |#
  (list* '%pushSubcontBarrier (%makeEnv) forms))


;;; Coroutines

(defConstant +defaultPrompt+
  #|This prompt is used for general coroutine-like use of continuations.
   |#
  'defaultPrompt)

(defMacro coroutine forms
  #|Evaluate the FORMS in a context in which `yield' can be used to pause execution.
   |#
  (list* 'pushPrompt '+defaultPrompt+ forms))

(defMacro yield (name . forms)
  #|Pause the current coroutine.  In the place where the enclosing
   |`coroutine' (or `resume') was called, evaluate the FORMS with NAME
   |bound to the paused coroutine.  `resume' can later be used to restart
   |execution inside the coroutine.
   |#
  (list* 'takeSubcont '+defaultPrompt+ name forms))

(defMacro resume (k . forms)
  #|Resume the paused coroutine K and evaluate FORMS in the place where
   |`yield' was called in the coroutine.
   |#
  (list* 'pushDelimSubcont '+defaultPrompt+ k forms))
