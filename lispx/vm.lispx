; sostituzioni nei .lispx
; #^ -> ''
; #' -> ''
; #void -> #inert
; #nil -> #null

; boot.lispx
; commentare stringhe in eccesso nelle (%def name expr "..."), troppi parametri per la %def!

(%resetEnv)

(%def milli (@currentTimeMillis &java.lang.System))

(@clear (.methods vm))
(ctapv #t)
(prtrc 0)
(bndres 1)
(ddft #inert)
(aquote #f)

(%def Apv &Wat.Vm$Apv)
(%def Box &Wat.Vm$Box)
(%def Boolean &java.lang.Boolean)
(%def Class &java.lang.Class)
(%def Combinable &Wat.Vm$Combinable)
(%def Condition &Wat.Vm$Condition)
(%def Cons &Wat.Vm$Cons)
(%def DVar &Wat.Vm$DVar)
(%def Env &Wat.Vm$Env)
(%def Error &Wat.Vm$Error)
(%def Intern &Wat.Vm$Intern)
(%def Integer &java.lang.Integer)
(%def List &Wat.Vm$List)
(%def Null #null)
(%def Number &java.lang.Number)
(%def Object &java.lang.Object)
(%def Opvr &Wat.Vm$Opv)
(%def Symbol &Wat.Vm$Symbol)
(%def Keyword &Wat.Vm$Keyword)
(%def Obj &Wat.Vm$Obj)
(%def Opv &Wat.Vm$Opv)
(%def String &java.lang.String)
(%def Throwable &java.lang.Throwable)
(%def Inert &Wat.Vm$Inert)
(%def Ignore &Wat.Vm$Ignore)
(%def Utility &Wat.Utility)

(%def BuiltInClass Class)
(%def Dynamic DVar)
(%def Environment Env)
(%def Fexpr Opv)
(%def Function Apv)
(%def Operator Combinable)
(%def StandardClass Class)
(%def StandardObject Obj)

(%def AssertionError Error)
(%def MatchError Error)
(%def OutOfBoundsError Error)
(%def PromptNotFoundError Error)
(%def UnboundSymbolError Error)
(%def UnboundSlotError Error)
(%def TypeError Error)
(%def UnboundMethodError Error)

(%def \ %\)

(%def %zero? (\ (v) (%== v 0)))
(%def %inert? (\ (v) (%== v #inert)))

(%def %the (\ (class value)
  (if (%instanceof? class Class)
    (if (%instanceof? value class) value
      (%error (%$ "" "not a {:expectedType}: {:datum}") :type 'type :datum value :expectedType (%intern (@getSimpleName class))) )
    (%error (%$ "" "not a {:expectedType}: {:datum}") :type 'type :datum class :expectedType (%intern (@getSimpleName Class))) )))

(%def %className (\ (class) (%intern (@getSimpleName (%the Class class)))))
(%def %symbolName %internName)

(%def %intern->symbol  (\ (i) (if (%symbol? i) i (%symbol (%internName i)))))
(%def %intern->keyword (\ (i) (if (%keyword? i) i (%keyword (%internName i)))))

(%def %classSymbol %intern->symbol)
(%def %functionSymbol %intern->symbol)
(%def %variableSymbol %intern->symbol)
(%def %keywordSymbol %intern->keyword)

(%def %nth (\ (i l) (%the Integer i) (@car (%the Cons l) i)))
(%def %nthCdr (\ (i l) (%the Integer i) (%if (%zero? i) l (@cdr (%the Cons l) (%- i 1)))))

(%def %makeInstance %obj)
(%def %makeStandardClass (\ (name superclass) (%class name superclass)))
;(%def %makeStandardClass (\ (name superclass) (%class (%intern (@capitalize Utility (@camelize Utility (%$ "" name) "-"))) superclass)))

(%def %pushDelimSubcont %pushPromptSubcont)
(%def %pushPrompt ((\ (%pushPrompt) (%wrap %pushPrompt)) %pushPrompt))

(%def +rootPrompt+ %rootPrompt)
(%def %printStacktrace
  (\ (k)
    (%if (%!= (.nxt k) #null)
      (%printStacktrace (.nxt k)) )
    (%if (prstk) (log "--" k)) ))
(%def %panic (\ (e)
  (%throw #ignore e) ))

(%def %take (\ (i l) (%if (%zero? i) #null (%cons (%car l) (%take (%- i 1) (%cdr l))))))
(%def %listSubseq (\ (l s e) (%the Integer s) (%if (%! (%inert? e)) (%the Integer e)) (%def tail (%nthCdr s l)) (%if (%inert? e) tail (%take (%- e s) tail))))
(%def %stringSubseq (\ (seq start end) (%if (%inert? end) (@substring (%the String seq) (%the Integer start)) (@substring (%the String seq) (%the Integer start) (%the Integer end)))))

(load "lispx/src/boot.lispx")

(def finally %finally)
(def takeSubcont %takeSubcont)

(def %getSlot (\ (obj slot)
  ((%the StandardObject obj) (%the Intern slot)) ))

(def %setSlot (\ (obj slot value)
  ((%the StandardObject obj) (%the Intern slot) value) ))

(def %slotBound? (\ (obj slot)
  (@isBound (%the StandardObject obj) (%the Intern slot)) ))

   
; vedi signalsError più avanti o in test-util per codice simile
(def checkSlot 
  (\ (c slotSpecs)
    (letloop next ((slotSpecs slotSpecs))
      (if (null? slotSpecs) #t
        (let (((name value . rest-slotSpecs) slotSpecs))
          (if (or (%! (%slotBound? c name)) (%! (eq? (getSlot c name) value))) #f
            (next rest-slotSpecs) ))))))

(def\ lispx::makeTypecaseWithDefaultFunction (default)
  (vau (keyform . clauses) env
    (let ((key (eval keyform env)))
      (letloop -typecase- ((clauses clauses))
        (if (null? clauses) (default key)
          (let* ( (((test . forms) . restClauses) clauses)
                  (symbol? (%symbol? test))
                  (className (if symbol? test (car test)))
                  (class (findClass className env)) )
            (if (and (type? key class) (or symbol? (checkSlot key (map (\ (c) (eval c env)) (cdr test)))))
              (eval (list* begin forms) env)
              (-typecase- restClauses) )))))))

(def typecase (lispx::makeTypecaseWithDefaultFunction (\ (#ignore) #inert)))
(def etypecase (lispx::makeTypecaseWithDefaultFunction (\ (key) (error (makeTypeError key Object)))))

;(typecase (%obj StandardObject :a 3) ((Error) #t)) ;-> #inert
;(typecase (%obj StandardObject :a 3) (StandardObject #t)) ;-> #t
;(typecase (%obj StandardObject :a 3) ((StandardObject) #t))  
;(typecase (%obj UnboundSymbolError :type 'unbound) ((UnboundSymbolError :type 'unbound) "ok"))

(load "lispx/src/cond-sys.lispx")
;(load "lispx/src/stream.lispx")
;(load "lispx/src/read.lispx")
;(load "lispx/src/print.lispx")
;(load "lispx/src/js.lispx")

; lasciare commentato, bastano le successive definizioni
;(load "lispx/test/test-util.lispx")

(defMacro deftest (name expression . expected?)
  (list %test name expression (opt? expected? #t)))

(defMacro deftest* (name . forms)
  (list deftest name (list* prog1 #t forms)) )

(defVau defsuite (name . forms) env
  (eval (list* begin forms) env) )

(def userBreak error)

(defVau signalsError (form conditionClass . slotSpecs) env
  (let ((class (findClass conditionClass env)))
    (block exit
      (handlerCase (
        (StandardObject
          (\ (obj)
            (if (type? obj class)
              (begin
                (letloop -check-slots- ((slotSpecs slotSpecs))
                  (when (not (null? slotSpecs))
                    (let (((name value . rest-slotSpecs) slotSpecs))
                      (unless (eq? (getSlot obj name) (eval value env))
                        (returnFrom exit #f))
                      (-check-slots- rest-slotSpecs) )))
                (returnFrom exit #t) )
              (returnFrom exit #f) ))) )
        (eval form env) )
      #f )))

;(load "lispx/test/test-util-test.lispx") ;; mai
(load "lispx/test/boot-test.lispx")
(load "lispx/test/cond-sys-test.lispx")
(load "lispx/test/delimcc-test.lispx")
(load "lispx/test/control-test.lispx")

#|
(def\ runFiber* (thunk . values)
  (letloop -run- ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
        (cons (getSlot result 'value)
              (if (null? values)
                (-run- (fiberResume result) #null)
                (-run- (fiberResume result (car values)) (cdr values)) ))
        (list result))))

(runFiber* (\() (fiberYield 1) (fiberYield 2) 3)) -> (1 2 3)

(runFiberWithValues (\() (if (fiberYield 1) 2 3)) (#t)) -> (1 2)
(runFiberWithValues (\() (if (fiberYield 1) 2 3)) (#f)) -> (1 3)
(runFiberWithValues (\() (if (fiberYield 1) (fiberYield 2) 3)) #t) -> {Error ... 

(runFiber* (\() (if (fiberYield 1) (fiberYield 2) 3)) #t) -> (1 2 #inert)
(runFiber* (\() (if (fiberYield 1) (fiberYield 2) 3)) #t 4) -> (1 2 4)
(runFiber* (\() ((\ (a b) (+ a b)) (fiberYield 1) (fiberYield 2)) ) 3 4) -> (1 2 7)
|#

;(load "lispx/test/stream-test.lispx")
;(load "lispx/test/read-test.lispx")
;(load "lispx/test/print-test.lispx")
;(load "lispx/test/js-test.lispx")
;(load "lispx/test/hierarchy-test.lispx")

#|
(load "lispx/tool/repl/repl.lispx")
(def uprint print)
;(def repl:%displayPrompt (\ (level) (if (== level 0) "* " (%$ level "]"))) )
(repl:run)
|#

(%def milli (%- (@currentTimeMillis &java.lang.System) milli))
(%$ "vm started in " (%$ milli "ms"))