; sostituzioni nei .lispx
; #^ -> ''
; #' -> ''
; #void -> #inert
; #nil -> #null

; boot.lispx
; commentare stringhe in eccesso nelle (%def name expr "..."), troppi parametri per la %def!

(%resetEnv)

(%def milli (@currentTimeMillis &java.lang.System))

(@clear (.methods vm))
(ctapv #t)
(prtrc 0)
(bndres 1)
(bdft #inert)
(aquote #f)

(%def Apv &Wat.Vm$Apv)
(%def Box &Wat.Vm$Box)
(%def Boolean &java.lang.Boolean)
(%def Class &java.lang.Class)
(%def Combinable &Wat.Vm$Combinable)
(%def Condition &Wat.Vm$Condition)
(%def Cons &Wat.Vm$Cons)
(%def Double &java.lang.Double)
(%def DVar &Wat.Vm$DVar)
(%def Env &Wat.Vm$Env)
(%def Error &Wat.Vm$Error)
(%def Intern &Wat.Vm$Intern)
(%def Integer &java.lang.Integer)
(%def List &Wat.Vm$List)
(%def Null #null)
(%def Number &java.lang.Number)
(%def Object &java.lang.Object)
(%def Opvr &Wat.Vm$Opv)
(%def Symbol &Wat.Vm$Symbol)
(%def Keyword &Wat.Vm$Keyword)
(%def Obj &Wat.Vm$Obj)
(%def Opv &Wat.Vm$Opv)
(%def String &java.lang.String)
(%def Throwable &java.lang.Throwable)
(%def Inert &Wat.Vm$Inert)
(%def Ignore &Wat.Vm$Ignore)
(%def Utility &Wat.Utility)

(%def BuiltInClass Class)
(%def Dynamic DVar)
(%def Environment Env)
(%def Fexpr Opv)
(%def Function Apv)
(%def Operator Combinable)
(%def StandardClass Class)
(%def StandardObject Obj)

(%def AssertionError Error)
(%def MatchError Error)
(%def OutOfBoundsError Error)
(%def PromptNotFoundError Error)
(%def UnboundSymbolError Error)
(%def UnboundSlotError Error)
(%def TypeError Error)
(%def UnboundMethodError Error)
(%def SimpleError Error)
(%def RestartError Error)

(%def %zero? (%\ (v) (%== v 0)))
(%def %inert? (%\ (v) (%== v #inert)))

(%def %className (%\ (class) (%intern (@getSimpleName (%the Class class)))))
(%def %symbolName %internName)

(%def %intern->symbol  (%\ (i) (if (%symbol? i) i (%symbol (%internName i)))))
(%def %intern->keyword (%\ (i) (if (%keyword? i) i (%keyword (%internName i)))))

(%def %classSymbol %intern->symbol)
(%def %functionSymbol %intern->symbol)
(%def %variableSymbol %intern->symbol)
(%def %keywordSymbol %intern->keyword)

(%def %cddr (%\ (cons) (%cdr (%cdr cons))))

(%def %nth (%\ (i l) (%the Integer i) (@car (%the Cons l) i)))
(%def %nthCdr (%\ (i l) (%the Integer i) (%if (%zero? i) l (@cdr (%the Cons l) (%- i 1)))))

(%def %makeInstance %obj)
(%def %makeStandardClass (%\ (name superclass) (%class name superclass)))
;(%def %makeStandardClass (%\ (name superclass) (%class (%intern (@capitalize Utility (@camelize Utility (%$ "" name) "-"))) superclass)))

(%def %pushDelimSubcont %pushPromptSubcont)
(%def %pushPrompt ((%\ (%pushPrompt) (%wrap %pushPrompt)) %pushPrompt))

(%def +rootPrompt+ %rootPrompt)
(%def %printStacktrace
  (%\ (k)
    (%if (%!= (.nxt k) #null)
      (%printStacktrace (.nxt k)) )
    (%if (prstk) (log "--" k)) ))
(%def %panic (%\ (e)
  (%throw #ignore e) ))

(%def %take (%\ (i l) (%if (%zero? i) #null (%cons (%car l) (%take (%- i 1) (%cdr l))))))
(%def %listSubseq (%\ (l s e) (%the Integer s) (%if (%! (%inert? e)) (%the Integer e)) (%def tail (%nthCdr s l)) (%if (%inert? e) tail (%take (%- e s) tail))))
(%def %stringSubseq (%\ (seq start end) (%if (%inert? end) (@substring (%the String seq) (%the Integer start)) (@substring (%the String seq) (%the Integer start) (%the Integer end)))))

(load "lispx/src/boot.lispx")

(def finally %finally)
(def takeSubcont %takeSubcont)

(def %getSlot (\ (obj slot)
  ((the StandardObject obj) (the Intern slot)) ))

(def %setSlot (\ (obj slot value)
  ((the StandardObject obj) (the Intern slot) value) ))

(def %slotBound? (\ (obj slot)
  (@isBound (the StandardObject obj) (the Intern slot)) ))

(load "lispx/src/cond-sys.lispx")
;(load "lispx/src/stream.lispx")
;(load "lispx/src/read.lispx")
;(load "lispx/src/print.lispx")
;(load "lispx/src/js.lispx")

; lasciare commentato, bastano le successive definizioni
;(load "lispx/test/test-util.lispx")

(defMacro deftest (name expression . expected?)
  (list %test name expression (opt? expected? #t)))

(defMacro deftest* (name . forms)
  (list deftest name (list* prog1 #t forms)) )

(defVau defsuite (name . forms) env
  (eval (list* begin forms) env) )

(def userBreak error)

(defVau signalsError (form conditionClass . slotSpecs) env
  (let ((class (findClass conditionClass env)))
    (block exit
      (handlerCase (
        (StandardObject
          (\ (obj)
            (if (type? obj class)
              (begin
                (letLoop -check-slots- ((slotSpecs slotSpecs))
                  (when (not (null? slotSpecs))
                    (let (((name value . slotSpecs) slotSpecs))
                      (unless (eq? (getSlot obj name) (eval value env))
                        (returnFrom exit #f))
                      (-check-slots- slotSpecs) )))
                (returnFrom exit #t) )
              (returnFrom exit #f) ))) )
        (eval form env) )
      #f )))

;(load "lispx/test/test-util-test.lispx") ;; mai
(load "lispx/test/boot-test.lispx")
(load "lispx/test/cond-sys-test.lispx")
(load "lispx/test/delimcc-test.lispx")
(load "lispx/test/control-test.lispx")

#|
(def\ runFiber* (thunk . values)
  (letLoop -run- ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
        (cons (getSlot result 'value)
              (if (null? values)
                (-run- (fiberResume result) #null)
                (-run- (fiberResume result (car values)) (cdr values)) ))
        (list result))))

(runFiber* (\() (fiberYield 1) (fiberYield 2) 3)) -> (1 2 3)

(runFiber* (\() (if (fiberYield 1) (fiberYield 2) 3)) #t) -> (1 2 #inert)
(runFiber* (\() (if (fiberYield 1) (fiberYield 2) 3)) #t 4) -> (1 2 4)
(runFiber* (\() ((\ (a b) (+ a b)) (fiberYield 1) (fiberYield 2)) ) 3 4) -> (1 2 7)
|#

;(load "lispx/test/stream-test.lispx")
;(load "lispx/test/read-test.lispx")
;(load "lispx/test/print-test.lispx")
;(load "lispx/test/js-test.lispx")
;(load "lispx/test/hierarchy-test.lispx")

#|
(load "lispx/tool/repl/repl.lispx")
(def uprint print)
(repl:run)
x
(invokeRestart 'abort)
|#

(%def milli (%- (@currentTimeMillis &java.lang.System) milli))
(%$ "vm started in " (%$ milli "ms"))