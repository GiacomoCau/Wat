; sostituzioni nei .lispx
; #^ -> ''
; #' -> ''
; #void -> #inert
; #nil -> #null

; boot.lispx
; commentare stringhe in eccesso nelle (%def name expr "..."), troppi parametri per la %def!

(%resetEnv)

(%def milli (@currentTimeMillis &java.lang.System))

(@clear (.methods vm))
(ctapv #f)
(prtrc 0)
(bndres 0)
(boxdft #inert)
(aquote #t)
(ttrue 0)

(%def Null #null)
(%def Any &Wat.Vm$Any)
(%def Apv &Wat.Vm$Apv)
(%def At &Wat.Vm$At)
(%def Box &Wat.Vm$Box)
(%def Boolean &java.lang.Boolean)
(%def Class &java.lang.Class)
(%def Combinable &Wat.Vm$Combinable)
(%def Condition &Wat.Vm$Condition)
(%def Cons &Wat.Vm$Cons)
(%def Date &java.util.Date)
(%def Dot &Wat.Vm$Dot)
(%def Double &java.lang.Double)
(%def DVar &Wat.Vm$DVar)
(%def Env &Wat.Vm$Env)
(%def Error &Wat.Vm$Error)
(%def Ignore &Wat.Vm$Ignore)
(%def Inert &Wat.Vm$Inert)
(%def Intern &Wat.Vm$Intern)
(%def Integer &java.lang.Integer)
(%def Keyword &Wat.Vm$Keyword)
(%def JFun &Wat.Vm$JFun)
(%def List &Wat.Vm$List)
(%def Math &java.lang.Math)
(%def Number &java.lang.Number)
(%def Object &java.lang.Object)
(%def Opv &Wat.Vm$Opv)
(%def Keyword &Wat.Vm$Keyword)
(%def Obj &Wat.Vm$Obj)
(%def Object &java.lang.Object)
(%def Opv &Wat.Vm$Opv)
(%def Symbol &Wat.Vm$Symbol)
(%def System &java.lang.System)
(%def String &java.lang.String)
(%def Throwable &java.lang.Throwable)
(%def Inert &Wat.Vm$Inert)
(%def Ignore &Wat.Vm$Ignore)
(%def Utility &Wat.Utility)

(%def Fexpr Opv)
(%def Function Apv)
(%def Operator Combinable)
(%def StandardClass Class)

(%def AssertionError Error)
(%def MatchError Error)
(%def OutOfBoundsError Error)
(%def PromptNotFoundError Error)
(%def SimpleError Error)
(%def RestartError Error)

(%def %zero? (%\ (v) (%== v 0)))
(%def %inert? (%\ (v) (%== v #inert)))

(%def %nth (%\ (i l) (%the Integer i) (@car (%the Cons l) i)))
(%def %nthCdr (%\ (i l) (%the Integer i) (%if (%zero? i) l (@cdr (%the Cons l) (%- i 1)))))

(%def %take (%\ (i l) (%if (%zero? i) #null (%cons (%car l) (%take (%- i 1) (%cdr l))))))
(%def %listSubseq (%\ (l s e) (%the Integer s) (%if (%! (%inert? e)) (%the Integer e)) (%def tail (%nthCdr s l)) (%if (%inert? e) tail (%take (%- e s) tail))))
(%def %stringSubseq (%\ (seq start end) (%if (%inert? end) (@substring (%the String seq) (%the Integer start)) (@substring (%the String seq) (%the Integer start) (%the Integer end)))))

;(%def %pushPrompt ((%\ (%pushPrompt) (%wrap %pushPrompt)) %pushPrompt))

(%def %className (%\ (class) (%intern (@getSimpleName (%the Class class)))))
;(%def %newClass ((%\ (%newClass) (%\ (name superclass) (%newClass (%intern (@capitalize Utility (@camelize Utility (%$ "" name) "-"))) superclass))) %newClass))

(%def %getSlot (%\ (obj slot) ((%the Obj obj) (%the Intern slot)) ))
(%def %setSlot (%\ (obj slot value) ((%the Obj obj) (%the Intern slot) value) ))
(%def %slotBound? (%\ (obj slot) (@isBound (%the Obj obj) (%the Intern slot)) ))


;;; Boot

(load "lispx/src/boot.lispx")
(load "lispx/src/cond-sys.lispx")

(def userBreak error)

;(load "lispx/src/stream.lispx")
;(load "lispx/src/read.lispx")
;(load "lispx/src/print.lispx")
;(load "lispx/src/js.lispx")


;;;; Test

; lasciare commentati, bastano le successive definizioni
;(load "lispx/test/test-util.lispx")
;(load "lispx/test/test-util-test.lispx")

(defMacro deftest (name expression . expected?)
  (list %test name expression (opt? expected? #t)))

(defMacro deftest* (name . forms)
  (list deftest name (list* prog1 #t forms)) )

(defVau defsuite (name . forms) env
  (eval (list* begin forms) env) )

(defVau signalsError (form conditionClass . slots) env
  (let1 (class (findClass conditionClass env))
    (block exit
      (handlerCase
        ( (Obj
            (\ (obj)
              (if (type? obj class)
                (let1 check (slots slots)
                  (if (null? slots) (exit #t)
                    (let1 ((name value . slots) slots)
                      (unless (eq? (getSlot obj name) (eval value env)) (exit #f))
                      (check slots) )))
                (exit #f) ))) )
        (eval form env) )
      #f )))

(load "lispx/test/boot-test.lispx")
(load "lispx/test/cond-sys-test.lispx")
(load "lispx/test/delimcc-test.lispx")
(load "lispx/test/control-test.lispx")

(def\ runFiber* (thunk . values)
  (let run ((result (fiber (thunk))) (values values))
    (if (type? result YieldRecord)
      (cons (getSlot result 'value)
        (if (null? values)
          (run (fiberResume result) #null)
          (run (fiberResume result (car values)) (cdr values)) ))
      (list result) )))

(%assert (runFiber* (\ () (fiberYield 1) (fiberYield 2) 3)) '(1 2 3))

(%assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #t) '(1 2 #inert))
(%assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #t #_) '(1 2 #ignore))
(%assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #t 4) '(1 2 4))
(%assert (runFiber* (\ () (if (fiberYield 1) (fiberYield 2) 3)) #f) '(1 3))

(%assert (runFiber* (\ () ((\ (a b) (+ a b)) (fiberYield 1) (fiberYield 2)) ) 3 4) '(1 2 7))


;(load "lispx/test/stream-test.lispx")
;(load "lispx/test/read-test.lispx")
;(load "lispx/test/print-test.lispx")
;(load "lispx/test/js-test.lispx")
;(load "lispx/test/hierarchy-test.lispx")


#|
(load "lispx/tool/repl/repl.lispx")
(def uprint print)
(repl:run)
x
(invokeRestart 'abort)
(+ 100 x)
(invokeRestart 'useValue 42)
|#

(%def milli (%- (@currentTimeMillis &java.lang.System) milli))
(%$ "vm started in " (%$ milli "ms"))